<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Lambda," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="1. 什么是λ表达式λ表达式本质上是一个匿名方法。让我们来看下面这个例子： public int add(int x, int y) {     return x + y; } 转成λ表达式后是这个样子： (int x, int y) -&amp;gt; x + y; 参数类型也可以省略，Java编译器会根据上下文推断出来： (x, y) -&amp;gt; x + y; //返回两数之和 或者 (x, y) -">
<meta name="keywords" content="Lambda">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Lambda">
<meta property="og:url" content="https://justxzm.github.io/2017/03/31/Java-Lambda/index.html">
<meta property="og:site_name" content="JUST DO IT">
<meta property="og:description" content="1. 什么是λ表达式λ表达式本质上是一个匿名方法。让我们来看下面这个例子： public int add(int x, int y) {     return x + y; } 转成λ表达式后是这个样子： (int x, int y) -&amp;gt; x + y; 参数类型也可以省略，Java编译器会根据上下文推断出来： (x, y) -&amp;gt; x + y; //返回两数之和 或者 (x, y) -">
<meta property="og:updated_time" content="2017-03-31T15:45:15.364Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Lambda">
<meta name="twitter:description" content="1. 什么是λ表达式λ表达式本质上是一个匿名方法。让我们来看下面这个例子： public int add(int x, int y) {     return x + y; } 转成λ表达式后是这个样子： (int x, int y) -&amp;gt; x + y; 参数类型也可以省略，Java编译器会根据上下文推断出来： (x, y) -&amp;gt; x + y; //返回两数之和 或者 (x, y) -">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://justxzm.github.io/2017/03/31/Java-Lambda/"/>





  <title> Java Lambda | JUST DO IT </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JUST DO IT</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://justxzm.github.io/2017/03/31/Java-Lambda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Try.Catch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JUST DO IT">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java Lambda
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-31T23:33:26+08:00">
                2017-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/31/Java-Lambda/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/31/Java-Lambda/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-eye"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="1-什么是λ表达式"><a href="#1-什么是λ表达式" class="headerlink" title="1. 什么是λ表达式"></a><strong>1. 什么是λ表达式</strong></h3><p>λ表达式本质上是一个匿名方法。让我们来看下面这个例子：</p>
<pre><code>public int add(int x, int y) {
    return x + y;
}
</code></pre><p>转成λ表达式后是这个样子：</p>
<pre><code>(int x, int y) -&gt; x + y;
</code></pre><p>参数类型也可以省略，Java编译器会根据上下文推断出来：</p>
<pre><code>(x, y) -&gt; x + y; //返回两数之和
</code></pre><p>或者</p>
<pre><code>(x, y) -&gt; { return x + y; } //显式指明返回值
</code></pre><p>可见λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。</p>
<p>下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）：</p>
<pre><code>() -&gt; { System.out.println(&quot;Hello Lambda!&quot;); }
</code></pre><p>如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：</p>
<pre><code>c -&gt; { return c.size(); }
</code></pre><h3 id="2-λ表达式的类型（它是Object吗？）"><a href="#2-λ表达式的类型（它是Object吗？）" class="headerlink" title="2. λ表达式的类型（它是Object吗？）"></a><strong>2. λ表达式的类型（它是Object吗？）</strong></h3><p>λ表达式可以被当做是一个Object（注意措辞）。λ表达式的类型，叫做“目标类型（target type）”。λ表达式的目标类型是“函数接口（functional interface）”，这是Java8新引入的概念。它的定义是：一个接口，如果只有一个显式声明的抽象方法，那么它就是一个函数接口。一般用@FunctionalInterface标注出来（也可以不标）。举例如下：</p>
<pre><code>@FunctionalInterface
public interface Runnable {void run();}

public interface Callable&lt;V&gt; {V call() throws Exception;}

public interface ActionListener {void actionPerformed(ActionEvent e);}

public interface Comparator&lt;T&gt; {int compare(T o1, T o2); boolean equals(Object obj);}
</code></pre><p>注意最后这个Comparator接口。它里面声明了两个方法，貌似不符合函数接口的定义，但它的确是函数接口。这是因为equals方法是Object的，所有的接口都会声明Object的public方法——虽然大多是隐式的。所以，Comparator显式的声明了equals不影响它依然是个函数接口。</p>
<p>你可以用一个λ表达式为一个函数接口赋值：</p>
<pre><code>Runnable r1 = () -&gt; {System.out.println(&quot;Hello Lambda!&quot;);};
</code></pre><p>然后再赋值给一个Object：</p>
<pre><code>Object obj = r1;
</code></pre><p>但却不能这样干：</p>
<pre><code>Object obj = () -&gt; {System.out.println(&quot;Hello Lambda!&quot;);}; 
// ERROR! Object is not a functional interface!
</code></pre><p>必须显式的转型成一个函数接口才可以：</p>
<pre><code>Object o = (Runnable) () -&gt; { System.out.println(&quot;hi&quot;); }; // correct
</code></pre><p>一个λ表达式只有在转型成一个函数接口后才能被当做Object使用。所以下面这句也不能编译：</p>
<pre><code>System.out.println( () -&gt; {} ); //错误! 目标类型不明
</code></pre><p>必须先转型:</p>
<pre><code>System.out.println( (Runnable)() -&gt; {} ); // 正确
</code></pre><p>假设你自己写了一个函数接口，长的跟Runnable一模一样：</p>
<pre><code>@FunctionalInterface
public interface MyRunnable {
    public void run();
}
</code></pre><p>那么</p>
<pre><code>Runnable r1 =    () -&gt; {System.out.println(&quot;Hello Lambda!&quot;);};
MyRunnable2 r2 = () -&gt; {System.out.println(&quot;Hello Lambda!&quot;);};
</code></pre><p>JDK预定义了很多函数接口以避免用户重复定义。最典型的是Function：</p>
<pre><code>@FunctionalInterface
public interface Function&lt;T, R&gt; {  
    R apply(T t);
}
</code></pre><p>这个接口代表一个函数，接受一个T类型的参数，并返回一个R类型的返回值。   </p>
<p>另一个预定义函数接口叫做Consumer，跟Function的唯一不同是它没有返回值。</p>
<pre><code>@FunctionalInterface
public interface Consumer&lt;T&gt; {
    void accept(T t);
}
</code></pre><p>还有一个Predicate，用来判断某项条件是否满足。经常用来进行筛滤操作：</p>
<pre><code>@FunctionalInterface
public interface Predicate&lt;T&gt; {
    boolean test(T t);
}
</code></pre><p>综上所述，一个λ表达式其实就是定义了一个匿名方法，只不过这个方法必须符合至少一个函数接口。</p>
<h3 id="3-λ表达式的使用"><a href="#3-λ表达式的使用" class="headerlink" title="3. λ表达式的使用"></a><strong>3. λ表达式的使用</strong></h3><h4 id="λ表达式用在何处"><a href="#λ表达式用在何处" class="headerlink" title="λ表达式用在何处"></a><strong><em>λ表达式用在何处</em></strong></h4><p>λ表达式主要用于替换以前广泛使用的内部匿名类，各种回调，比如事件响应器、传入Thread类的Runnable等。看下面的例子：</p>
<pre><code>Thread oldSchool = new Thread( new Runnable () {
    @Override
    public void run() {
        System.out.println(&quot;This is from an anonymous class.&quot;);
        }
} );
Thread gaoDuanDaQiShangDangCi = new Thread( () -&gt; {
    System.out.println(&quot;This is from an anonymous method (lambda exp).&quot;);
} );
</code></pre><p>注意第二个线程里的λ表达式，你并不需要显式地把它转成一个Runnable，因为Java能根据上下文自动推断出来：一个Thread的构造函数接受一个Runnable参数，而传入的λ表达式正好符合其run()函数，所以Java编译器推断它为Runnable。</p>
<p>从形式上看，λ表达式只是为你节省了几行代码。但将λ表达式引入Java的动机并不仅仅为此。Java8有一个短期目标和一个长期目标。短期目标是：配合“集合类批处理操作”的内部迭代和并行处理（下面将要讲到）；长期目标是将Java向函数式编程语言这个方向引导（并不是要完全变成一门函数式编程语言，只是让它有更多的函数式编程语言的特性），也正是由于这个原因，Oracle并没有简单地使用内部类去实现λ表达式，而是使用了一种更动态、更灵活、易于将来扩展和改变的策略（invokedynamic）。</p>
<h4 id="λ表达式与集合类批处理操作（或者叫块操作）"><a href="#λ表达式与集合类批处理操作（或者叫块操作）" class="headerlink" title="λ表达式与集合类批处理操作（或者叫块操作）"></a><strong><em>λ表达式与集合类批处理操作（或者叫块操作）</em></strong></h4><p>上文提到了集合类的批处理操作。这是Java8的另一个重要特性，它与λ表达式的配合使用乃是Java8的最主要特性。集合类的批处理操作API的目的是实现集合类的“内部迭代”，并期望充分利用现代多核CPU进行并行计算。<br>Java8之前集合类的迭代（Iteration）都是外部的，即客户代码。而内部迭代意味着改由Java类库来进行迭代，而不是客户代码。例如：</p>
<pre><code>for(Object o: list) { // 外部迭代
    System.out.println(o);
}
</code></pre><p>可以写成</p>
<pre><code>//forEach函数实现内部迭代
list.forEach(o -&gt; {System.out.println(o);}); 
</code></pre><p>集合类（包括List）现在都有一个forEach方法，对元素进行迭代（遍历），所以我们不需要再写for循环了。forEach方法接受一个函数接口Consumer做参数，所以可以使用λ表达式。</p>
<p>这种内部迭代方法广泛存在于各种语言，如C++的STL算法库、Python、ruby、Scala等。</p>
<p>Java8为集合类引入了另一个重要概念：流（stream）。一个流通常以一个集合类实例为其数据源，然后在其上定义各种操作。流的API设计使用了管道（pipelines）模式。对流的一次操作会返回另一个流。如同IO的API或者StringBuffer的append方法那样，从而多个不同的操作可以在一个语句里串起来。看下面的例子：</p>
<pre><code>List&lt;Shape&gt; shapes = ...
shapes.stream()
  .filter(s -&gt; s.getColor() == BLUE)
  .forEach(s -&gt; s.setColor(RED));
</code></pre><p>首先调用stream方法，以集合类对象shapes里面的元素为数据源，生成一个流。然后在这个流上调用filter方法，挑出蓝色的，返回另一个流。最后调用forEach方法将这些蓝色的物体喷成红色。（forEach方法不再返回流，而是一个终端方法，类似于StringBuffer在调用若干append之后的那个toString）</p>
<p>filter方法的参数是Predicate类型，forEach方法的参数是Consumer类型，它们都是函数接口，所以可以使用λ表达式。</p>
<p>还有一个方法叫parallelStream()，顾名思义它和stream()一样，只不过指明要并行处理，以期充分利用现代CPU的多核特性。</p>
<pre><code>shapes.parallelStream(); // 或shapes.stream().parallel()
</code></pre><p>来看更多的例子。下面是典型的大数据处理方法，Filter-Map-Reduce：</p>
<pre><code>//给出一个String类型的数组，找出其中所有不重复的素数
public void distinctPrimary(String... numbers) {
    List&lt;String&gt; l = Arrays.asList(numbers);
    List&lt;Integer&gt; r = l.stream()
            .map(e -&gt; new Integer(e))
            .filter(e -&gt; Primes.isPrime(e))
            .distinct()
            .collect(Collectors.toList());
    System.out.println(&quot;distinctPrimary result is: &quot; + r);
}
</code></pre><p>第一步：传入一系列String（假设都是合法的数字），转成一个List，然后调用stream()方法生成流。</p>
<p>第二步：调用流的map方法把每个元素由String转成Integer，得到一个新的流。map方法接受一个Function类型的参数，上面介绍了，Function是个函数接口，所以这里用λ表达式。</p>
<p>第三步：调用流的filter方法，过滤那些不是素数的数字，并得到一个新流。filter方法接受一个Predicate类型的参数，上面介绍了，Predicate是个函数接口，所以这里用λ表达式。</p>
<p>第四步：调用流的distinct方法，去掉重复，并得到一个新流。这本质上是另一个filter操作。</p>
<p>第五步：用collect方法将最终结果收集到一个List里面去。collect方法接受一个Collector类型的参数，这个参数指明如何收集最终结果。在这个例子中，结果简单地收集到一个List中。我们也可以用Collectors.toMap(e-&gt;e, e-&gt;e)把结果收集到一个Map中，它的意思是：把结果收到一个Map，用这些素数自身既作为键又作为值。toMap方法接受两个Function类型的参数，分别用以生成键和值，Function是个函数接口，所以这里都用λ表达式。</p>
<p>你可能会觉得在这个例子里，List l被迭代了好多次，map，filter，distinct都分别是一次循环，效率会不好。实际并非如此。这些返回另一个Stream的方法都是“懒（lazy）”的，而最后返回最终结果的collect方法则是“急（eager）”的。在遇到eager方法之前，lazy的方法不会执行。</p>
<p>当遇到eager方法时，前面的lazy方法才会被依次执行。而且是管道贯通式执行。这意味着每一个元素依次通过这些管道。例如有个元素“3”，首先它被map成整数型3；然后通过filter，发现是素数，被保留下来；又通过distinct，如果已经有一个3了，那么就直接丢弃，如果还没有则保留。这样，3个操作其实只经过了一次循环。</p>
<blockquote>
<p>除collect外其它的eager操作还有forEach，toArray，reduce等。</p>
</blockquote>
<p>下面来看一下也许是最常用的收集器方法，groupingBy：</p>
<pre><code>//给出一个String类型的数组，找出其中各个素数，并统计其出现次数
public void primaryOccurrence(String... numbers) {
    List&lt;String&gt; l = Arrays.asList(numbers);
    Map&lt;Integer, Integer&gt; r = l.stream()
        .map(e -&gt; new Integer(e))
        .filter(e -&gt; Primes.isPrime(e))
        .collect( Collectors.groupingBy(p-&gt;p, Collectors.summingInt(p-&gt;1)) );
    System.out.println(&quot;primaryOccurrence result is: &quot; + r);
}
</code></pre><p>注意这一行：</p>
<pre><code>Collectors.groupingBy(p-&gt;p, Collectors.summingInt(p-&gt;1))
</code></pre><p>它的意思是：把结果收集到一个Map中，用统计到的各个素数自身作为键，其出现次数作为值。</p>
<p>下面是一个reduce的例子：</p>
<pre><code>//给出一个String类型的数组，求其中所有不重复素数的和
public void distinctPrimarySum(String... numbers) {
    List&lt;String&gt; l = Arrays.asList(numbers);
    int sum = l.stream()
        .map(e -&gt; new Integer(e))
        .filter(e -&gt; Primes.isPrime(e))
        .distinct()
        .reduce(0, (x,y) -&gt; x+y); // equivalent to .sum()
    System.out.println(&quot;distinctPrimarySum result is: &quot; + sum);
}
</code></pre><p>reduce方法用来产生单一的一个最终结果。</p>
<p>流有很多预定义的reduce操作，如sum()，max()，min()等。</p>
<p>再举个现实世界里的例子比如：</p>
<pre><code>// 统计年龄在25-35岁的男女人数、比例
public void boysAndGirls(List&lt;Person&gt; persons) {
    Map&lt;Integer, Integer&gt; result = persons.parallelStream().filter(p -&gt;
     p.getAge()&gt;=25 &amp;&amp; p.getAge()&lt;=35).
        collect(
            Collectors.groupingBy(p-&gt;p.getSex(), Collectors.summingInt(p-&gt;1))
    );
    System.out.print(&quot;boysAndGirls result is &quot; + result);
    System.out.println(&quot;, ratio (male : female) is &quot; + (float)result.get
    (Person.MALE)/result.get(Person.FEMALE));
}
</code></pre><h4 id="λ表达式的更多用法"><a href="#λ表达式的更多用法" class="headerlink" title="λ表达式的更多用法"></a><strong><strong>λ表达式的更多用法</strong></strong></h4><pre><code>// 嵌套的λ表达式
Callable&lt;Runnable&gt; c1 = () -&gt; () -&gt; { System.out.println(&quot;Nested lambda&quot;); };
c1.call().run();

// 用在条件表达式中
Callable&lt;Integer&gt; c2 = true ? (() -&gt; 42) : (() -&gt; 24);
System.out.println(c2.call());

// 定义一个递归函数，注意须用this限定
protected UnaryOperator&lt;Integer&gt; factorial = i -&gt; i == 0 ? 1 : i * this.factorial.apply( i - 1 );
...
System.out.println(factorial.apply(3));
</code></pre><p>在Java中，随声明随调用的方式是不行的，比如下面这样，声明了一个λ表达式(x, y) -&gt; x + y，同时企图通过传入实参(2, 3)来调用它：</p>
<pre><code>int five = ( (x, y) -&gt; x + y ) (2, 3); // ERROR! try to call a lambda in-place
</code></pre><p>这在C++中是可以的，但Java中不行。Java的λ表达式只能用作赋值、传参、返回值等。</p>
<h3 id="4-其它相关概念"><a href="#4-其它相关概念" class="headerlink" title="4. 其它相关概念"></a><strong>4. 其它相关概念</strong></h3><h4 id="捕获（Capture）"><a href="#捕获（Capture）" class="headerlink" title="捕获（Capture）"></a><strong><em>捕获（Capture）</em></strong></h4><p>捕获的概念在于解决在λ表达式中我们可以使用哪些外部变量（即除了它自己的参数和内部定义的本地变量）的问题。</p>
<p>答案是：与内部类非常相似，但有不同点。不同点在于内部类总是持有一个其外部类对象的引用。而λ表达式呢，除非在它内部用到了其外部类（包围类）对象的方法或者成员，否则它就不持有这个对象的引用。</p>
<p>在Java8以前，如果要在内部类访问外部对象的一个本地变量，那么这个变量必须声明为final才行。在Java8中，这种限制被去掉了，代之以一个新的概念，“effectively final”。它的意思是你可以声明为final，也可以不声明final但是按照final来用，也就是一次赋值永不改变。换句话说，保证它加上final前缀后不会出编译错误。</p>
<p>在Java8中，内部类和λ表达式都可以访问effectively final的本地变量。λ表达式的例子如下：</p>
<pre><code> ...    
int tmp1 = 1; //包围类的成员变量
static int tmp2 = 2; //包围类的静态成员变量
public void testCapture() {
    int tmp3 = 3; //没有声明为final，但是effectively final的本地变量
    final int tmp4 = 4; //声明为final的本地变量
    int tmp5 = 5; //普通本地变量

    Function&lt;Integer, Integer&gt; f1 = i -&gt; i + tmp1;
    Function&lt;Integer, Integer&gt; f2 = i -&gt; i + tmp2;
    Function&lt;Integer, Integer&gt; f3 = i -&gt; i + tmp3;
    Function&lt;Integer, Integer&gt; f4 = i -&gt; i + tmp4;
    Function&lt;Integer, Integer&gt; f5 = i -&gt; {
        tmp5  += i; // 编译错！对tmp5赋值导致它不是effectively final的
        return tmp5;
    };
    ...
    tmp5 = 9; // 编译错！对tmp5赋值导致它不是effectively final的
}
...
</code></pre><p>Java要求本地变量final或者effectively final的原因是多线程并发问题。内部类、λ表达式都有可能在不同的线程中执行，允许多个线程同时修改一个本地变量不符合Java的设计理念。</p>
<h4 id="方法引用（Method-reference）"><a href="#方法引用（Method-reference）" class="headerlink" title="方法引用（Method reference）"></a><strong><em>方法引用（Method reference）</em></strong></h4><p>任何一个λ表达式都可以代表某个函数接口的唯一方法的匿名描述符。我们也可以使用某个类的某个具体方法来代表这个描述符，叫做方法引用。例如：</p>
<pre><code>Integer::parseInt //静态方法引用
System.out::print //实例方法引用
Person::new       //构造器引用
</code></pre><p>下面是一组例子，教你使用方法引用代替λ表达式：</p>
<pre><code>//c1 与 c2 是一样的（静态方法引用）
Comparator&lt;Integer&gt; c2 = (x, y) -&gt; Integer.compare(x, y);
Comparator&lt;Integer&gt; c1 = Integer::compare;

//下面两句是一样的（实例方法引用1）
persons.forEach(e -&gt; System.out.println(e));
persons.forEach(System.out::println);

//下面两句是一样的（实例方法引用2）
persons.forEach(person -&gt; person.eat());
persons.forEach(Person::eat);

//下面两句是一样的（构造器引用）
strList.stream().map(s -&gt; new Integer(s));
strList.stream().map(Integer::new);
</code></pre><p>使用方法引用，你的程序会变得更短些。现在distinctPrimarySum方法可以改写如下：</p>
<pre><code>public void distinctPrimarySum(String... numbers) {
    List&lt;String&gt; l = Arrays.asList(numbers);
    int sum = l.stream().map(Integer::new).filter(Primes::isPrime).distinct().sum();
    System.out.println(&quot;distinctPrimarySum result is: &quot; + sum);
}
</code></pre><p>还有一些其它的方法引用:</p>
<pre><code>super::toString //引用某个对象的父类方法
String[]::new //引用一个数组的构造器
</code></pre><h4 id="默认方法（Default-method）"><a href="#默认方法（Default-method）" class="headerlink" title="默认方法（Default method）"></a><strong><em>默认方法（Default method）</em></strong></h4><p>Java8中，接口声明里可以有方法实现了，叫做默认方法。在此之前，接口里的方法全部是抽象方法。</p>
<pre><code>public interface MyInterf {
    String m1();
    default String m2() {
        return &quot;Hello default method!&quot;;
    }
}
</code></pre><p>这实际上混淆了接口和抽象类，但一个类仍然可以实现多个接口，而只能继承一个抽象类。</p>
<p>这么做的原因是：由于Collection库需要为批处理操作添加新的方法，如forEach()，stream()等，但是不能修改现有的Collection接口——如果那样做的话所有的实现类都要进行修改，包括很多客户自制的实现类。所以只好使用这种妥协的办法。</p>
<p>如此一来，我们就面临一种类似多继承的问题。如果类Sub继承了两个接口，Base1和Base2，而这两个接口恰好具有完全相同的两个默认方法，那么就会产生冲突。这时Sub类就必须通过重载来显式指明自己要使用哪一个接口的实现（或者提供自己的实现）：</p>
<pre><code>public class Sub implements Base1, Base2 {
    public void hello() {
        Base1.super.hello(); //使用Base1的实现
    }
}
</code></pre><p>除了默认方法，Java8的接口也可以有静态方法的实现：</p>
<pre><code>public interface MyInterf {
    String m1();
    default String m2() {
        return &quot;Hello default method!&quot;;
    }
    static String m3() {
        return &quot;Hello static method in Interface!&quot;;
    }
}
</code></pre><h4 id="生成器函数（Generator-function）"><a href="#生成器函数（Generator-function）" class="headerlink" title="生成器函数（Generator function）"></a><strong><em>生成器函数（Generator function）</em></strong></h4><p>有时候一个流的数据源不一定是一个已存在的集合对象，也可能是个“生成器函数”。一个生成器函数会产生一系列元素，供给一个流。Stream.generate(Supplier<t> s)就是一个生成器函数。其中参数Supplier是一个函数接口，里面有唯一的抽象方法 <t> get()。</t></t></p>
<p>下面这个例子生成并打印5个随机数：</p>
<pre><code>Stream.generate(Math::random).limit(5).forEach(System.out::println);
</code></pre><p>注意这个limit(5)，如果没有这个调用，那么这条语句会永远地执行下去。也就是说这个生成器是无穷的。这种调用叫做终结操作，或者短路（short-circuiting）操作。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Lambda/" rel="tag"># Lambda</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/31/Java内存泄露/" rel="next" title="Java内存泄露">
                <i class="fa fa-chevron-left"></i> Java内存泄露
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/29/Copy-On-Write/" rel="prev" title="Copy On Write">
                Copy On Write <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/03/31/Java-Lambda/"
           data-title="Java Lambda" data-url="https://justxzm.github.io/2017/03/31/Java-Lambda/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Try.Catch" />
          <p class="site-author-name" itemprop="name">Try.Catch</p>
           
              <p class="site-description motion-element" itemprop="description">孤单而灿烂</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/justxzm" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.cnblogs.com/justcaxzm" target="_blank" title="博客园">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  博客园
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是λ表达式"><span class="nav-number">1.</span> <span class="nav-text">1. 什么是λ表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-λ表达式的类型（它是Object吗？）"><span class="nav-number">2.</span> <span class="nav-text">2. λ表达式的类型（它是Object吗？）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-λ表达式的使用"><span class="nav-number">3.</span> <span class="nav-text">3. λ表达式的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#λ表达式用在何处"><span class="nav-number">3.1.</span> <span class="nav-text">λ表达式用在何处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#λ表达式与集合类批处理操作（或者叫块操作）"><span class="nav-number">3.2.</span> <span class="nav-text">λ表达式与集合类批处理操作（或者叫块操作）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#λ表达式的更多用法"><span class="nav-number">3.3.</span> <span class="nav-text">λ表达式的更多用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-其它相关概念"><span class="nav-number">4.</span> <span class="nav-text">4. 其它相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#捕获（Capture）"><span class="nav-number">4.1.</span> <span class="nav-text">捕获（Capture）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法引用（Method-reference）"><span class="nav-number">4.2.</span> <span class="nav-text">方法引用（Method reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认方法（Default-method）"><span class="nav-number">4.3.</span> <span class="nav-text">默认方法（Default method）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成器函数（Generator-function）"><span class="nav-number">4.4.</span> <span class="nav-text">生成器函数（Generator function）</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Try.Catch</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"justxzm"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
