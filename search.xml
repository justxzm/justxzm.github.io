<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IO流之切割合并文件</title>
      <link href="/2020/08/21/IO%E6%B5%81%E4%B9%8B%E5%88%87%E5%89%B2%E5%90%88%E5%B9%B6%E6%96%87%E4%BB%B6/"/>
      <url>/2020/08/21/IO%E6%B5%81%E4%B9%8B%E5%88%87%E5%89%B2%E5%90%88%E5%B9%B6%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>以每块多大的分量去切割成多少块</strong>。</p><p>比方说 1024 的 文件以 500 切，切成 3 块，就是 500、500、24 的三块。最后一块可能装不满 500，那就得取实际数量了，也就是 24 。</p><p>3 块文件的起始点就是：</p><ul><li>第一块：0，500</li><li>第二块：500，1000</li><li>第三块：1000，1024</li></ul><h3 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h3><ol><li>进行读写，读得时候可以使用 <strong>RandomAccessFile</strong> 的  <strong>seek</strong> 方法设置开始读取的地方，然后结束的地方再使用输入的结束点进行判断，从而进行分割。</li><li>文件合并，因为 初始化文件的时候就确定了切块后的每块的文件名，只需要将其全部读取出来然后写，记得这里的 <strong>new FileOutputStream( file, true )</strong> 构造方法应该这样写，因为是合并文件，所以这里得 是<strong>追加</strong>。</li></ol><a id="more"></a><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitFileDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 文件路径</span></div><div class="line">    <span class="keyword">private</span> String filePath;</div><div class="line"></div><div class="line">    <span class="comment">// 文件大小</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fileLength;</div><div class="line"></div><div class="line">    <span class="comment">// 文件名称</span></div><div class="line">    <span class="keyword">private</span> String fileName;</div><div class="line"></div><div class="line">    <span class="comment">// 以多大来切割文件</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> blockSize = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 文件块数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">    <span class="comment">// 切割后的文件的存放路径</span></div><div class="line">    <span class="keyword">private</span> String splitDirPath;</div><div class="line"></div><div class="line">    <span class="comment">// 切割后的每块的文件名</span></div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; splitFilePathList;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SplitFileDemo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.splitFilePathList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SplitFileDemo</span><span class="params">(String filePath, String destPath)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(filePath, blockSize, destPath);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SplitFileDemo</span><span class="params">(String filePath, <span class="keyword">long</span> blockSize, String splitDirPath)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>();</div><div class="line">        <span class="keyword">this</span>.filePath = filePath;</div><div class="line">        <span class="keyword">this</span>.blockSize = blockSize;</div><div class="line">        <span class="keyword">this</span>.splitDirPath = splitDirPath;</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@Description</span>: 初始化必须参数，比如说文件切割后的名字，分成几块，之类的</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        File src = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 如果 文件地址为空，或者文件不存在则终止程序</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.filePath == <span class="keyword">null</span> || !(src = <span class="keyword">new</span> File(<span class="keyword">this</span>.filePath)).exists()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 该地址为文件夹也终止</span></div><div class="line">        <span class="keyword">if</span> (src.isDirectory()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        File dest = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 如果目标文件不存在则终止程序</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.splitDirPath == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        dest = <span class="keyword">new</span> File(<span class="keyword">this</span>.splitDirPath);</div><div class="line">        <span class="comment">// 如果目标文件不存在则创建</span></div><div class="line">        <span class="keyword">if</span> (!dest.exists()) &#123;</div><div class="line">            dest.mkdirs();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 文件大小</span></div><div class="line">        <span class="keyword">this</span>.fileLength = src.length();</div><div class="line"></div><div class="line">        <span class="comment">// 文件名称</span></div><div class="line">        <span class="keyword">this</span>.fileName = src.getName();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.blockSize &gt; <span class="keyword">this</span>.fileLength) &#123;</div><div class="line">            <span class="keyword">this</span>.blockSize = <span class="keyword">this</span>.fileLength;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 分块</span></div><div class="line">        <span class="keyword">this</span>.size = (<span class="keyword">int</span>) Math.ceil((src.length() * <span class="number">1.0</span> / <span class="keyword">this</span>.blockSize));</div><div class="line"></div><div class="line">        initDestFileName();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@Description</span>: 初始化切割后的文件的名称</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initDestFileName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</div><div class="line">            <span class="keyword">this</span>.splitFilePathList.add(<span class="keyword">this</span>.splitDirPath + File.separator + <span class="keyword">this</span>.fileName + <span class="string">".temp"</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@Description</span>: 切割文件 ，确定起始点</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> beginPos = <span class="number">0</span>;</div><div class="line">        <span class="keyword">long</span> actualBlockSize = <span class="keyword">this</span>.blockSize;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</div><div class="line">            <span class="comment">// 当最后一块的大小比分块的大小小的时候，实际大小为 总长度-起点</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.fileLength - beginPos &lt;= <span class="keyword">this</span>.blockSize) &#123;</div><div class="line">                actualBlockSize = <span class="keyword">this</span>.fileLength - beginPos;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            splitDetil(i, beginPos, actualBlockSize);</div><div class="line">            <span class="comment">// 起点 = 上一次的结尾 + 实际读取的长度</span></div><div class="line">            beginPos += actualBlockSize;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@Description</span>: 切割文件的具体实现方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">splitDetil</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> beginPos, <span class="keyword">long</span> actualBlockSize)</span> </span>&#123;</div><div class="line">        <span class="comment">// 创建源文件</span></div><div class="line">        File src = <span class="keyword">new</span> File(<span class="keyword">this</span>.filePath);</div><div class="line">        File desc = <span class="keyword">new</span> File(<span class="keyword">this</span>.splitFilePathList.get(index));</div><div class="line"></div><div class="line">        RandomAccessFile raf = <span class="keyword">null</span>;</div><div class="line">        BufferedOutputStream bos = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 设置只读读取</span></div><div class="line">            raf = <span class="keyword">new</span> RandomAccessFile(src, <span class="string">"r"</span>);</div><div class="line">            bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(desc));</div><div class="line"></div><div class="line">            <span class="comment">// 读取文件</span></div><div class="line">            raf.seek(beginPos);</div><div class="line"></div><div class="line">            <span class="comment">// 缓冲</span></div><div class="line">            <span class="keyword">byte</span>[] flush = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">            <span class="comment">// 记录每次读取的长度</span></div><div class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (len = raf.read(flush))) &#123;</div><div class="line">                <span class="keyword">if</span> ((actualBlockSize - len) &gt; <span class="number">0</span>) &#123;</div><div class="line">                    bos.write(flush, <span class="number">0</span>, len);</div><div class="line">                    actualBlockSize -= len;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 写出最后一块后关闭循环</span></div><div class="line">                    bos.write(flush, <span class="number">0</span>, (<span class="keyword">int</span>) actualBlockSize);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            bos.flush();</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                bos.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                raf.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@Description</span>: 文件合并</div><div class="line">     * <span class="doctag">@param</span>: mergeFilePath 合并后的文件位置</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(String mergeFilePath)</span> </span>&#123;</div><div class="line">        File dest = <span class="keyword">new</span> File(mergeFilePath);</div><div class="line">        <span class="keyword">if</span> (mergeFilePath == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 目标文件不存在则创建</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">new</span> File(dest.getParent()).exists()) &#123;</div><div class="line">            <span class="keyword">new</span> File(dest.getParent()).mkdirs();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        BufferedOutputStream bos = <span class="keyword">null</span>;</div><div class="line">        BufferedInputStream bis = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 此处是追加，因为是文件合并</span></div><div class="line">            bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest, <span class="keyword">true</span>));</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</div><div class="line"></div><div class="line">                bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="keyword">this</span>.splitFilePathList.get(i))));</div><div class="line"></div><div class="line">                <span class="keyword">byte</span>[] flush = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">                <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (-<span class="number">1</span> != (len = bis.read(flush))) &#123;</div><div class="line">                    bos.write(flush, <span class="number">0</span>, len);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                bos.flush();</div><div class="line">                bis.close();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                bos.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String fileName = <span class="string">"测试.pdf"</span>;</div><div class="line">        String basicPath = <span class="string">"C:\\Users\\Admin\\Downloads\\"</span>;</div><div class="line">        String filePath = basicPath + fileName;<span class="comment">//目标文件名路径</span></div><div class="line">        String splitDirPath = basicPath + <span class="string">"\\split"</span>;<span class="comment">//分割文件夹路径</span></div><div class="line">        String mergeFilePath = basicPath + <span class="string">"\\merge\\"</span> + fileName;<span class="comment">//合并文件路径</span></div><div class="line">        <span class="keyword">int</span> blockSize = <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//1MB大小分割</span></div><div class="line">        SplitFileDemo splitFileDemo = <span class="keyword">new</span> SplitFileDemo(filePath, blockSize, splitDirPath);</div><div class="line">        splitFileDemo.split();<span class="comment">//分割文件</span></div><div class="line">        splitFileDemo.merge(mergeFilePath);<span class="comment">//合并文件</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收</title>
      <link href="/2020/06/24/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2020/06/24/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>内存回收常用算法：</strong></p><ol><li>引用计数</li><li>可达性分析（GC Root）</li></ol><p><strong>如何判断一个对象的死亡？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当一个对象不再被任何存活的对象继续引用的时候，这个对象就死亡了。</div></pre></td></tr></table></figure><a id="more"></a><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>给每一个对象添加一个计数器</p><ul><li>当有对象引用它的时候，计数器+1。</li><li>当有对象取消对它的引用时，计数就会-1。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当计数器的值为 0 时，即说明没有对象引用它，也就是这个对象死亡了。</div></pre></td></tr></table></figure><p>这种算法简单，但是有个重大缺陷，那就是无法解决循环引用问题。</p><p>什么是循环引用问题呢？</p><p>比如对象A 引用 对象B，对象B 引用 对象A，那么 对象A 和 对象B 的计数器都为1。但是如果后续的运行环境再也用不到对象A 和 对象B，那么就造成了内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountGC</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="comment">// 每个对象中包含2M的成员，方便观察</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"Yes, i am alive"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">ReferenceCountGC objA = <span class="keyword">new</span> ReferenceCountGC();</div><div class="line">ReferenceCountGC objB = <span class="keyword">new</span> ReferenceCountGC();</div><div class="line">objA.instance = objB.instance;</div><div class="line">objB.instance = objA.instance;</div><div class="line"></div><div class="line"><span class="comment">// 取消对对象的引用</span></div><div class="line">objA = <span class="keyword">null</span>;</div><div class="line">objB = <span class="keyword">null</span>;</div><div class="line"><span class="comment">// 是否进行垃圾回收</span></div><div class="line">System.gc();</div><div class="line"><span class="comment">// 没有执行，说明Java没有使用这种算法，而是使用了我们后面说的可达性算法</span></div><div class="line"><span class="keyword">if</span> (objA != <span class="keyword">null</span>) &#123;</div><div class="line">objA.isAlive();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>别名：根搜索算法，追踪性垃圾收集，GC Root。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先，我们选取一些对象，这些对象是存活的，也被称为 GC Roots，然后根据这些对象的引用关系，凡是直接或者间接跟 GC Roots 相关联的对象，都是存活的。就像图中的连通性判断一样。</p><p><img src="/images/Java/2020062401.png" alt=""></p><h3 id="如何选取GC-Roots"><a href="#如何选取GC-Roots" class="headerlink" title="如何选取GC Roots"></a>如何选取GC Roots</h3><ul><li>在堆结构周围的一些结构，其中引用的对象可以作为GC Roots，具体可以概括为：</li><li><p>虚拟机栈上（确切的说，是栈帧上的本地变量表）所引用的对象</p></li><li><p>本地方法栈引用的对象</p></li><li><p>方法区中的静态属性，常量引用</p></li><li><p>Java 虚拟机的内部引用，常用数据类型的 Class 对象，常驻的异常对象，系统类加载器</p></li><li><p>所有被同步锁持有的对象</p></li><li><p>除此之外，还有一些临时的 GC Roots 可以加入进来。比如老年代中的对象一般都存活时间比较久，也就是大概率是活着的对象，也可临时作为 GC Roots。</p></li></ul><h3 id="标记死亡后如何自救"><a href="#标记死亡后如何自救" class="headerlink" title="标记死亡后如何自救"></a>标记死亡后如何自救</h3><p>被判定为不可达的对象，并不立刻死亡。它仍然有次机会进行自救，需要重写 finalize()。</p><p>也就是可达性算法的逻辑大致是这样的：</p><ol><li>第一次进行标记，凡是不可达 GC Roots 的对象，都暂时判定为死亡，只是暂时。</li><li>检查暂时被判定为死亡对象，检查是否有重写 finalize()方法：<ul><li>如果有，则触发，对象可以在里面完成自救。</li><li>如果没有自救成功 或者 没有重写 finalize()方法，则宣告这个对象的死亡。</li></ul></li><li>除此之外，这个对象中的 finalize()方法，只能被调用一次，一生只有一次自救机会。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"Yes, i am alive"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"><span class="keyword">super</span>.finalize();</div><div class="line">System.out.println(<span class="string">"Finalize method executed"</span>);</div><div class="line">FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</div><div class="line">SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line">System.gc();</div><div class="line">Thread.sleep(<span class="number">500</span>);</div><div class="line"><span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">SAVE_HOOK.isAlive();</div><div class="line">SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line">System.gc();</div><div class="line"><span class="keyword">if</span> (SAVE_HOOK == <span class="keyword">null</span>) &#123;</div><div class="line">System.out.println(<span class="string">"Dead"</span>);</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">System.out.println(<span class="string">"Dead"</span>);</div><div class="line">System.gc();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Finalize method executed</div><div class="line">Yes, i am alive</div><div class="line">Dead</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java NIO实例</title>
      <link href="/2020/02/01/Java-NIO%E5%AE%9E%E4%BE%8B/"/>
      <url>/2020/02/01/Java-NIO%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>示例来源（<a href="http://www.imooc.com/learn/1118" target="_blank" rel="external">imooc</a>）（<a href="//img.mukewang.com/down//imgsvc/2019/04/25/5cc12e36110335d2224bd972.zip">代码下载</a>）</p><a id="more"></a><h3 id="NioServer"><a href="#NioServer" class="headerlink" title="NioServer"></a>NioServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.*;</div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * NIO服务器端</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 启动</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 1. 创建Selector</div><div class="line">         */</div><div class="line">        Selector selector = Selector.open();</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 2. 通过ServerSocketChannel创建channel通道</div><div class="line">         */</div><div class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 3. 为channel通道绑定监听端口</div><div class="line">         */</div><div class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>));</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 4. **设置channel为非阻塞模式**</div><div class="line">         */</div><div class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 5. 将channel注册到selector上，监听连接事件</div><div class="line">         */</div><div class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">        System.out.println(<span class="string">"服务器启动成功！"</span>);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 6. 循环等待新接入的连接</div><div class="line">         */</div><div class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// while(true) c for;;</span></div><div class="line">            <span class="comment">/**</span></div><div class="line">             * TODO 获取可用channel数量</div><div class="line">             */</div><div class="line">            <span class="keyword">int</span> readyChannels = selector.select();</div><div class="line"></div><div class="line">            <span class="comment">/**</span></div><div class="line">             * TODO 为什么要这样！！？</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 获取可用channel的集合</div><div class="line">             */</div><div class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</div><div class="line"></div><div class="line">            Iterator iterator = selectionKeys.iterator();</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                <span class="comment">/**</span></div><div class="line">                 * selectionKey实例</div><div class="line">                 */</div><div class="line">                SelectionKey selectionKey = (SelectionKey) iterator.next();</div><div class="line"></div><div class="line">                <span class="comment">/**</span></div><div class="line">                 * **移除Set中的当前selectionKey**</div><div class="line">                 */</div><div class="line">                iterator.remove();</div><div class="line"></div><div class="line">                <span class="comment">/**</span></div><div class="line">                 * 7. 根据就绪状态，调用对应方法处理业务逻辑</div><div class="line">                 */</div><div class="line">                <span class="comment">/**</span></div><div class="line">                 * 如果是 接入事件</div><div class="line">                 */</div><div class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</div><div class="line">                    acceptHandler(serverSocketChannel, selector);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">/**</span></div><div class="line">                 * 如果是 可读事件</div><div class="line">                 */</div><div class="line">                <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</div><div class="line">                    readHandler(selectionKey, selector);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 接入事件处理器</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(ServerSocketChannel serverSocketChannel,</span></span></div><div class="line">                               Selector selector)</div><div class="line">            <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 如果要是接入事件，创建socketChannel</div><div class="line">         */</div><div class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 将socketChannel设置为非阻塞工作模式</div><div class="line">         */</div><div class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 将channel注册到selector上，监听 可读事件</div><div class="line">         */</div><div class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 回复客户端提示信息</div><div class="line">         */</div><div class="line">        socketChannel.write(Charset.forName(<span class="string">"UTF-8"</span>)</div><div class="line">                .encode(<span class="string">"你与聊天室里其他人都不是朋友关系，请注意隐私安全"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 可读事件处理器</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey selectionKey, Selector selector)</span></span></div><div class="line">            <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 要从 selectionKey 中获取到已经就绪的channel</div><div class="line">         */</div><div class="line">        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 创建buffer</div><div class="line">         */</div><div class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 循环读取客户端请求信息</div><div class="line">         */</div><div class="line">        String request = <span class="string">""</span>;</div><div class="line">        <span class="keyword">while</span> (socketChannel.read(byteBuffer) &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 切换buffer为读模式</div><div class="line">             */</div><div class="line">            byteBuffer.flip();</div><div class="line"></div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 读取buffer中的内容</div><div class="line">             */</div><div class="line">            request += Charset.forName(<span class="string">"UTF-8"</span>).decode(byteBuffer);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 将channel再次注册到selector上，监听他的可读事件</div><div class="line">         */</div><div class="line">        <span class="comment">//socketChannel.register(selector, SelectionKey.OP_READ);</span></div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 将客户端发送的请求信息 广播给其他客户端</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (request.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 广播给其他客户端</span></div><div class="line">            broadCast(selector, socketChannel, request);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 广播给其他客户端</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">broadCast</span><span class="params">(Selector selector,</span></span></div><div class="line">                           SocketChannel sourceChannel, String request) &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 获取到所有已接入的客户端channel</div><div class="line">         */</div><div class="line">        Set&lt;SelectionKey&gt; selectionKeySet = selector.keys();</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 循环向所有channel广播信息</div><div class="line">         */</div><div class="line">        <span class="keyword">for</span>(SelectionKey selectionKey:selectionKeySet)&#123;</div><div class="line">            Channel targetChannel = selectionKey.channel();</div><div class="line">            <span class="comment">// 剔除发消息的客户端</span></div><div class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel</div><div class="line">                    &amp;&amp; targetChannel != sourceChannel) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// 将信息发送到targetChannel客户端</span></div><div class="line">                    ((SocketChannel) targetChannel).write(</div><div class="line">                            Charset.forName(<span class="string">"UTF-8"</span>).encode(request));</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主方法</div><div class="line">     * <span class="doctag">@param</span> args</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">new</span> NioServer().start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="NioClient"><a href="#NioClient" class="headerlink" title="NioClient"></a>NioClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</div><div class="line"><span class="keyword">import</span> java.nio.channels.Selector;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * NIO客户端</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 启动</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String nickname)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 连接服务器端</div><div class="line">         */</div><div class="line">        SocketChannel socketChannel = SocketChannel.open(</div><div class="line">                <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8000</span>));</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 接收服务器端响应</div><div class="line">         */</div><div class="line">        <span class="comment">// 新开线程，专门负责来接收服务器端的响应数据</span></div><div class="line">        <span class="comment">// selector ， socketChannel ， 注册</span></div><div class="line">        Selector selector = Selector.open();</div><div class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> NioClientHandler(selector)).start();</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 向服务器端发送数据</div><div class="line">         */</div><div class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</div><div class="line">            String request = scanner.nextLine();</div><div class="line">            <span class="keyword">if</span> (request != <span class="keyword">null</span> &amp;&amp; request.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                socketChannel.write(</div><div class="line">                        Charset.forName(<span class="string">"UTF-8"</span>)</div><div class="line">                                .encode(nickname + <span class="string">" : "</span> + request));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">//new NioClient().start();</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="NioClientHandler"><a href="#NioClientHandler" class="headerlink" title="NioClientHandler"></a>NioClientHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</div><div class="line"><span class="keyword">import</span> java.nio.channels.Selector;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 客户端线程类，专门接收服务器端响应信息</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClientHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Selector selector;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioClientHandler</span><span class="params">(Selector selector)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.selector = selector;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> readyChannels = selector.select();</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">                <span class="comment">/**</span></div><div class="line">                 * 获取可用channel的集合</div><div class="line">                 */</div><div class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</div><div class="line"></div><div class="line">                Iterator iterator = selectionKeys.iterator();</div><div class="line"></div><div class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                    <span class="comment">/**</span></div><div class="line">                     * selectionKey实例</div><div class="line">                     */</div><div class="line">                    SelectionKey selectionKey = (SelectionKey) iterator.next();</div><div class="line"></div><div class="line">                    <span class="comment">/**</span></div><div class="line">                     * **移除Set中的当前selectionKey**</div><div class="line">                     */</div><div class="line">                    iterator.remove();</div><div class="line"></div><div class="line">                    <span class="comment">/**</span></div><div class="line">                     * 7. 根据就绪状态，调用对应方法处理业务逻辑</div><div class="line">                     */</div><div class="line"></div><div class="line">                    <span class="comment">/**</span></div><div class="line">                     * 如果是 可读事件</div><div class="line">                     */</div><div class="line">                    <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</div><div class="line">                        readHandler(selectionKey, selector);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 可读事件处理器</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey selectionKey, Selector selector)</span></span></div><div class="line">            <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 要从 selectionKey 中获取到已经就绪的channel</div><div class="line">         */</div><div class="line">        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 创建buffer</div><div class="line">         */</div><div class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 循环读取服务器端响应信息</div><div class="line">         */</div><div class="line">        String response = <span class="string">""</span>;</div><div class="line">        <span class="keyword">while</span> (socketChannel.read(byteBuffer) &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 切换buffer为读模式</div><div class="line">             */</div><div class="line">            byteBuffer.flip();</div><div class="line"></div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 读取buffer中的内容</div><div class="line">             */</div><div class="line">            response += Charset.forName(<span class="string">"UTF-8"</span>).decode(byteBuffer);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 将channel再次注册到selector上，监听他的可读事件</div><div class="line">         */</div><div class="line">        <span class="comment">//socketChannel.register(selector, SelectionKey.OP_READ);</span></div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 将服务器端响应信息打印到本地</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (response.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">            System.out.println(response);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="AClient"><a href="#AClient" class="headerlink" title="AClient"></a>AClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">            <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">new</span> NioClient().start(<span class="string">"AClient"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="BClient"><a href="#BClient" class="headerlink" title="BClient"></a>BClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">            <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">new</span> NioClient().start(<span class="string">"BClient"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="CClient"><a href="#CClient" class="headerlink" title="CClient"></a>CClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">            <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">new</span> NioClient().start(<span class="string">"CClient"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2020/01/23/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/01/23/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ul><li>Observable<ul><li>即被观察者，也可以被叫做主题<strong>（Subject）</strong>。通常有注册方法<strong>（register）</strong>，取消注册方法<strong>（remove）</strong>和通知方法<strong>（notify）</strong>。</li></ul></li><li>Observer<ul><li>即观察者，可以接收到主题的更新。当对某个主题感兴趣的时候需要注册自己，在不需要接收更新时进行注销操作。</li></ul></li></ul><h2 id="例子与应用"><a href="#例子与应用" class="headerlink" title="例子与应用"></a>例子与应用</h2><ol><li>用户从报社订阅报纸，报社和用户之间是一对多依赖，用户可以在报社订阅（register）报纸，报社可以把最新的报纸发给用户<strong>（notify）</strong>，用户自动收到更新。在用户不需要的时候还可以取消注册<strong>（remove）</strong>。</li><li>Android中的EventBus，Rxjava的实现都是基于观察者模式的思想。再比如回调函数：Android中对Button的点击监听等等。</li><li>观察者模式可以用来解耦</li></ol><a id="more"></a><h2 id="观察者模式代码实现"><a href="#观察者模式代码实现" class="headerlink" title="观察者模式代码实现"></a>观察者模式代码实现</h2><p>现在我们用代码来实现上面订阅报纸的例子：</p><ul><li>NewProvider作为对于报社的抽象，每隔两秒钟向用户发送报纸。</li><li>User作为用户的抽象，可以收到报纸。</li><li>NewsModel作为对报纸本身的抽象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 被观察者接口定义</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyObserverable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(MyObserver myObserver)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(MyObserver myObserver)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(NewsModel model)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 观察者接口定义</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyObserver</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(NewsModel model)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 对于报社的抽象，实现了被观察者接口，每隔2s发送一次报纸</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsProvider</span> <span class="keyword">implements</span> <span class="title">MyObserverable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DELAY = <span class="number">2</span> * <span class="number">1000</span>;</div><div class="line">    <span class="keyword">private</span> List&lt;MyObserver&gt; mObservers;<span class="comment">//我们用一个List来维护所有的观察者对象</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewsProvider</span><span class="params">()</span> </span>&#123;</div><div class="line">        mObservers = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        generateNews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 模拟产生新闻，每个2s发送一次</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateNews</span><span class="params">()</span> </span>&#123;</div><div class="line">        Timer timer = <span class="keyword">new</span> Timer();</div><div class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">            <span class="keyword">int</span> titleCount = <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> contentCount = <span class="number">1</span>;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                send(<span class="keyword">new</span> NewsModel(<span class="string">"title:"</span> + titleCount++, <span class="string">"content:"</span> + contentCount++));</div><div class="line">            &#125;</div><div class="line">        &#125;, DELAY, <span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(MyObserver myObserver)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (myObserver == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!mObservers.contains(myObserver))</div><div class="line">                mObservers.add(myObserver);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(MyObserver myObserver)</span> </span>&#123;</div><div class="line">        mObservers.remove(myObserver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(NewsModel model)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (MyObserver observer : mObservers) &#123;</div><div class="line">            observer.receive(model);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 对于用户的抽象</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">MyObserver</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String mName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        mName = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(NewsModel model)</span> </span>&#123;</div><div class="line">        System.out.println(mName + <span class="string">" receive news:"</span> + model.getTitle() + <span class="string">"  "</span> + model.getContent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsModel</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> String title;</div><div class="line"><span class="keyword">private</span> String content;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NewsModel</span><span class="params">(String title, String content)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.title = title;</div><div class="line"><span class="keyword">this</span>.content = content;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> title;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.title = title;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> content;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.content = content;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 测试类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        NewsProvider provider = <span class="keyword">new</span> NewsProvider();</div><div class="line">        User user;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            user = <span class="keyword">new</span> User(<span class="string">"user:"</span>+i);</div><div class="line">            provider.register(user);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">user:0 receive news:title:1  content:1</div><div class="line">user:1 receive news:title:1  content:1</div><div class="line">user:2 receive news:title:1  content:1</div><div class="line">user:3 receive news:title:1  content:1</div><div class="line">user:4 receive news:title:1  content:1</div><div class="line">user:5 receive news:title:1  content:1</div><div class="line">user:6 receive news:title:1  content:1</div><div class="line">user:7 receive news:title:1  content:1</div><div class="line">user:8 receive news:title:1  content:1</div><div class="line">user:9 receive news:title:1  content:1</div><div class="line">user:0 receive news:title:2  content:2</div><div class="line">user:1 receive news:title:2  content:2</div><div class="line">user:2 receive news:title:2  content:2</div><div class="line">user:3 receive news:title:2  content:2</div><div class="line">user:4 receive news:title:2  content:2</div><div class="line">user:5 receive news:title:2  content:2</div><div class="line">user:6 receive news:title:2  content:2</div><div class="line">user:7 receive news:title:2  content:2</div><div class="line">user:8 receive news:title:2  content:2</div><div class="line">user:9 receive news:title:2  content:2</div><div class="line">...</div></pre></td></tr></table></figure><h2 id="JDK观察者模式API"><a href="#JDK观察者模式API" class="headerlink" title="JDK观察者模式API"></a>JDK观察者模式API</h2><p>在JDK的util包内Java为我们提供了一套观察者模式的实现，在使用的时候我们只需要继承Observable和Observer类即可。此外在JDK的实现中还增加了一个布尔类型的changed域，通过设置这个变量来确定是否通知观察者。</p><h3 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsProvider</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DELAY = <span class="number">2</span> * <span class="number">1000</span>;</div><div class="line">    <span class="keyword">private</span> List&lt;MyObserver&gt; mObservers;<span class="comment">//我们用一个List来维护所有的观察者对象</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewsProvider</span><span class="params">()</span> </span>&#123;</div><div class="line">        Timer timer = <span class="keyword">new</span> Timer();</div><div class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">           <span class="keyword">private</span> <span class="keyword">int</span> titleCount = <span class="number">1</span>;</div><div class="line">           <span class="keyword">private</span> <span class="keyword">int</span> contentCount = <span class="number">1</span>;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                setChanged();<span class="comment">//调用setChagned方法，将changed域设置为true，这样才能通知到观察者们</span></div><div class="line">                notifyObservers(<span class="keyword">new</span> NewsModel(<span class="string">"title:"</span> + titleCount++, <span class="string">"content:"</span> + contentCount++));</div><div class="line">            &#125;</div><div class="line">        &#125;, DELAY, <span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String mName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        mName = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object data)</span> </span>&#123;</div><div class="line">        NewsModel model = (NewsModel) data;</div><div class="line">        System.out.println(mName + <span class="string">" receive news:"</span> + model.getTitle() + <span class="string">"  "</span> + model.getContent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        NewsProvider provider = <span class="keyword">new</span> NewsProvider();</div><div class="line">        User user = <span class="keyword">new</span> User(<span class="string">"张三"</span>);</div><div class="line">        provider.addObserver(user);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a>Demo2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Publish</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String data = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(String data)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.data.equals(data))&#123;</div><div class="line">            <span class="keyword">this</span>.data = data;</div><div class="line">            setChanged();<span class="comment">//改变通知者的状态</span></div><div class="line">        &#125;</div><div class="line">        notifyObservers();<span class="comment">//调用父类Observable方法，通知所有观察者</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscribe</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Subscribe</span><span class="params">(Observable o)</span> </span>&#123;</div><div class="line">o.addObserver(<span class="keyword">this</span>);<span class="comment">//将该观察者放入待通知观察者里</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"收到通知:"</span> + ((Publish) o).getData());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Publish publish = <span class="keyword">new</span> Publish();</div><div class="line">        Subscribe subscribe = <span class="keyword">new</span> Subscribe(publish);</div><div class="line">        publish.setData(<span class="string">"开始"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="回调函数与观察者模式"><a href="#回调函数与观察者模式" class="headerlink" title="回调函数与观察者模式"></a>回调函数与观察者模式</h2><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。</p><p>在这个例子里：</p><ol><li>你的电话号码就叫回调函数；</li><li>你把电话留给店员就叫登记回调函数；</li><li>店里后来有货了叫做触发了回调关联的事件；</li><li>店员给你打电话叫做调用回调函数；</li><li>你到店里去取货叫做响应回调事件。</li></ol><p>在Android中我们有一个常用的回调：对于View点击事件的监听。</p><p>通常在我们使用的时候是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">xxxView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line"><span class="comment">// do something</span></div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这样我们就注册好了一个回调函数。</p><p>我们可以在View的源码里发现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Interface definition for a callback to be invoked when a view is clicked.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span> </span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Called when a view has been clicked.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> v The view that was clicked.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当你setClickListener的时候在View的源码中可以看到对本地OnClickListener的初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Register a callback to be invoked when this view is clicked. If this view is not</div><div class="line"> * clickable, it becomes clickable.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> l The callback that will run</div><div class="line"> *</div><div class="line"> * <span class="doctag">@see</span> #setClickable(boolean)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(@Nullable OnClickListener l)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (!isClickable()) &#123;</div><div class="line">setClickable(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line">getListenerInfo().mOnClickListener = l;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当你的点击到一个View后Android系统经过一系列的调用最后到了View的performClick方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Call this view's OnClickListener, if it is defined.  Performs all normal</div><div class="line"> * actions associated with clicking: reporting accessibility event, playing</div><div class="line"> * a sound, etc.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> True there was an assigned OnClickListener that was called, false</div><div class="line"> *         otherwise is returned.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> result;</div><div class="line"><span class="keyword">final</span> ListenerInfo li = mListenerInfo;</div><div class="line"><span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">playSoundEffect(SoundEffectConstants.CLICK);</div><div class="line">li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">result = <span class="keyword">true</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">result = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就在这里，触发了你的onClick方法，然后执行方法体。</p><p>这里我们的被观察者就是View，他的注册方法（register）就是setOnClickListener()，通知方法就是performClick；而OnClickListener就是观察者。只不过这里的只能注册一个观察对象而已。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8种方法实现线程顺序执行</title>
      <link href="/2019/11/17/8%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C/"/>
      <url>/2019/11/17/8%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>本文使用8种方法实现在多线程中让线程按顺序运行：</p><ol><li>使用线程的join方法</li><li>使用主线程的join方法</li><li>使用线程的wait/notify方法</li><li>使用单线程化线程池</li><li>使用线程的Condition(条件变量)</li><li>使用线程的CountDownLatch(倒计数)</li><li>使用线程的CyclicBarrier(回环栅栏)</li><li>使用线程的Semaphore(信号量)</li></ol><a id="more"></a><h2 id="使用线程的join方法"><a href="#使用线程的join方法" class="headerlink" title="使用线程的join方法"></a>使用线程的join方法</h2><p> <strong>join():</strong>是Theard的方法，作用是调用线程需等待该join()线程执行完成后，才能继续用下运行。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"开始执行线程1。"</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">thread1.join();</div><div class="line">System.out.println(<span class="string">"线程1执行完成，开始执行线程2。"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">thread2.join();</div><div class="line">System.out.println(<span class="string">"线程2执行完成，开始执行线程3。"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">thread3.start();</div><div class="line">thread1.start();</div><div class="line">thread2.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">开始执行线程1。</div><div class="line">线程1执行完成，开始执行线程2。</div><div class="line">线程2执行完成，开始执行线程3。</div></pre></td></tr></table></figure><h2 id="使用主线程的join方法"><a href="#使用主线程的join方法" class="headerlink" title="使用主线程的join方法"></a>使用主线程的join方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMainJoinDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"开始执行线程1..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"开始执行线程2..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"开始执行线程3..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">thread1.start();</div><div class="line"><span class="comment">//父进程调用子进程的join()方法后，需要等待子进程运行完再继续运行。</span></div><div class="line">thread1.join();</div><div class="line">thread2.start();</div><div class="line">thread2.join();</div><div class="line">thread3.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">开始执行线程1...</div><div class="line">开始执行线程2...</div><div class="line">开始执行线程3...</div></pre></td></tr></table></figure><h2 id="使用线程的wait-notify方法"><a href="#使用线程的wait-notify方法" class="headerlink" title="使用线程的wait/notify方法"></a>使用线程的wait/notify方法</h2><p><strong>wait()：</strong>是Object的方法，作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。“直到其他线程调用此对象的notify()方法或notifyAll()方法”，当前线程被唤醒(进入“就绪状态”)</p><p><strong>notify()和notifyAll()：</strong>是Object的方法，作用则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。</p><p><strong>wait(long timeout)：</strong>让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</p><p><strong>应用场景：</strong>Java实现生产者消费者的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaitDemo</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object myLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="comment">// 线程执行完成标识</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Boolean t1Run = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Boolean t2Run = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (myLock) &#123;</div><div class="line">System.out.println(<span class="string">"&gt;&gt;线程1获得锁和执行权"</span>);</div><div class="line">t1Run = <span class="keyword">true</span>;</div><div class="line">myLock.notify();</div><div class="line">System.out.println(<span class="string">"【线程1执行完成，释放锁】"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (myLock) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"&gt;&gt;线程2获得锁和执行权"</span>);</div><div class="line"><span class="keyword">if</span> (!t1Run) &#123;</div><div class="line">System.out.println(<span class="string">"!!线程1未运行，线程2释放锁让出执行权..."</span>);</div><div class="line">myLock.wait();</div><div class="line">System.out.println(<span class="string">"线程2重新获得锁，继续运行..."</span>);</div><div class="line">&#125;</div><div class="line">t2Run = <span class="keyword">true</span>;</div><div class="line">myLock.notify();</div><div class="line">System.out.println(<span class="string">"【线程2执行完成，释放锁】"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (myLock) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"&gt;&gt;线程3获得锁和执行权"</span>);</div><div class="line"><span class="keyword">if</span> (!t1Run) &#123;</div><div class="line">System.out.println(<span class="string">"!!线程1未运行，线程3释放锁让出执行权..."</span>);</div><div class="line">myLock.wait();</div><div class="line">System.out.println(<span class="string">"线程3重新获得锁，继续运行..."</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (!t2Run) &#123;</div><div class="line">System.out.println(<span class="string">"!!线程2未运行，线程3释放锁让出执行权..."</span>);</div><div class="line">myLock.notify();</div><div class="line">myLock.wait();</div><div class="line">System.out.println(<span class="string">"线程3重新获得锁，继续运行..."</span>);</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"【线程3执行完成，释放锁】"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">thread3.start();</div><div class="line">thread2.start();</div><div class="line">thread1.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;线程3获得锁和执行权</div><div class="line">!!线程1未运行，线程3释放锁让出执行权...</div><div class="line">&gt;&gt;线程2获得锁和执行权</div><div class="line">!!线程1未运行，线程2释放锁让出执行权...</div><div class="line">&gt;&gt;线程1获得锁和执行权</div><div class="line">【线程1执行完成，释放锁】</div><div class="line">线程3重新获得锁，继续运行...</div><div class="line">!!线程2未运行，线程3释放锁让出执行权...</div><div class="line">线程2重新获得锁，继续运行...</div><div class="line">【线程2执行完成，释放锁】</div><div class="line">线程3重新获得锁，继续运行...</div><div class="line">【线程3执行完成，释放锁】</div></pre></td></tr></table></figure><h2 id="使单线程化线程池"><a href="#使单线程化线程池" class="headerlink" title="使单线程化线程池"></a>使单线程化线程池</h2><p>JAVA通过Executors提供了四种线程池</p><ul><li>单线程化线程池(newSingleThreadExecutor);</li><li>可控最大并发数线程池(newFixedThreadPool);</li><li>可回收缓存线程池(newCachedThreadPool);</li><li>支持定时与周期性任务的线程池(newScheduledThreadPool)。</li></ul><p><strong>单线程化线程池(newSingleThreadExecutor)优点：串行执行所有任务。</strong></p><ul><li><p>submit()：提交任务。</p></li><li><p>shutdown()：方法用来关闭线程池，拒绝新任务。</p></li></ul><p><strong>应用场景：</strong>串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。<strong>此线程池保证所有任务的执行顺序按照任务的提交顺序执行</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过SingleThreadExecutor让线程按顺序执行</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">static</span> ExecutorService executorService = Executors</div><div class="line">.newSingleThreadExecutor();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"开始执行线程1..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"开始执行线程2..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"开始执行线程3..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">executorService.submit(thread1);</div><div class="line">executorService.submit(thread2);</div><div class="line">executorService.submit(thread3);</div><div class="line">executorService.shutdown();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">开始执行线程1...</div><div class="line">开始执行线程2...</div><div class="line">开始执行线程3...</div></pre></td></tr></table></figure><h2 id="使用线程的Condition-条件变量"><a href="#使用线程的Condition-条件变量" class="headerlink" title="使用线程的Condition(条件变量)"></a>使用线程的Condition(条件变量)</h2><p>Condition（条件变量）：<strong>通常与一个锁关联</strong>。需要在多个Contidion中共享一个锁时，可以传递一个Lock/RLock实例给构造方法，否则它将自己生成一个RLock实例。</p><ul><li>Condition中await()方法类似于Object类中的wait()方法。</li><li>Condition中await(long time,TimeUnit unit)方法类似于Object类中的wait(long time)方法。</li><li>Condition中signal()方法类似于Object类中的notify()方法。</li><li>Condition中signalAll()方法类似于Object类中的notifyAll()方法。</li></ul><p>应用场景：Condition是一个多线程间协调通信的工具类，使得某个，或者某些线程一起等待某个条件（Condition），只有当该条件具备( signal 或者 signalAll方法被调用)时 ，这些等待线程才会被唤醒，从而重新争夺锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用Condition(条件变量)实现线程按顺序运行</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadConditionDemo</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Condition condition1 = lock.newCondition();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Condition condition2 = lock.newCondition();</div><div class="line"></div><div class="line"><span class="comment">//线程执行完成标识</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Boolean t1Run = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Boolean t2Run = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(<span class="string">"&gt;&gt;开始执行线程1..."</span>);</div><div class="line">t1Run = <span class="keyword">true</span>;</div><div class="line">condition1.signal();</div><div class="line">System.out.println(<span class="string">"【线程1执行完成】"</span>);</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"&gt;&gt;开始执行线程2..."</span>);</div><div class="line"><span class="keyword">if</span> (!t1Run) &#123;</div><div class="line">System.out.println(<span class="string">"!!线程1未执行，线程2让出执行权..."</span>);</div><div class="line">condition1.await();</div><div class="line">System.out.println(<span class="string">"线程2重新获得锁，继续执行..."</span>);</div><div class="line">&#125;</div><div class="line">t2Run = <span class="keyword">true</span>;</div><div class="line">condition2.signal();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"【线程2执行完成】"</span>);</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"&gt;&gt;开始执行线程3..."</span>);</div><div class="line"><span class="keyword">if</span> (!t2Run) &#123;</div><div class="line">System.out.println(<span class="string">"!!线程2未执行，线程3让出执行权..."</span>);</div><div class="line">condition2.await();</div><div class="line">System.out.println(<span class="string">"线程3重新获得锁，继续执行..."</span>);</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"【线程3执行完成】"</span>);</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">thread3.start();</div><div class="line">thread2.start();</div><div class="line">thread1.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;开始执行线程3...</div><div class="line">!!线程2未执行，线程3让出执行权...</div><div class="line">&gt;&gt;开始执行线程2...</div><div class="line">!!线程1未执行，线程2让出执行权...</div><div class="line">&gt;&gt;开始执行线程1...</div><div class="line">【线程1执行完成】</div><div class="line">线程2重新获得锁，继续执行...</div><div class="line">【线程2执行完成】</div><div class="line">线程3重新获得锁，继续执行...</div><div class="line">【线程3执行完成】</div></pre></td></tr></table></figure><h2 id="使用线程的CountDownLatch-倒计数"><a href="#使用线程的CountDownLatch-倒计数" class="headerlink" title="使用线程的CountDownLatch(倒计数)"></a>使用线程的CountDownLatch(倒计数)</h2><p><strong>CountDownLatch</strong>：位于java.util.concurrent包下，利用它可以实现类似计数器的功能。</p><p>应用场景：比如有一个任务C，它要等待其他任务A,B执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过CountDownLatch（倒计数）使线程按顺序执行</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCountDownLatchDemo</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于判断线程一是否执行，倒计时设置为1，执行后减1</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch c1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于判断线程二是否执行，倒计时设置为1，执行后减1</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch c2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"&gt;&gt;开始执行线程1..."</span>);</div><div class="line"><span class="comment">//TODO</span></div><div class="line">System.out.println(<span class="string">"【线程1执行完成】"</span>);</div><div class="line"><span class="comment">// 对c1倒计时-1</span></div><div class="line">c1.countDown();</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"&gt;&gt;开始执行线程2..."</span>);</div><div class="line"><span class="comment">// 等待c1倒计时，计时为0则往下运行</span></div><div class="line">c1.await();</div><div class="line">System.out.println(<span class="string">"线程1执行完成，继续执行线程2..."</span>);</div><div class="line"><span class="comment">//TODO</span></div><div class="line">System.out.println(<span class="string">"【线程2执行完成】"</span>);</div><div class="line"><span class="comment">// 对c2倒计时-1</span></div><div class="line">c2.countDown();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"&gt;&gt;开始执行线程3..."</span>);</div><div class="line"><span class="comment">// 等待c2倒计时，计时为0则往下运行</span></div><div class="line">c2.await();</div><div class="line">System.out.println(<span class="string">"线程2执行完成，继续执行线程3..."</span>);</div><div class="line"><span class="comment">//TODO</span></div><div class="line">System.out.println(<span class="string">"【线程3执行完成】"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">thread3.start();</div><div class="line">thread2.start();</div><div class="line">thread1.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;开始执行线程3...</div><div class="line">&gt;&gt;开始执行线程2...</div><div class="line">&gt;&gt;开始执行线程1...</div><div class="line">【线程1执行完成】</div><div class="line">线程1执行完成，继续执行线程2...</div><div class="line">【线程2执行完成】</div><div class="line">线程2执行完成，继续执行线程3...</div><div class="line">【线程3执行完成】</div></pre></td></tr></table></figure><h2 id="使用CyclicBarrier-回环栅栏"><a href="#使用CyclicBarrier-回环栅栏" class="headerlink" title="使用CyclicBarrier(回环栅栏)"></a>使用CyclicBarrier(回环栅栏)</h2><p>CyclicBarrier(回环栅栏)：</p><ul><li>通过它可以实现让一组线程等待至某个状态之后再全部同时执行。</li><li>叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。</li><li>我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。</li></ul><p>应用场景：公司组织春游，等待所有的员工到达集合地点才能出发，每个人到达后进入barrier状态。都到达后，唤起大家一起出发去旅行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用CyclicBarrier(回环栅栏)实现线程按顺序运行</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">static</span> CyclicBarrier barrier1 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</div><div class="line"><span class="keyword">static</span> CyclicBarrier barrier2 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"&gt;&gt;开始执行线程1..."</span>);</div><div class="line"><span class="comment">//TODO</span></div><div class="line">System.out.println(<span class="string">"【线程1执行完成】"</span>);</div><div class="line"><span class="comment">// 放开栅栏1</span></div><div class="line">barrier1.await();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"&gt;&gt;开始执行线程2..."</span>);</div><div class="line"><span class="comment">// 放开栅栏1</span></div><div class="line">barrier1.await();</div><div class="line">System.out.println(<span class="string">"线程1执行完成，执行线程2继续执行..."</span>);</div><div class="line"><span class="comment">//TODO</span></div><div class="line">System.out.println(<span class="string">"【线程2执行完成】"</span>);</div><div class="line"><span class="comment">// 放开栅栏2</span></div><div class="line">barrier2.await();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(<span class="string">"&gt;&gt;开始执行线程3..."</span>);</div><div class="line"><span class="comment">// 放开栅栏2</span></div><div class="line">barrier2.await();</div><div class="line">System.out.println(<span class="string">"线程2执行完成，执行线程3继续执行..."</span>);</div><div class="line"><span class="comment">//TODO</span></div><div class="line">System.out.println(<span class="string">"【线程3执行完成】"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">thread3.start();</div><div class="line">thread2.start();</div><div class="line">thread1.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;开始执行线程3...</div><div class="line">&gt;&gt;开始执行线程2...</div><div class="line">&gt;&gt;开始执行线程1...</div><div class="line">【线程1执行完成】</div><div class="line">线程1执行完成，执行线程2继续执行...</div><div class="line">【线程2执行完成】</div><div class="line">线程2执行完成，执行线程3继续执行...</div><div class="line">【线程3执行完成】</div></pre></td></tr></table></figure><h2 id="使用线程的Sephmore-信号量"><a href="#使用线程的Sephmore-信号量" class="headerlink" title="使用线程的Sephmore(信号量)"></a>使用线程的Sephmore(信号量)</h2><p>Sephmore(信号量)：Semaphore是一个计数信号量,从概念上将，Semaphore包含一组许可证，如果有需要的话，每个acquire()方法都会阻塞，直到获取一个可用的许可证，每个release()方法都会释放持有许可证的线程，并且归还Semaphore一个可用的许可证。然而，实际上并没有真实的许可证对象供线程使用，<strong>Semaphore只是对可用的数量进行管理维护</strong>。</p><ul><li><p>acquire()：当前线程尝试去阻塞的获取1个许可证，此过程是阻塞的，当前线程获取了1个可用的许可证，则会停止等待，继续执行。</p></li><li><p>release()：当前线程释放1个可用的许可证。</p></li></ul><p>应用场景：<strong>Semaphore可以用来做流量分流，特别是对公共资源有限的场景，比如数据库连接</strong>。</p><p>假设有这个的需求，读取几万个文件的数据到数据库中，由于文件读取是IO密集型任务，<strong>可以启动几十个线程并发读取，但是数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作</strong>。这个时候，就可以使用Semaphore做流量控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用Sephmore(信号量)实现线程按顺序运行</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore1 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"&gt;&gt;开始执行线程1..."</span>);</div><div class="line"><span class="comment">// TODO</span></div><div class="line">System.out.println(<span class="string">"【线程1执行完成】"</span>);</div><div class="line">semaphore1.release();</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">semaphore1.acquire();</div><div class="line">System.out.println(<span class="string">"&gt;&gt;开始执行线程2..."</span>);</div><div class="line"><span class="comment">// TODO</span></div><div class="line">System.out.println(<span class="string">"【线程2执行完成】"</span>);</div><div class="line">semaphore2.release();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">semaphore2.acquire();</div><div class="line">System.out.println(<span class="string">"&gt;&gt;开始执行线程3..."</span>);</div><div class="line"><span class="comment">// TODO</span></div><div class="line">System.out.println(<span class="string">"【线程3执行完成】"</span>);</div><div class="line">semaphore2.release();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">thread3.start();</div><div class="line">thread2.start();</div><div class="line">thread1.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;开始执行线程1...</div><div class="line">【线程1执行完成】</div><div class="line">&gt;&gt;开始执行线程2...</div><div class="line">【线程2执行完成】</div><div class="line">&gt;&gt;开始执行线程3...</div><div class="line">【线程3执行完成】</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis实现原理：动态代理的运用</title>
      <link href="/2019/11/14/MyBatis%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E8%BF%90%E7%94%A8/"/>
      <url>/2019/11/14/MyBatis%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E8%BF%90%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p> 动态代理的功能：</p><ul><li>通过拦截器方法回调，对目标target方法进行增强。</li><li>动态代理还有”投鞭断流“的霸权，连目标target都不要的使用方式。 </li></ul><h2 id="自动映射器Mapper自己实现"><a href="#自动映射器Mapper自己实现" class="headerlink" title="自动映射器Mapper自己实现"></a>自动映射器Mapper自己实现</h2><h3 id="定义pojo"><a href="#定义pojo" class="headerlink" title="定义pojo"></a>定义pojo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// getter setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id)</span></span>;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="定义代理类"><a href="#定义代理类" class="headerlink" title="定义代理类"></a>定义代理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.proxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Class&lt;T&gt; clz)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clz.getClassLoader(), <span class="keyword">new</span> Class[] &#123; clz &#125;, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 诸如hashCode()、toString()、equals()等方法，将target指向当前对象this</span></div><div class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 投鞭断流</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User((Integer) args[<span class="number">0</span>], <span class="string">"zhangsan"</span>, <span class="number">18</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">MapperProxy proxy = <span class="keyword">new</span> MapperProxy();</div><div class="line"></div><div class="line">UserMapper mapper = proxy.newInstance(UserMapper.class);</div><div class="line">User user = mapper.getUserById(<span class="number">1001</span>);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"ID:"</span> + user.getId());</div><div class="line">System.out.println(<span class="string">"Name:"</span> + user.getName());</div><div class="line">System.out.println(<span class="string">"Age:"</span> + user.getAge());</div><div class="line"></div><div class="line">System.out.println(mapper.toString());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ID:1001</div><div class="line">Name:zhangsan</div><div class="line">Age:18</div><div class="line">com.justxzm.proxy.MapperProxy@66788a7b</div></pre></td></tr></table></figure><p> 这便是Mybatis自动映射器Mapper的底层实现原理。</p><h2 id="自动映射器Mapper源码分析"><a href="#自动映射器Mapper源码分析" class="headerlink" title="自动映射器Mapper源码分析"></a>自动映射器Mapper源码分析</h2><h3 id="编写一个测试类"><a href="#编写一个测试类" class="headerlink" title="编写一个测试类"></a>编写一个测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">SqlSession sqlSession = MybatisSqlSessionFactory.openSession();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</div><div class="line">List&lt;Student&gt; students = studentMapper.findAllStudents();</div><div class="line"><span class="keyword">for</span> (Student student : students) &#123;</div><div class="line">System.out.println(student);</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">sqlSession.close();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</div><div class="line">    <span class="function">List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Student <span class="title">findStudentById</span><span class="params">(Integer id)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertStudent</span><span class="params">(Student student)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="MapperProxy-java"><a href="#MapperProxy-java" class="headerlink" title="MapperProxy.java"></a>MapperProxy.java</h3><p> org.apache.ibatis.binding.MapperProxy.java部分源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</div><div class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</div><div class="line">    <span class="keyword">this</span>.methodCache = methodCache;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 投鞭断流</span></div><div class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</div><div class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div></pre></td></tr></table></figure><h3 id="MapperProxyFactory-java"><a href="#MapperProxyFactory-java" class="headerlink" title="MapperProxyFactory.java"></a>MapperProxyFactory.java</h3><p> org.apache.ibatis.binding.MapperProxyFactory.java部分源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p> 这便是Mybatis使用动态代理之投鞭断流。 </p><h2 id="问题（重要）"><a href="#问题（重要）" class="headerlink" title="问题（重要）"></a>问题（重要）</h2><p>接口Mapper内的方法能重载（overLoad）吗？ 类似下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id, String name)</span></span>;</div></pre></td></tr></table></figure><p>Answer：不能。</p><p>原因：在投鞭断流时，Mybatis使用package+Mapper+method全限名作为key，去xml内寻找唯一sql来执行的。</p><p>类似：key=x.y.UserMapper.getUserById，那么，重载方法时将导致矛盾。对于Mapper接口，Mybatis禁止方法重载（overLoad）。</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定类加载器实现热加载</title>
      <link href="/2019/11/05/%E8%87%AA%E5%AE%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%83%AD%E5%8A%A0%E8%BD%BD/"/>
      <url>/2019/11/05/%E8%87%AA%E5%AE%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%83%AD%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是热加载"><a href="#什么是热加载" class="headerlink" title="什么是热加载"></a>什么是热加载</h2><ul><li>热加载是指在不重启服务的情况下让更改的代码生效。</li><li>热加载基于 Java 的类加载器实现，可以显著提升开发以及调试的效率。</li><li>由于热加载的不安全性，一般不会用于正式的生产环境。</li></ul><h2 id="热加载与热部署的区别"><a href="#热加载与热部署的区别" class="headerlink" title="热加载与热部署的区别"></a>热加载与热部署的区别</h2><p>相同点：</p><ul><li>都可以在不重启服务的情况下编译/部署项目。</li><li>都是基于 Java 的类加载器实现的。</li></ul><p>不同点：</p><ul><li>部署方式上：<ul><li>热部署是在服务器运行时重新部署项目。</li><li>热加载是在运行时重新加载 class。</li></ul></li><li>实现原理上：<ul><li>热部署是直接重新加载整个应用，耗时相对较高。</li><li>热加载是在运行时重新加载 class，后台启动一个线程不断检测类是否改变。</li></ul></li><li>使用场景上：<ul><li>热部署更多的是在生产环境使用。</li><li>热加载更多在开发环境上使用。线上由于安全性问题不会使用，难以监控。</li></ul></li></ul><a id="more"></a><h2 id="类加载五个阶段"><a href="#类加载五个阶段" class="headerlink" title="类加载五个阶段"></a>类加载五个阶段</h2><p><img src="/images/Java/2019110501.jpg" alt=""></p><p>类的完整生命周期一共是7个阶段，除图里最后的使用（Using）和卸载（Unloading）外的五个阶段是类加载阶段。</p><p>简单描述一下类加载的五个阶段：</p><ol><li>加载阶段：找到类的静态存储结构，加载到虚拟机，定义数据结构。用户可以自定义类加载器。</li><li>验证阶段：确保字节码是安全的，确保不会对虚拟机的安全造成危害。</li><li>准备阶段：确定内存布局，确定内存遍历，赋初始值（注意：是初始值，也有特殊情况）。</li><li>解析阶段：将符号变成直接引用。</li><li>初始化阶段：调用程序自定义的代码。规定有且仅有5种情况必须进行初始化：<ul><li>new（实例化对象）、getstatic（获取类变量的值，被final修饰的除外，他的值在编译器时放到了常量池）、putstatic（给类变量赋值）、invokestatic（调用静态方法） 时会初始化。</li><li>调用子类的时候，发现父类还没有初始化，则父类需要立即初始化。</li><li>虚拟机启动，用户要执行的主类，主类需要立即初始化，如 main 方法。</li><li>使用 java.lang.reflect包的方法对类进行反射调用方法是会初始化。</li><li>当使用JDK 1.7的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、 REF_putStatic、 REF_invokeStatic的方法句柄， 并且这个方法句柄所对应的类没有进行过初始化， 则需要先触发其初始化。</li></ul></li></ol><p>要说明的是，类加载的 5 个阶段中，<strong>只有加载阶段是用户可以自定义处理的</strong>，而验证阶段、准备阶段、解析阶段、初始化阶段都是用 JVM 来处理的。</p><h2 id="实现类的热加载"><a href="#实现类的热加载" class="headerlink" title="实现类的热加载"></a>实现类的热加载</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>根据分析：</p><ol><li>Java 程序在运行的时候，首先会把 class 类文件加载到 JVM 中，而类的加载过程又有五个阶段，五个阶段中只有加载阶段用户可以进行自定义处理。</li><li>所以我们如果能在程序代码更改且重新编译后，让运行的进程可以实时获取到新编译后的 class 文件，然后重新进行加载的话，那么理论上就可以实现一个简单的 Java 热加载。</li></ol><p>可以得出实现思路：</p><ol><li>实现自己的类加载器。</li><li>从自己的类加载器中加载要热加载的类。</li><li>不断轮训要热加载的类 class 文件是否有更新。</li><li>如果有更新，重新加载。</li></ol><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>设计 Java 虚拟机的团队把类的加载阶段放到的 JVM 的外部实现（通过一个类的全限定名来获取描述此类的二进制字节流 ），这样就可以让程序自己决定如何获取到类信息。而实现这个加载动作的代码模块，我们就称之为 “类加载器”。在 Java 中，类加载器也就是 <strong>ClassLoader</strong>。</p><p>所以如果我们想要自己<strong>实现一个类加载器</strong>，就<strong>需要继承 ClassLoader 然后重写里面 findClass的方法</strong>，同时因为类加载器是<strong>双亲委派模型</strong>实现（也就说，除了一个最顶层的类加载器之外，每个类加载器都要有父加载器，而加载时，会先询问父加载器能否加载，如果父加载器不能加载，则会自己尝试加载）所以我们还需要指定父加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.alex;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义Java类加载器来实现Java类的热加载</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClasslLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">/** 要加载的 Java 类的 classpath 路径 */</span></div><div class="line"><span class="keyword">private</span> String classpath;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyClasslLoader</span><span class="params">(String classpath)</span> </span>&#123;</div><div class="line"><span class="comment">// 指定父加载器</span></div><div class="line"><span class="keyword">super</span>(ClassLoader.getSystemClassLoader());</div><div class="line"><span class="keyword">this</span>.classpath = classpath;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line"><span class="keyword">byte</span>[] data = <span class="keyword">this</span>.loadClassData(name);</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, data, <span class="number">0</span>, data.length);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 加载 class 文件中的内容</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> name</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">// 传进来是带包名的</span></div><div class="line">name = name.replace(<span class="string">"."</span>, <span class="string">"//"</span>);</div><div class="line">FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(</div><div class="line">classpath + name + <span class="string">".class"</span>));</div><div class="line"><span class="comment">// 定义字节数组输出流</span></div><div class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> ((b = inputStream.read()) != -<span class="number">1</span>) &#123;</div><div class="line">baos.write(b);</div><div class="line">&#125;</div><div class="line">inputStream.close();</div><div class="line"><span class="keyword">return</span> baos.toByteArray();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="定义要类型热加载的类"><a href="#定义要类型热加载的类" class="headerlink" title="定义要类型热加载的类"></a>定义要类型热加载的类</h3><p>假设某个接口（BaseTask.java）下的某个方法（execute）要进行热加载处理。</p><p>首先定义接口信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.alex;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 实现这个接口的子类，需要动态更新。也就是热加载</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>写一个这个接口的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.alex;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * BaseTask 这个接口的实现类需要热加载功能。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">BaseTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">": Java类的热加载"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>后面要让这个类可以通过MyClassLoader进行自定义加载。为了避免无意义的重复加载，类的热加载应当只有在类的信息被更改然后重新编译之后进行重新加载，所以需要判断class是否进行了更新，需要记录class类的修改时间，以及对应的类信息。</p><p>编译一个类用来记录某个类对应的某个类加载器以及上次加载的class的修改时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.alex;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 封装加载类的信息</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadInfo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/** 自定义的类加载器 */</span></div><div class="line">    <span class="keyword">private</span> MyClasslLoader myClasslLoader;</div><div class="line"></div><div class="line">    <span class="comment">/** 记录要加载的类的时间戳--&gt;加载的时间 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> loadTime;</div><div class="line"></div><div class="line">    <span class="comment">/** 需要被热加载的类 */</span></div><div class="line">    <span class="keyword">private</span> BaseTask myTask;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadInfo</span><span class="params">(MyClasslLoader myClasslLoader, <span class="keyword">long</span> loadTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.myClasslLoader = myClasslLoader;</div><div class="line">        <span class="keyword">this</span>.loadTime = loadTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> MyClasslLoader <span class="title">getMyClasslLoader</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> myClasslLoader;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyClasslLoader</span><span class="params">(MyClasslLoader myClasslLoader)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.myClasslLoader = myClasslLoader;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLoadTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> loadTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadTime</span><span class="params">(<span class="keyword">long</span> loadTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.loadTime = loadTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> BaseTask <span class="title">getTask</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> myTask;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTask</span><span class="params">(BaseTask myTask)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.myTask = myTask;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="热加载获取类信息"><a href="#热加载获取类信息" class="headerlink" title="热加载获取类信息"></a>热加载获取类信息</h3><p>每次调用要热加载的类时，我们都要进行检查类是否被更新然后决定要不要重新加载。可以使用一个简单的工厂模式进行封装。 </p><p>要注意是加载class文件需要指定完整的路径，所以类中定义了CLASS_PATH 常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.alex;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 加载 manager 的工厂</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/** 记录热加载类的加载信息 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, LoadInfo&gt; loadTimeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/** 要加载的类的 classpath */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLASS_PATH = <span class="string">"E:\\MyLearning\\LearningWorkSpace\\MyLearning\\bin\\"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** 实现热加载的类的全名称(包名+类名 ) */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MY_MANAGER = <span class="string">"com.justxzm.alex.MyTask"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BaseTask <span class="title">getManager</span><span class="params">(String className)</span> </span>&#123;</div><div class="line">        File loadFile = <span class="keyword">new</span> File(CLASS_PATH + className.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>) + <span class="string">".class"</span>);</div><div class="line">        <span class="comment">// 获取最后一次修改时间</span></div><div class="line">        <span class="keyword">long</span> lastModified = loadFile.lastModified();</div><div class="line">        <span class="comment">// loadTimeMap 不包含 ClassName 为 key 的信息，证明这个类没有被加载，要加载到 JVM</span></div><div class="line">        <span class="keyword">if</span> (loadTimeMap.get(className) == <span class="keyword">null</span>) &#123;</div><div class="line">        System.out.println(<span class="string">"init"</span>);</div><div class="line">            load(className, lastModified);</div><div class="line">        &#125; <span class="comment">// 加载类的时间戳变化了，我们同样要重新加载这个类到 JVM。</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (loadTimeMap.get(className).getLoadTime() != lastModified) &#123;</div><div class="line">        System.out.println(<span class="string">"modify"</span>);</div><div class="line">            load(className, lastModified);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> loadTimeMap.get(className).getTask();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 加载 class ，缓存到 loadTimeMap</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> className</div><div class="line">     * <span class="doctag">@param</span> lastModified</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String className, <span class="keyword">long</span> lastModified)</span> </span>&#123;</div><div class="line">        MyClasslLoader myClasslLoader = <span class="keyword">new</span> MyClasslLoader(CLASS_PATH);</div><div class="line">        Class loadClass = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 加载</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//myClasslLoader.loadClass(className)采用默认类加载器，需进入debugger模式运行</span></div><div class="line">            loadClass = myClasslLoader.findClass(className);</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        BaseTask task = newInstance(loadClass);</div><div class="line">        LoadInfo loadInfo = <span class="keyword">new</span> LoadInfo(myClasslLoader, lastModified);</div><div class="line">        loadInfo.setTask(task);</div><div class="line">        loadTimeMap.put(className, loadInfo);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 以反射的方式创建 BaseManager 的子类对象</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> loadClass</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BaseTask <span class="title">newInstance</span><span class="params">(Class loadClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> (BaseTask)loadClass.getConstructor(<span class="keyword">new</span> Class[] &#123;&#125;).newInstance(<span class="keyword">new</span> Object[] &#123;&#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="热加载测试"><a href="#热加载测试" class="headerlink" title="热加载测试"></a>热加载测试</h3><p>写一个线程不断的检测要热加载的类是不是已经更改需要重新加载，然后运行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.alex;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 后台启动一条线程，不断检测是否要刷新重新加载，实现了热加载的类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgHandle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            BaseTask task = TaskFactory.getManager(TaskFactory.MY_MANAGER);</div><div class="line">            task.execute();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>主线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.justxzm.alex;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> MsgHandle()).start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>启动后看到控制台不断的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">init</div><div class="line">Tue Nov 05 19:49:38 CST 2019: Java类的热加载</div><div class="line">Tue Nov 05 19:49:40 CST 2019: Java类的热加载</div><div class="line">Tue Nov 05 19:49:42 CST 2019: Java类的热加载</div></pre></td></tr></table></figure><p> 这时候我们随便改下MyTask类的execute方法的输出内容然后保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">BaseTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">": Java类的热加载 By justxzm"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 可以看到控制台的输出已经自动更改了 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">init</div><div class="line">Tue Nov 05 20:12:52 CST 2019: Java类的热加载</div><div class="line">Tue Nov 05 20:12:54 CST 2019: Java类的热加载</div><div class="line">Tue Nov 05 20:12:56 CST 2019: Java类的热加载</div><div class="line">modify</div><div class="line">Tue Nov 05 20:12:58 CST 2019: Java类的热加载 By justxzm</div><div class="line">Tue Nov 05 20:13:00 CST 2019: Java类的热加载 By justxzm</div><div class="line">Tue Nov 05 20:13:02 CST 2019: Java类的热加载 By justxzm</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发总结-Executor框架</title>
      <link href="/2019/10/20/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-Executor%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/10/20/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-Executor%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>Java线程的创建与销毁需要一定的开销，如果为每一个任务创建一个新线程来执行：</p><ul><li>这些线程的创建与销毁将消耗大量的计算资源。</li><li>可能会使处于高负荷状态的应用最终崩溃。</li></ul><p>Java的线程既是工作单元，也是执行机制。从JDK 5开始，把工作单元与执行机制分离开来。<strong>工作单元包括Runnable和Callable，而执行机制由Executor框架提供</strong>。</p><h1 id="Executor框架简介"><a href="#Executor框架简介" class="headerlink" title="Executor框架简介"></a>Executor框架简介</h1><h2 id="Executor框架的两级调度模型"><a href="#Executor框架的两级调度模型" class="headerlink" title="Executor框架的两级调度模型"></a>Executor框架的两级调度模型</h2><p>在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程：</p><ol><li>Java线程启动时会创建一个本地操作系统线程。</li><li>当该Java线程终止时，这个操作系统线程也会被回收。</li><li>操作系统会调度所有线程并将它们分配给可用的CPU。</li></ol><p>这种两级调度模型：</p><ul><li><strong>在上层</strong>，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程，应用程序通过Executor框架控制上层的调度；</li><li><strong>在底层</strong>，操作系统内核将这些线程映射到硬件处理器上，下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</li></ul><a id="more"></a><p><img src="/images/并发编程/2019102201.png" alt=""></p><h2 id="Executor框架的结构"><a href="#Executor框架的结构" class="headerlink" title="Executor框架的结构"></a>Executor框架的结构</h2><p>Executor框架主要由3大部分组成如下：</p><ul><li><strong>任务</strong>。包括被执行任务需要实现的接口：<strong>Runnable接口或Callable接口</strong>。</li><li><strong>任务的执行</strong>。包括任务执行机制的<strong>核心接口Executor</strong>，以及<strong>继承自Executor的ExecutorService接口</strong>。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor和ScheduledThreadPoolExecutor）。</li><li><strong>异步计算的结果</strong>。包括<strong>接口Future</strong>和实现Future接口的<strong>FutureTask类</strong>。</li></ul><p>Executor框架包含的主要的类与接口如下图：</p><p><img src="/images/并发编程/2019102202.png" alt=""></p><p>上图中：</p><ul><li>Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。</li><li><strong>ThreadPoolExecutor</strong>是线程池的核心实现类，用来执行被提交的任务。</li><li><strong>ScheduledThreadPoolExecutor</strong>是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。</li><li><strong>Future接口和实现Future接口的FutureTask类</strong>，代表异步计算的结果。</li><li><strong>Runnable接口和Callable接口的实现类</strong>，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。</li></ul><h2 id="Executor框架的使用"><a href="#Executor框架的使用" class="headerlink" title="Executor框架的使用"></a>Executor框架的使用</h2><p><img src="/images/并发编程/2019102203.png" alt=""></p><ol><li><strong>主线程首先要创建实现Runnable或者Callable接口的任务对象</strong>。<ul><li>工具类Executors可以把一个Runnable对象封装为一个Callable对象：Executors.callable(Runnable task)或Executors.callable(Runnable task，Object resule)。</li></ul></li><li><strong>然后可以把Runnable对象直接交给ExecutorService执行</strong>。<ul><li>ExecutorService.execute(Runnable command)；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行：<ul><li>ExecutorService.submit(Runnable task)</li><li>或ExecutorService.submit(Callable<t>task)</t></li></ul></li></ul></li><li><strong>如果执行ExecutorService.submit(…)，ExecutorService将返回一个实现Future接口的对象</strong>（到目前为止的JDK中，返回的是FutureTask对象）。<ul><li>由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。</li></ul></li><li><strong>最后，主线程可以执行FutureTask.get()方法来等待任务执行完成</strong>。<ul><li>主线程也可以执行FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行。</li></ul></li></ol><h2 id="Executor框架的成员"><a href="#Executor框架的成员" class="headerlink" title="Executor框架的成员"></a>Executor框架的成员</h2><p>Executor框架的主要成员：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>ThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建3种类型的ThreadPoolExecutor：</p><ul><li>SingleThreadExecutor</li><li>FixedThreadPool</li><li>CachedThreadPool</li></ul><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p>Executors提供的，创建使用固定线程数的FixedThreadPool的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span></div></pre></td></tr></table></figure><p>FixedThreadPool适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。</p><h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p>Executors提供的，创建使用单个线程的SingleThreadExecutor的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></div></pre></td></tr></table></figure><p>SingleThreadExecutor适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。</p><h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><p>Executors提供的，创建一个会根据需要创建新线程的CachedThreadPool的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></div></pre></td></tr></table></figure><p>CachedThreadPool是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</p><h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建2种类型的ScheduledThreadPoolExecutor：</p><ul><li><strong>ScheduledThreadPoolExecutor</strong>：包含若干个线程的ScheduledThreadPoolExecutor。</li><li><strong>SingleThreadScheduledExecutor</strong>：只包含一个线程的ScheduledThreadPoolExecutor。</li></ul><p>工厂类Executors提供的，创建固定个数线程的<strong>ScheduledThreadPoolExecutor</strong>的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize,ThreadFactory threadFactory)</span></div></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。</p><p>Executors提供的，创建单个线程的<strong>SingleThreadScheduledExecutor</strong>的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span></div></pre></td></tr></table></figure><p>SingleThreadScheduledExecutor适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。</p><h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。</p><p>当我们把Runnable接口或Callable接口的实现类提交(submit)给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutureTask对象。下面是对应的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></div><div class="line">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></div><div class="line">Future&lt;&gt; <span class="title">submit</span><span class="params">(Runnable task)</span></div></pre></td></tr></table></figure><p>注意：到目前最新的JDK 8为止，Java通过上述API返回的是一个FutureTask对象。但从API可以看到，<strong>Java仅仅保证返回的是一个实现了Future接口的对象</strong>。在将来的JDK实现中，返回的可能不一定是FutureTask。</p><h3 id="Runnable接口和Callable接口"><a href="#Runnable接口和Callable接口" class="headerlink" title="Runnable接口和Callable接口"></a>Runnable接口和Callable接口</h3><p>Runnable接口和Callable接口的实现类：</p><ul><li>都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。</li><li>区别是Runnable不会返回结果，而Callable可以返回结果。</li></ul><p>除了可以自己创建实现Callable接口的对象外，还可以使用工厂类Executors来把一个Runnable包装成一个Callable。</p><p>Executors提供的，把一个Runnable包装成一个Callable的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span> <span class="comment">//假设返回对象Callable1</span></span></div></pre></td></tr></table></figure><p>Executors提供的，把一个Runnable和一个待返回的结果包装成一个Callable的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> <span class="comment">//假设返回对象Callable2</span></span></div></pre></td></tr></table></figure><p>当我们把一个Callable对象（比如上面的Callable1或Callable2）提交给ThreadPoolExecutor或ScheduledThreadPoolExecutor执行时，<strong>submit(…)会向我们返回一个FutureTask对象</strong>。我们<strong>可以执行FutureTask.get()方法来等待任务执行完成</strong>。当<strong>任务成功完成后FutureTask.get()将返回该任务的结果</strong>。</p><p><strong>例如</strong>：如果提交的是对象Callable1，FutureTask.get()方法将返回null；如果提交的是对象Callable2，FutureTask.get()方法将返回result对象。</p><h1 id="FutureTask详解"><a href="#FutureTask详解" class="headerlink" title="FutureTask详解"></a>FutureTask详解</h1><p>Future接口和实现Future接口的FutureTask类，<strong>代表异步计算的结果</strong>。</p><h2 id="FutureTask简介"><a href="#FutureTask简介" class="headerlink" title="FutureTask简介"></a>FutureTask简介</h2><p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）。根据FutureTask.run()方法被执行的时机，FutureTask可以处于下面3种状态：</p><ul><li><strong>未启动</strong>。FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。</li><li><strong>已启动</strong>。FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。</li><li><strong>已完成</strong>。FutureTask.run()方法执行完后正常结束，或被取消（FutureTask.cancel(…)），或执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态。</li></ul><p>FutureTask的<strong>状态迁移</strong>图如下：</p><p><img src="/images/并发编程/2019102701.png" alt=""></p><ul><li>当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞；</li><li>当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或抛出异常。</li><li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；</li><li>当FutureTask处于已启动状态时，执行FutureTask.cancel(true)方法将以中断执行此任务线程的方式来试图停止任务；</li><li>当FutureTask处于已启动状态时，执行FutureTask.cancel(false)方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；</li><li>当FutureTask处于已完成状态时，执行FutureTask.cancel(…)方法将返回false。</li></ul><p>FutureTask的get方法和cancel方法的执行示意图如下：</p><p><img src="/images/并发编程/2019102702.png" alt=""></p><h2 id="FutureTask的使用"><a href="#FutureTask的使用" class="headerlink" title="FutureTask的使用"></a>FutureTask的使用</h2><ul><li>可以把FutureTask交给Executor执行；</li><li>也可以通过ExecutorService.submit(…)方法返回一个FutureTask，然后执行FutureTask.get()方法或FutureTask.cancel(…)方法。</li><li>除此以外，还可以<strong>单独使用FutureTask</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, Future&lt;String&gt;&gt; taskCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Object, Future&lt;String&gt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">executionTask</span><span class="params">(<span class="keyword">final</span> String taskName)</span></span></div><div class="line"><span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">Future&lt;String&gt; future = taskCache.get(taskName);<span class="comment">// 1.1,2.1</span></div><div class="line"><span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;</div><div class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"><span class="keyword">return</span> taskName;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(task);</div><div class="line">future = taskCache.putIfAbsent(taskName, futureTask);<span class="comment">// 1.3</span></div><div class="line"><span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;</div><div class="line">future = futureTask;</div><div class="line">futureTask.run();<span class="comment">// 1.4执行任务</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">return</span> future.get();<span class="comment">// 1.5,2.2</span></div><div class="line">&#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">taskCache.remove(taskName, future);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发总结-线程池</title>
      <link href="/2019/10/19/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/10/19/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h2><p>Java中的<strong>线程池是运用场景最多的并发框架</strong>，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，<strong>合理地使用线程池能够带来3个好处</strong>：</p><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。</li></ol><h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p><img src="/images/并发编程/2019102001.png" alt=""></p><a id="more"></a><p>从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：</p><ol><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li><li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li><li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li></ol><p>ThreadPoolExecutor执行execute()方法的示意图如下：</p><p><img src="/images/并发编程/2019102002.png" alt=""></p><p>ThreadPoolExecutor执行execute方法分下面4种情况：</p><ol><li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li><li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li><li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</li><li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li></ol><p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，<strong>尽可能地避免获取全局锁</strong>（那将会是一个严重的可伸缩瓶颈）。在<strong>ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize）</strong>，几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>线程池执行任务的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (command == <span class="keyword">null</span>)&#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果线程数小于基本线程数，则创建线程并执行当前任务</span></div><div class="line"><span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</div><div class="line"><span class="comment">//如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span></div><div class="line"><span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line"><span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)&#123;</div><div class="line">ensureQueuedTaskHandled(command);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，</span></div><div class="line"><span class="comment">//则创建一个线程执行任务。</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))&#123;</div><div class="line"><span class="comment">//抛出RejectedExecutionException异常</span></div><div class="line">reject(command); <span class="comment">//is shutdown or saturated</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h3><p>线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。我们可以从Worker类的run()方法里看到这点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Runnable task = firstTask;</div><div class="line">firstTask = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line">runTask(task);</div><div class="line">task = <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">workerDone(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ThreadPoolExecutor中线程执行任务的示意图如下：</p><p><img src="/images/并发编程/2019102003.png" alt=""></p><p>线程池中的线程执行任务分两种情况，如下：</p><ol><li>在execute()方法中创建一个线程时，会让这个线程执行当前任务。</li><li>这个线程执行完上图中1的任务后，会反复从BlockingQueue获取任务来执行。</li></ol><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds, runnableTaskQueue, handler);</div></pre></td></tr></table></figure><p>创建一个线程池时需要输入几个参数，如下：</p><ol><li><p><strong>corePoolSize</strong>（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p></li><li><p><strong>runnableTaskQueue</strong>（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：</p><ul><li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li><li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li></ul></li><li><p><strong>maximumPoolSize</strong>（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p></li><li><p><strong>ThreadFactory</strong>：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字，代码如下。new ThreadFactoryBuilder().setNameFormat(“XX-task-%d”).build();</p></li><li><p><strong>RejectedExecutionHandler</strong>（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略：</p><ul><li><p>AbortPolicy：直接抛出异常。</p></li><li><p>CallerRunsPolicy：只用调用者所在线程来运行任务。</p></li><li><p>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</p></li><li><p>DiscardPolicy：不处理，丢弃掉。</p><p>当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</p></li></ul></li><li><p>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p></li><li><p>TimeUnit（线程活动保持时间的单位）：可选的单位有天(DAYS)、小时(HOURS)、分钟(MINUTES)、毫秒(MILLISECONDS)、微秒(MICROSECONDS，千分之一毫秒)和纳秒(NANOSECONDS，千分之一微秒)。</p></li></ol><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</p><p><strong>execute()方法用于提交不需要返回值的任务</strong>，所以<strong>无法判断任务是否被线程池执行成功</strong>。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><strong>submit()方法用于提交需要返回值的任务</strong>。<strong>线程池会返回一个future类型的对象</strong>，通过这个future对象可以判断任务是否执行成功，并且可以<strong>通过future的get()方法来获取返回值</strong>，<strong>get()方法会阻塞当前线程直到任务完成</strong>，而使用get(long timeout，TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Object s = future.get();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">// 处理中断异常</span></div><div class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line"><span class="comment">// 处理无法执行任务异常</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="comment">// 关闭线程池</span></div><div class="line">executor.shutdown();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。</p><p><strong>原理</strong>：遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p><p><strong>区别</strong>：shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p><p><strong>相同点</strong>：只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</p><p><strong>选择</strong>：至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p><h3 id="合理地配置线程池"><a href="#合理地配置线程池" class="headerlink" title="合理地配置线程池"></a>合理地配置线程池</h3><p>要想合理地配置线程池，就必须<strong>首先分析任务特性</strong>，可以从以下几个角度来分析：</p><ul><li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</li><li>任务的优先级：高、中和低。</li><li>任务的执行时间：长、中和短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li></ul><p><strong>性质不同的任务可以用不同规模的线程池分开处理</strong>：</p><ul><li>CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。</li><li>由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。</li><li>混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。</li></ul><p>可以通过<strong>Runtime.getRuntime().availableProcessors()</strong>方法<strong>获得当前设备的CPU个数</strong>。</p><p><strong>注意</strong>：</p><ul><li>优先级不同的任务可以使用优先级队列<strong>PriorityBlockingQueue</strong>来处理。它可以<strong>让优先级高的任务先执行</strong>。但如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</li><li><strong>执行时间不同的任务可以交给不同规模的线程池来处理</strong>，或者可以使用优先级队列，<strong>让执行时间短的任务先执行</strong>。</li><li><strong>依赖数据库连接池的任务</strong>，因为线程提交SQL后需要等待数据库返回结果，<strong>等待的时间越长</strong>，则CPU空闲时间就越长，那么<strong>线程数应该设置得越大</strong>，这样才能更好地利用CPU。</li><li><strong>建议使用有界队列</strong>。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。</li><li><strong>使用不同规模的线程池完成不同类型的任务</strong>。</li></ul><h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。</p><p>可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性：</p><ul><li>taskCount：线程池需要执行的任务数量。</li><li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li><li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li><li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li><li>getActiveCount：获取活动的线程数。</li></ul><p><strong>通过扩展线程池进行监控</strong>：可以通过继承线程池来自定义线程池，<strong>重写线程池的beforeExecute、afterExecute和terminated方法</strong>，也可以<strong>在任务执行前、执行后和线程池关闭前执行一些代码来进行监控</strong>。例如：<strong>监控任务的平均执行时间、最大执行时间和最小执行时间</strong>等。这几个方法在线程池里是空方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure><h2 id="实现自己的线程池"><a href="#实现自己的线程池" class="headerlink" title="实现自己的线程池"></a>实现自己的线程池</h2><p>使用钩子为线程池加点料（可用于日志记录）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PauseableThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isPaused;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">private</span> Condition unPaused = lock.newCondition();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PauseableThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line"><span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PauseableThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="keyword">long</span> keepAliveTime, TimeUnit unit,</div><div class="line">BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123;</div><div class="line"><span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">threadFactory);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PauseableThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="keyword">long</span> keepAliveTime, TimeUnit unit,</div><div class="line">BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123;</div><div class="line"><span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">handler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PauseableThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="keyword">long</span> keepAliveTime, TimeUnit unit,</div><div class="line">BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory,</div><div class="line">RejectedExecutionHandler handler) &#123;</div><div class="line"><span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">threadFactory, handler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>.beforeExecute(t, r);</div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">while</span> (isPaused) &#123;</div><div class="line">unPaused.await();</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">isPaused = <span class="keyword">true</span>;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">isPaused = <span class="keyword">false</span>;</div><div class="line"><span class="comment">// 唤醒全部</span></div><div class="line">unPaused.signalAll();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">PauseableThreadPool pauseableThreadPool = <span class="keyword">new</span> PauseableThreadPool(<span class="number">10</span>,</div><div class="line"><span class="number">20</span>, <span class="number">10L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"我被执行"</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">pauseableThreadPool.execute(runnable);</div><div class="line">&#125;</div><div class="line">Thread.sleep(<span class="number">1500</span>);</div><div class="line">pauseableThreadPool.pause();</div><div class="line">System.out.println(<span class="string">"线程池被暂停了"</span>);</div><div class="line">Thread.sleep(<span class="number">2000</span>);</div><div class="line">pauseableThreadPool.resume();</div><div class="line">System.out.println(<span class="string">"线程池被恢复了"</span>);</div><div class="line">pauseableThreadPool.shutdownNow();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发总结-并发工具类</title>
      <link href="/2019/10/12/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2019/10/12/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="等待多线程完成的CountDownLatch"><a href="#等待多线程完成的CountDownLatch" class="headerlink" title="等待多线程完成的CountDownLatch"></a>等待多线程完成的CountDownLatch</h2><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p><p><strong>假如有这样一个需求：</strong>我们需要解析一个Excel里多个sheet的数据，此时可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完成。在这个需求中，<strong>要实现主线程等待所有线程完成sheet的解析操作</strong>，最简单的做法是使用join()方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinCountDownLatchTest</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">Thread parser1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"parser1 finish"</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">Thread parser2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"parser2 finish"</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">parser1.start();</div><div class="line">parser2.start();</div><div class="line">parser1.join();</div><div class="line">parser2.join();</div><div class="line">System.out.println(<span class="string">"all parser finish"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">parser1 finish</div><div class="line">parser2 finish</div><div class="line">all parser finish</div></pre></td></tr></table></figure><p><strong>join用于让当前执行线程等待join线程执行结束</strong>。其实现<strong>原理是不停检查join线程是否存活</strong>，如果join线程存活则让当前线程永远等待。wait(0)表示永远等待下去，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (isAlive()) &#123;</div><div class="line">wait(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>直到<strong>join线程中止后</strong>，<strong>线程的this.notifyAll()方法会被调用</strong>，调用notifyAll()方法是在JVM里实现的，所以在JDK里看不到，可以查看JVM源码。</p><p>在JDK 1.5之后的并发包中提供的<strong>CountDownLatch也可以实现join的功能</strong>，并且<strong>比join的功能更多</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</div><div class="line"><span class="comment">//构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。</span></div><div class="line"><span class="keyword">static</span> CountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="number">1</span>);</div><div class="line"><span class="comment">//调用CountDownLatch的countDown方法时，N就会减1，</span></div><div class="line">c.countDown();</div><div class="line">System.out.println(<span class="number">2</span>);</div><div class="line">c.countDown();</div><div class="line">&#125;</div><div class="line">&#125;).start();</div><div class="line"><span class="comment">//CountDownLatch的await方法会阻塞当前线程，直到N变成零。</span></div><div class="line">c.await();</div><div class="line">System.out.println(<span class="string">"3"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure><p>由于countDown方法可以用在任何地方，所以这里说的<strong>N个点</strong>，<strong>可以是N个线程</strong>，<strong>也可以是1个线程里的N个执行步骤</strong>。用在多个线程时，只需把这个CountDownLatch的引用传递到线程里即可。</p><p>如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以使用另外一个<strong>带指定时间的await方法</strong>——<strong>await(long time，TimeUnit unit)</strong>，这个方法等待特定时间后，就会不再阻塞当前线程。join也有类似的方法。</p><p><strong>注意</strong>：</p><ul><li><strong>计数器必须大于等于0</strong>，只是<strong>等于0时</strong>候，<strong>计数器就是零</strong>，<strong>调用await方法时不会阻塞当前线程</strong>。</li><li>CountDownLatch<strong>不可能重新初始化或者修改其对象内部计数器的值</strong>。</li><li>一个线程调用countDown方法happen-before，另一个线程调用await方法。</li></ul><h2 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h2><p>CyclicBarrier的字面意思是<strong>可循环使用</strong>（Cyclic）的<strong>屏障</strong>（Barrier）。</p><p><strong>作用</strong>：<strong>让一组线程到达一个屏障</strong>（也可以叫同步点）时被阻塞，<strong>直到最后一个线程到达屏障</strong>时，屏障才会开门，<strong>所有被屏障拦截的线程才会继续运行</strong>。</p><h3 id="CyclicBarrier简介"><a href="#CyclicBarrier简介" class="headerlink" title="CyclicBarrier简介"></a>CyclicBarrier简介</h3><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其<strong>参数表示屏障拦截的线程数量</strong>，每个<strong>线程调用await方法告诉CyclicBarrier我已经到达了屏障</strong>，<strong>然后当前线程被阻塞</strong>。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">c.await();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">&#125;).start();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">c.await();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生两种输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//第一种可能输出如下：</div><div class="line">1</div><div class="line">2</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//第二种可能输出如下：</div><div class="line">2</div><div class="line">1</div></pre></td></tr></table></figure><p><strong>如果</strong>把new CyclicBarrier(2)修改成new CyclicBarrier(3)，则<strong>主线程和子线程会永远等待</strong>，<strong>因为</strong>没有第三个线程执行await方法，即<strong>没有第三个线程到达屏障</strong>，所以<strong>之前到达屏障的两个线程都不会继续执行</strong>。</p><p>CyclicBarrier还<strong>提供一个更高级的构造函数</strong>CyclicBarrier(int parties，Runnable barrier-Action)，<strong>用于在线程到达屏障时，优先执行barrierAction</strong>，方便处理更复杂的业务场景，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> A());</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">c.await();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">&#125;).start();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">c.await();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为CyclicBarrier设置了拦截线程的数量是2，所以必须等代码中的第一个线程和线程A都执行完之后，才会继续执行主线程，然后输出2，所以代码执行输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">3</div><div class="line">1</div><div class="line">2</div></pre></td></tr></table></figure><h3 id="CyclicBarrier应用场景"><a href="#CyclicBarrier应用场景" class="headerlink" title="CyclicBarrier应用场景"></a>CyclicBarrier应用场景</h3><p>CyclicBarrier<strong>可用于多线程计算数据</strong>，<strong>最后合并计算结果的场景</strong>。</p><p><strong>例如</strong>：用一个Excel保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 银行流水处理服务类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankWaterService</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 创建4个屏障，处理完之后执行当前类的run方法</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">this</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 假设只有4个sheet，所以只启动4个线程</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> Executor executor = Executors.newFixedThreadPool(<span class="number">4</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 保存每个sheet计算出的银流结果</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Integer&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">executor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// 计算当前sheet的银流数据，计算代码省略</span></div><div class="line">sheetBankWaterCount.put(Thread.currentThread().getName(), <span class="number">1</span>);</div><div class="line"><span class="comment">// 银流计算完成，插入一个屏障</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">c.await();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line"><span class="comment">// 汇总每个sheet计算出的结果</span></div><div class="line"><span class="keyword">for</span> (Entry&lt;String, Integer&gt; sheet : sheetBankWaterCount.entrySet()) &#123;</div><div class="line">result += sheet.getValue();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 将结果输出</span></div><div class="line">sheetBankWaterCount.put(<span class="string">"result"</span>, result);</div><div class="line">System.out.println(result);<span class="comment">//4</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">BankWaterService bankWaterCount = <span class="keyword">new</span> BankWaterService();</div><div class="line">bankWaterCount.count();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="和CountDownLatch的区别"><a href="#和CountDownLatch的区别" class="headerlink" title="和CountDownLatch的区别"></a>和CountDownLatch的区别</h3><p><strong>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</strong>所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</p><p>CyclicBarrier还提供其他有用的方法：</p><ul><li>getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。</li><li>isBroken()方法用来了解阻塞的线程是否被中断。</li></ul><p>isBroken的使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest3</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span></div><div class="line">BrokenBarrierException &#123;</div><div class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">c.await();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">thread.start();</div><div class="line">thread.interrupt();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">c.await();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">System.out.println(c.isBroken());<span class="comment">//true</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="控制并发线程数的Semaphore"><a href="#控制并发线程数的Semaphore" class="headerlink" title="控制并发线程数的Semaphore"></a>控制并发线程数的Semaphore</h2><p>Semaphore（信号量）是<strong>用来控制同时访问特定资源的线程数量</strong>，它通过协调各个线程，以保证合理的使用公共资源。</p><p>从字面上很难理解Semaphore所表达的含义，只能<strong>把它比作是控制流量的红绿灯</strong>：比如××马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入××马路，但是如果前一百辆中有5辆车已经离开了××马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>Semaphore可以<strong>用于做流量控制</strong>，<strong>特别是公用资源有限</strong>的应用场景，比如<strong>数据库连接</strong>。</p><p>假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</div><div class="line"><span class="comment">//Semaphore的构造方法Semaphore(int permits)接受一个整型的数字，表示可用的许可证数量。</span></div><div class="line"><span class="comment">//Semaphore(10)表示允许10个线程获取许可证，也就是最大并发数是10</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//虽然有30个线程在执行，但是只允许10个并发执行。</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</div><div class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//首先线程使用Semaphore的acquire()方法获取一个许可证</span></div><div class="line">s.acquire();<span class="comment">//还可以用tryAcquire()方法尝试获取许可证</span></div><div class="line">System.out.println(<span class="string">"save data"</span>);</div><div class="line"><span class="comment">//使用完之后调用release()方法归还许可证</span></div><div class="line">s.release();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">//TODO</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">threadPool.shutdown();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>Semaphore还提供一些其他方法：</p><ul><li>intavailablePermits()：返回此信号量中当前可用的许可证数。</li><li>intgetQueueLength()：返回正在等待获取许可证的线程数。</li><li>booleanhasQueuedThreads()：是否有线程正在等待获取许可证。</li><li>void reducePermits(int reduction)：减少reduction个许可证，是个protected方法。</li><li>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</li></ul><h2 id="线程间交换数据的Exchanger"><a href="#线程间交换数据的Exchanger" class="headerlink" title="线程间交换数据的Exchanger"></a>线程间交换数据的Exchanger</h2><p>Exchanger（交换者）：</p><ul><li>是一个用于线程间协作的工具类。</li><li>用于进行线程间的数据交换。</li><li>它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果<strong>第一个线程先执行exchange()</strong>方法，它会一直<strong>等待第二个线程也执行exchange</strong>方法，<strong>当两个线程都到达同步点时，这两个线程就可以交换数据</strong>，将本线程生产出来的数据传递给对方。</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>Exchanger可以用于遗传算法</strong>，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。</li><li><strong>Exchanger也可以用于校对工作</strong>，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</li></ul><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> Exchanger&lt;String&gt;();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">String A = <span class="string">"银行流水A"</span>;<span class="comment">// A录入银行流水数据</span></div><div class="line">exgr.exchange(A);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">String B = <span class="string">"银行流水B"</span>;<span class="comment">// B录入银行流水数据</span></div><div class="line">String A = exgr.exchange(<span class="string">"B"</span>);</div><div class="line">System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span></div><div class="line">+ A + <span class="string">"，B录入是："</span> + B);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">threadPool.shutdown();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange(V x，longtimeout，TimeUnit unit)设置最大等待时长。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发总结-原子操作类</title>
      <link href="/2019/10/12/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"/>
      <url>/2019/10/12/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>Java从JDK 1.5开始提供了<strong>java.util.concurrent.atomic</strong>包（以下简称<strong>Atomic包</strong>），这个包中的原子操作类<strong>提供了一种用法简单、性能高效、线程安全地更新一个变量的方式</strong>。</p><p>因为变量的类型有很多种，所以在Atomic包里<strong>一共提供了13个类</strong>，属于<strong>4种类型的原子更新方式</strong>，分别是<strong>原子更新基本类型</strong>、<strong>原子更新数组</strong>、<strong>原子更新引用</strong>和<strong>原子更新属性</strong>（字段）。Atomic包里的类<strong>基本都是使用Unsafe实现的包装类</strong>。</p><h2 id="原子更新基本类型类"><a href="#原子更新基本类型类" class="headerlink" title="原子更新基本类型类"></a>原子更新基本类型类</h2><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类：</p><ul><li><strong>AtomicBoolean</strong>：原子更新布尔类型。</li><li><strong>AtomicInteger</strong>：原子更新整型。</li><li><strong>AtomicLong</strong>：原子更新长整型。</li></ul><a id="more"></a><p>以上3个类提供的方法几乎一模一样，本文仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：</p><ul><li><strong>int addAndGet（int delta）</strong>：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</li><li><strong>boolean compareAndSet（int expect，int update）</strong>：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</li><li><strong>int getAndIncrement()</strong>：以原子方式将当前值加1，注意，这里返回的是自增前的值。</li><li><strong>void lazySet（int newValue）</strong>：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</li><li><strong>int getAndSet（int newValue）</strong>：以原子方式设置为newValue的值，并返回旧值。</li></ul><p>AtomicInteger示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">System.out.println(ai.getAndIncrement());<span class="comment">//1</span></div><div class="line">System.out.println(ai.get());<span class="comment">//2</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>getAndIncrement是如何实现原子操作的呢？源码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># AtomicInteger.java</div><div class="line">public final int getAndIncrement() &#123;</div><div class="line">for (;;) &#123;</div><div class="line">int current = get();</div><div class="line">int next = current + 1;</div><div class="line">if (compareAndSet(current, next))&#123;</div><div class="line">return current;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; </div><div class="line">public final boolean compareAndSet(int expect, int update) &#123;</div><div class="line">return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>源码中for循环体：</p><ol><li>第一步先取得AtomicInteger里存储的数值；</li><li>第二步对AtomicInteger的当前数值进行加1操作；</li><li>关键的第三步调用compareAndSet方法来进行原子更新操作：<ul><li>该方法先检查当前数值是否等于current，等于意味着AtomicInteger的值没有被其他线程修改过，则将AtomicInteger的当前数值更新成next的值；</li><li>如果不等compareAndSet方法会返回false，程序会进入for循环重新进行compareAndSet操作。</li></ul></li></ol><p>Atomic包提供了3种基本类型的原子更新，但是Java的基本类型里还有char、float和double等。那么<strong>如何原子的更新其他的基本类型呢</strong>？Atomic包里的类基本都是使用Unsafe实现的，让我们一起看一下Unsafe的源码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># Unsafe.java</div><div class="line">/**</div><div class="line">* 如果当前数值是expected，则原子的将Java变量更新成x</div><div class="line">* @return 如果更新成功则返回true</div><div class="line">*/</div><div class="line">public final native boolean compareAndSwapObject(Object o,long offset,Object expected,Object x);</div><div class="line">public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x);</div><div class="line">public final native boolean compareAndSwapLong(Object o, long offset,long expected,long x);</div></pre></td></tr></table></figure><p>通过代码，我们发现Unsafe<strong>只提供了3种CAS方法</strong>：<strong>compareAndSwapObject</strong>、<strong>compare-AndSwapInt</strong>和<strong>compareAndSwapLong</strong>，再看<strong>AtomicBoolean</strong>源码，发现它是<strong>先把Boolean转换成整型，再使用compareAndSwapInt进行CAS</strong>，所以原子更新char、float和double变量也可以用类似的思路来实现。</p><h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下3个类：</p><ul><li><strong>AtomicIntegerArray</strong>：原子更新整型数组里的元素。</li><li><strong>AtomicLongArray</strong>：原子更新长整型数组里的元素。</li><li><strong>AtomicReferenceArray</strong>：原子更新引用类型数组里的元素。</li></ul><p>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型，其常用方法如下：</p><ul><li><strong>int addAndGet（int i，int delta）</strong>：以原子方式将输入值与数组中索引i的元素相加。</li><li><strong>boolean compareAndSet（int i，int expect，int update）</strong>：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</li></ul><p>以上几个类提供的方法几乎一样，本文仅以AtomicIntegerArray为例进行讲解，AtomicIntegerArray的使用实例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">static</span> AtomicIntegerArray ai = <span class="keyword">new</span> AtomicIntegerArray(value);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">ai.getAndSet(<span class="number">0</span>, <span class="number">3</span>);</div><div class="line">System.out.println(ai.get(<span class="number">0</span>));<span class="comment">//3</span></div><div class="line">System.out.println(value[<span class="number">0</span>]);<span class="comment">//1</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意：数组value通过构造方法传递进去，然后AtomicIntegerArray<strong>会将当前数组复制一份</strong>，所以当<strong>AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组</strong>。</p><h2 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h2><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p><ul><li><strong>AtomicReference</strong>：原子更新引用类型。</li><li><strong>AtomicReferenceFieldUpdater</strong>：原子更新引用类型里的字段。</li><li><strong>AtomicMarkableReference</strong>：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，booleaninitialMark）。</li></ul><p>以上几个类提供的方法几乎一样，本文仅以AtomicReference为例进行讲解，AtomicReference的使用示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;User&gt; atomicUserRef = <span class="keyword">new</span> AtomicReference&lt;User&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">User user = <span class="keyword">new</span> User(<span class="string">"conan"</span>, <span class="number">15</span>);</div><div class="line">atomicUserRef.set(user);</div><div class="line">User updateUser = <span class="keyword">new</span> User(<span class="string">"Shinichi"</span>, <span class="number">17</span>);</div><div class="line">atomicUserRef.compareAndSet(user, updateUser);<span class="comment">//实现原理同AtomicInteger里的compareAndSet方法</span></div><div class="line">System.out.println(atomicUserRef.get().getName());<span class="comment">//Shinichi</span></div><div class="line">System.out.println(atomicUserRef.get().getOld());<span class="comment">//17</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> String name;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> old;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> old)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.old = old;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> old;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h2><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新：</p><ul><li><strong>AtomicIntegerFieldUpdater</strong>：原子更新整型的字段的更新器。</li><li><strong>AtomicLongFieldUpdater</strong>：原子更新长整型字段的更新器。</li><li><strong>AtomicStampedReference</strong>：原子更新带有版本号的引用类型。该类<strong>将整数值与引用关联</strong>起来，可<strong>用于原子的更新数据和数据的版本号</strong>，可以<strong>解决</strong>使用CAS进行原子更新时可能出现的<strong>ABA问题</strong>。</li></ul><p>要想原子地更新字段类需要两步：</p><ol><li>第一步，因为原子更新字段类都是抽象类，每次使用的时候必须<strong>使用静态方法newUpdater()创建一个更新器</strong>，并且需要<strong>设置想要更新的类和属性</strong>。</li><li>第二步，<strong>更新类的字段（属性）必须使用public volatile修饰符</strong>。</li></ol><p>以上3个类提供的方法几乎一样，本文仅以AstomicIntegerFieldUpdater为例进行讲解，AstomicIntegerFieldUpdater的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</div><div class="line"><span class="comment">// 创建原子更新器，并设置需要更新的对象类和对象的属性</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater</div><div class="line">.newUpdater(User.class, <span class="string">"old"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// 设置柯南的年龄是10岁</span></div><div class="line">User conan = <span class="keyword">new</span> User(<span class="string">"conan"</span>, <span class="number">10</span>);</div><div class="line"><span class="comment">// 柯南长了一岁，但是仍然会输出旧的年龄</span></div><div class="line">System.out.println(a.getAndIncrement(conan));<span class="comment">//10</span></div><div class="line"><span class="comment">// 输出柯南现在的年龄</span></div><div class="line">System.out.println(a.get(conan));<span class="comment">//11</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> String name;</div><div class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> old;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> old)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.old = old;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> old;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle归档日志启用与维护</title>
      <link href="/2019/10/09/Oracle%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97%E5%90%AF%E7%94%A8%E4%B8%8E%E7%BB%B4%E6%8A%A4/"/>
      <url>/2019/10/09/Oracle%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97%E5%90%AF%E7%94%A8%E4%B8%8E%E7%BB%B4%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="归档开启情况判断"><a href="#归档开启情况判断" class="headerlink" title="归档开启情况判断"></a>归档开启情况判断</h1><ul><li><p>通用方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; SELECT log_mode from v$database;</div></pre></td></tr></table></figure></li><li><p>sys用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; archive log list;</div></pre></td></tr></table></figure></li></ul><h1 id="如何开启日志归档"><a href="#如何开启日志归档" class="headerlink" title="如何开启日志归档"></a>如何开启日志归档</h1><ol><li><p>启用归档日志前要先停止数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; shutdown immediate;</div></pre></td></tr></table></figure></li><li><p>开启数据库至mount状态(打开控制文件，不打开数据文件)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; startup mount;</div></pre></td></tr></table></figure><a id="more"></a></li><li><p>改变日志模式</p><ul><li><p>启用数据库归档</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; alter database archivelog;</div></pre></td></tr></table></figure></li><li><p>关闭归档</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; alter database noarchivelog;</div></pre></td></tr></table></figure></li></ul></li><li><p>打开数据库（将数据文件打开）</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; alter database open;</div></pre></td></tr></table></figure></li><li><p>验证当前日志模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; archive log list;</div></pre></td></tr></table></figure></li></ol><h1 id="归档启动后的设置"><a href="#归档启动后的设置" class="headerlink" title="归档启动后的设置"></a>归档启动后的设置</h1><ul><li><p>归档进程设置：</p><ul><li><p>查看</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SQL&gt; show parameter log_archive_max_processes;</div><div class="line">NAME                                 TYPE        VALUE</div><div class="line">log_archive_max_processes            integer     4</div></pre></td></tr></table></figure></li><li><p>修改：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SQL&gt; alter system set log_archive_max_processes=5;</div><div class="line">System altered</div></pre></td></tr></table></figure></li></ul></li></ul><h1 id="归档占用情况判断"><a href="#归档占用情况判断" class="headerlink" title="归档占用情况判断"></a>归档占用情况判断</h1><ul><li><p>查看闪回空间已经占用情况</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 如果空间使用率99%以上，证明归档空间已经满了，需要清理。</div><div class="line">SQL&gt; select * from V$FLASH_RECOVERY_AREA_USAGE;</div></pre></td></tr></table></figure></li><li><p>查看归档日志文件数量</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; select  * from v$recovery_file_dest;</div></pre></td></tr></table></figure></li><li><p>当出现<strong>ORA-00257: archiver error. Connect internal only, until freed</strong>错误连不上数据库时，如果数据库归档目标为USE_DB_RECOVERY_FILE_DEST且DB_RECOVERY_FILE_DEST目录为默认闪回空间目录时。</p></li></ul><h1 id="归档高占用处理方法"><a href="#归档高占用处理方法" class="headerlink" title="归档高占用处理方法"></a>归档高占用处理方法</h1><h2 id="归档路径设置"><a href="#归档路径设置" class="headerlink" title="归档路径设置"></a>归档路径设置</h2><h3 id="单一归档路径"><a href="#单一归档路径" class="headerlink" title="单一归档路径"></a>单一归档路径</h3><ul><li><p>如果使用<strong>db_recovery_file_dest</strong>参数设置单一的归档目录，默认使用<strong>Fast Recovery Area闪回恢复区</strong>存放归档数据。</p><ul><li><p>需要注意该区域有大小限制，建议将大小调大：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; alter system set db_recovery_file_dest_size=8G scope=both;</div></pre></td></tr></table></figure></li><li><p>修改闪回恢复区路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; alter system set db_recovery_file_dest=&apos;location=C:\app\Administrator\oracle_log&apos; scope=both;</div></pre></td></tr></table></figure></li><li><p>查看闪回归档存储路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; show parameter db_recovery_file_dest;</div></pre></td></tr></table></figure></li></ul></li><li><p>也可<strong>手工配置log_archive_dest初始化参数</strong>，使用本地路径存放归档日志，这里给出的是本地文件系统例子，可自行测试ASM磁盘组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 需要将DB_RECOVERY_FILE_DEST和LOG_ARCHIVE_DEST_n参数置空参数置空</div><div class="line">SQL&gt; alter system set db_recovery_file_dest=&apos;&apos;;</div><div class="line">SQL&gt; alter system set log_archive_dest_1 =&apos;&apos;;</div><div class="line"># 然后设置log_archive_dest参数</div><div class="line">SQL&gt; alter system set log_archive_dest =&quot;C:\log&quot;;</div></pre></td></tr></table></figure></li></ul><h3 id="两路归档路径"><a href="#两路归档路径" class="headerlink" title="两路归档路径"></a>两路归档路径</h3><p>配置<strong>log_archive_dest</strong>和<strong>log_archive_duplex_dest</strong>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 设置log_archive_duplex_dest参数路径</div><div class="line">SQL&gt; alter system set log_archive_duplex_dest=&apos;C:\log&apos;;</div><div class="line"># 切换日志触发写归档日志</div><div class="line">SQL&gt; alter system switch logfile;</div></pre></td></tr></table></figure><p>查看新生成的归档日志文件，可以看到新生成的归档大小和文件名一致。两份归档日志互为冗余。</p><h3 id="多路归档路径"><a href="#多路归档路径" class="headerlink" title="多路归档路径"></a>多路归档路径</h3><p>使用<strong>log_archive_dest_n</strong>参数，其中，<strong>n的取值为1到31的整数</strong>，也就是说，可以指定1到31个独立的路径作为归档日志的路径。</p><p> <strong>log_archive_dest_n</strong>参数的取值可以选择<strong>LOCATION</strong>或<strong>SERVIDE</strong>关键字：</p><ul><li>如果使用LOCATION关键字，可以选择本地文件系统、ASM磁盘组或<strong>USE_DB_RECOVERY_FILE_DEST代表的闪回恢复区</strong>；（在使用Fast Recovery Area归档的情况下，LOG_ARCHIVE_DEST_1的默认值为USE_DB_RECOVERY_FILE_DEST。）</li><li>如果使用SERVICE关键字，可以选择备库的网络连接标识符连接备份数据库。</li></ul><ol><li><p>需要将LOG_ARCHIVE_DEST和LOG_ARCHIVE_DUPLEX_DEST参数置空：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SQL&gt; alter system set log_archive_duplex_dest='';</div><div class="line">SQL&gt; alter system set log_archive_dest='';</div></pre></td></tr></table></figure></li><li><p>修改多路归档日志路径： </p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SQL&gt; alter system set log_archive_dest_1='location=C:\log\arch1' scope=spfile; </div><div class="line">SQL&gt; alter system set log_archive_dest_2='location=C:\log\arch2' scope=spfile;</div><div class="line">SQL&gt; alter system set log_archive_dest_3='location=C:\log\arch3' scope=spfile;</div></pre></td></tr></table></figure></li><li><p>查看归档文件目录：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; show parameter LOG_ARCHIVE_DEST_;</div></pre></td></tr></table></figure></li><li><p>再次查看：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SQL&gt; archive log list;</div><div class="line">数据库日志模式  存档模式</div><div class="line">自动存档启用</div><div class="line">存档终点C:\orclBackUp\archive01</div><div class="line">最早的联机日志序列18</div><div class="line">下一个存档日志序列20</div><div class="line">当前日志序列  20</div></pre></td></tr></table></figure></li><li><p>通过切换日志，查看归档路径下是否有归档日志产生来验证归档路径设置是否正确，切换日志命令如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; alter system switch logfile;</div></pre></td></tr></table></figure></li><li><p>查看新生成的归档日志文件，显然新生成的归档大小和文件名一致。两份归档日志互为冗余。</p></li></ol><h3 id="归档路径参数区别"><a href="#归档路径参数区别" class="headerlink" title="归档路径参数区别"></a>归档路径参数区别</h3><ul><li>DB_RECOVERY_FILE_DEST：闪回恢复区路径</li><li>LOG_ARCHIVE_DEST：指定归档文件存放的路径，该路径只能是本地磁盘，默认为’’。</li><li>LOG_ARCHIVE_DEST_n：指定归档文件存放的路径，Oracle最多支持把日志文件归档到31个地方，n从1到31。归档地址可以为本地磁盘，或者网络设备。</li></ul><p><strong>三个参数区别如下：</strong></p><ol><li><p>如果设置了DB_RECOVERY_FILE_DEST，就不能设置LOG_ARCHIVE_DEST，<strong>默认的归档日志存放于DB_RECOVERY_FILE_DEST指定的闪回恢复区中</strong>。</p><p>可以设置LOG_ARCHIVE_DEST_n，如果这样，那么归档日志不再存放于DB_RECOVERY_FILE_DEST中，而是存放于LOG_ARCHIVE_DEST_n设置的目录中。</p><p>如果<strong>想要归档日志继续存放在DB_RECOVERY_FILE_DEST中</strong>，可以通过如下命令：<strong>alter system set log_archive_dest_1=’location=USE_DB_RECOVERY_FILE_DEST’</strong>。</p></li><li><p>如果设置了LOG_ARCHIVE_DEST，就不能设置LOG_ARCHIVE_DEST_n和DB_RECOVERY_FILE_DEST。</p><p>如果设置了LOG_ARCHIVE_DEST_n，就不能设置LOG_ARCHIVE_DEST。</p><p>也就是说，<strong>LOG_ARCHIVE_DEST参数和DB_RECOVERY_FILE_DEST、LOG_ARCHIVE_DEST_n都不共存。而DB_RECOVERY_FILE_DEST和LOG_ARCHIVE_DEST_n可以共存</strong>。</p></li><li><p><strong>LOG_ARCHIVE_DEST只能与LOG_ARCHIVE_DUPLEX_DEST共存</strong>。这样可以设置两个归档路径。LOG_ARCHIVE_DEST设置一个<strong>主归档路径</strong>，LOG_ARCHIVE_DUPLEX_DEST设置一个从归档路径。所有归档路径必须是本地的。</p></li><li><p>如果LOG_ARCHIVE_DEST_n设置的<strong>路径不正确</strong>，那么Oracle<strong>会在设置的上一级目录</strong>归档。比如设置LOG_ARCHIVE_DEST_1=’location=C:\archive1’，而OS中并没有archive1这个目录，那么Oracle会在C盘归档。</p></li></ol><h2 id="归档日志清理"><a href="#归档日志清理" class="headerlink" title="归档日志清理"></a>归档日志清理</h2><ol><li><p>cmd进入oracle的rman模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RMAN&gt; rman target  /</div></pre></td></tr></table></figure></li><li><p>显示所有的日志及日志地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RMAN&gt; list archivelog all;</div></pre></td></tr></table></figure></li><li><p>可以把无效的expired的archivelog标出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RMAN&gt; crosscheck archivelog all;</div></pre></td></tr></table></figure></li><li><p>删除所有的无效日志</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RMAN&gt; delete expired archivelog all;</div></pre></td></tr></table></figure></li><li><p>使用删除语句进行删除：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 其中sysdate-7代表保留近七天的归档日志。</div><div class="line"># 如需保留近十天的，则需将sysdate-7修改为sysdate-10即可。</div><div class="line">RMAN&gt; delete archivelog until time 'sysdate-7';</div></pre></td></tr></table></figure></li><li><p>显示所有的日志及日志地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RMAN&gt; list archivelog all;</div></pre></td></tr></table></figure></li><li><p>查看归档日志文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SQL&gt; select name from v$archived_log;</div><div class="line">或：</div><div class="line">SQL&gt; select substr(t.NAME,1) NAME,ROUND(sum(t.BLOCKS*t.BLOCK_SIZE)/1024/1024) TOTAL_MB from v$archived_log t where t.DELETED='NO' group by substr(t.NAME,1);</div></pre></td></tr></table></figure></li></ol><h2 id="归档日志清理脚本"><a href="#归档日志清理脚本" class="headerlink" title="归档日志清理脚本"></a>归档日志清理脚本</h2><p><strong>clear.bat</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rman target / @&quot;D:\PMSALEX\clear.txt&quot;</div></pre></td></tr></table></figure><p><strong>clear.txt</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete archivelog until time &apos;sysdate-10&apos;;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发总结-并发容器和框架</title>
      <link href="/2019/09/29/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/09/29/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap是<strong>线程安全且高效</strong>的HashMap。</p><h3 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h3><p>在并发编程中使用<strong>HashMap</strong>可能导致<strong>程序死循环</strong>。而使用线程安全的<strong>HashTable效率又非常低下</strong>，基于以上两个原因，便有了ConcurrentHashMap的登场机会。</p><p><strong>（1）线程不安全的HashMap</strong></p><p>在<strong>多线程环境下</strong>，使用<strong>HashMap</strong>进行<strong>put操作</strong>会引起<strong>死循环</strong>，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。例如，执行以下代码会引起死循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">2</span>);</div><div class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">map.put(UUID.randomUUID().toString(), <span class="string">""</span>);</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"ftf"</span> + i).start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;, <span class="string">"ftf"</span>);</div><div class="line">t.start();</div><div class="line">t.join();</div></pre></td></tr></table></figure><p><strong>HashMap</strong>在<strong>并发执行put操作</strong>时会<strong>引起死循环</strong>，是因为多线程会导致<strong>HashMap的Entry</strong>链表<strong>形成环形数据结构</strong>，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p><a id="more"></a><p><strong>（2）效率低下的HashTable</strong></p><p>HashTable容器<strong>使用synchronized来保证线程安全</strong>，但在线程<strong>竞争激烈</strong>的情况下HashTable的<strong>效率非常低下</strong>。<strong>因为</strong>当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><p><strong>（3）ConcurrentHashMap的锁分段技术可有效提升并发访问率</strong></p><p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是<strong>所有访问HashTable的线程都必须竞争同一把锁</strong>，假如<strong>容器里有多把锁</strong>，<strong>每一把锁用于锁容器其中一部分数据</strong>，那么当多线程<strong>访问容器里不同数据段的数据时</strong>，线程间就<strong>不会存在锁竞争</strong>，从而可以<strong>有效提高并发访问效率</strong>，这就是<strong>ConcurrentHashMap</strong>所使用的<strong>锁分段技术</strong>。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><h3 id="容器结构分析"><a href="#容器结构分析" class="headerlink" title="容器结构分析"></a>容器结构分析</h3><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成：</p><ul><li>Segment是一种可重入锁（ReentrantLock），结构和HashMap类似，是一种数组和链表结构，在ConcurrentHashMap里扮演锁的角色，一个ConcurrentHashMap里包含一个Segment数组。</li><li>HashEntry则用于存储键值对数据，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</li></ul><p><img src="/images/并发编程/2019100101.png" alt=""></p><p><img src="/images/并发编程/2019100102.png" alt=""></p><h3 id="容器初始化原理"><a href="#容器初始化原理" class="headerlink" title="容器初始化原理"></a>容器初始化原理</h3><p>ConcurrentHashMap初始化方法是通过<strong>initialCapacity</strong>、<strong>loadFactor</strong>和<strong>concurrencyLevel</strong>等几个参数来<strong>初始化segment数组</strong>、<strong>段偏移量segmentShift</strong>、<strong>段掩码segmentMask</strong>和每个segment里的<strong>HashEntry数组</strong>来实现的。</p><p><strong>（1）初始化segments数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</div><div class="line">concurrencyLevel = MAX_SEGMENTS;</div><div class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</div><div class="line">++sshift;</div><div class="line">ssize &lt;&lt;= <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">segmentShift = <span class="number">32</span> - sshift;</div><div class="line">segmentMask = ssize - <span class="number">1</span>;</div><div class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</div></pre></td></tr></table></figure><p>由源码可知，segments数组的长度ssize是通过concurrencyLevel计算得出的。为了能<strong>通过按位与的散列算法</strong>来<strong>定位segments数组的索引</strong>，<strong>必须保证segments数组的长度是2的N次方</strong>（power-of-two size），所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16。</p><p><strong>注意：</strong>concurrencyLevel的最大值是65535，这意味着segments数组的长度最大为65536，对应的二进制是16位。</p><p><strong>（2）初始化segmentShift和segmentMask</strong></p><p>这两个全局变量需要在定位segment时的散列算法里使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。</p><p><strong>segmentShift用于定位参与散列运算的位数</strong>，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。</p><p><strong>segmentMask是散列运算的掩码</strong>，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p><p><strong>（3）初始化每个segment</strong></p><p>输入参数<strong>initialCapacity是</strong>ConcurrentHashMap的<strong>初始化容量</strong>，<strong>loadfactor是</strong>每个segment的<strong>负载因子</strong>，在构造方法里需要通过这两个参数来初始化数组中的每个segment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">initialCapacity = MAXIMUM_CAPACITY;</div><div class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</div><div class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</div><div class="line">++c;</div><div class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (cap &lt; c)</div><div class="line">cap &lt;&lt;= <span class="number">1</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</div><div class="line"><span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K, V&gt;(cap, loadFactor);</div></pre></td></tr></table></figure><p>上面代码中的<strong>变量cap就是segment里HashEntry数组的长度</strong>，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。</p><p>segment的容量threshold＝（int）cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p><h3 id="如何定位Segment"><a href="#如何定位Segment" class="headerlink" title="如何定位Segment"></a>如何定位Segment</h3><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先<strong>通过散列算法定位到Segment</strong>。可以看到ConcurrentHashMap会首先<strong>使用Wang/Jenkins hash的变种算法</strong>对元素的hashCode<strong>进行一次再散列</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</div><div class="line">h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</div><div class="line">h += (h &lt;&lt; <span class="number">3</span>);</div><div class="line">h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</div><div class="line">h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</div><div class="line"><span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之所以<strong>进行再散列</strong>，<strong>目的是减少散列冲突</strong>，<strong>使元素能够均匀地分布在不同的Segment上</strong>，从而提高容器的存取效率。假如散列的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。</p><p>通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。ConcurrentHashMap通过以下散列算法定位segment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到散列运算中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTest</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">System.out.println(segmentFor(Integer.parseInt(<span class="string">"0001111"</span>, <span class="number">2</span>)));</div><div class="line">System.out.println(segmentFor(Integer.parseInt(<span class="string">"0011111"</span>, <span class="number">2</span>)));</div><div class="line">System.out.println(segmentFor(Integer.parseInt(<span class="string">"0111111"</span>, <span class="number">2</span>)));</div><div class="line">System.out.println(segmentFor(Integer.parseInt(<span class="string">"1111111"</span>, <span class="number">2</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> keyHashCode)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> (hash(keyHashCode) &gt;&gt;&gt; <span class="number">28</span>) &amp; <span class="number">15</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</div><div class="line">h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</div><div class="line">h += (h &lt;&lt; <span class="number">3</span>);</div><div class="line">h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</div><div class="line">h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</div><div class="line"><span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运算结果分别是4、15、7和8，可以看到散列值没有发生冲突。</p><h3 id="get、put、size操作"><a href="#get、put、size操作" class="headerlink" title="get、put、size操作"></a>get、put、size操作</h3><p><strong>（1）get操作</strong></p><p>Segment的get操作实现非常简单和高效。先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> hash = hash(key.hashCode());</div><div class="line"><span class="keyword">return</span> segmentFor(hash).get(key, hash);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>get操作的<strong>高效之处</strong>在于整个<strong>get过程不需要加锁</strong>，除非<strong>读到的值是空才会加锁重读</strong>。</p><p>我们知道<strong>HashTable容器的get方法</strong>是<strong>需要加锁</strong>的，那么<strong>ConcurrentHashMap</strong>的<strong>get操作是如何做到不加锁</strong>的呢？</p><p>原因是它的get方法里将要使用的<strong>共享变量都定义成volatile类型</strong>，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，<strong>能够在线程之间保持可见性</strong>，能够被多线程同时读，并且<strong>保证不会读到过期的值</strong>，但是<strong>只能被单线程写</strong>（<strong>有一种情况可以被多线程写，就是写入的值不依赖于原值</strong>），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是因为根据Java内存模型的<strong>happen before原则</strong>，<strong>对volatile字段的写入操作先于读操作</strong>，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是<strong>用volatile替换锁</strong>的经典应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</div><div class="line"><span class="keyword">volatile</span> V value;</div></pre></td></tr></table></figure><p>在定位元素的代码里我们可以发现，定位HashEntry和定位Segment的散列算法虽然一样，都与数组的长度减去1再相“与”，但是相“与”的值不一样，<strong>定位Segment使用的是元素的hashcode通过再散列后得到的值的高位</strong>，而<strong>定位HashEntry直接使用的是再散列后的值</strong>。其目的是<strong>避免两次散列后的值一样</strong>，虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask <span class="comment">// 定位Segment所使用的hash算法</span></div><div class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); <span class="comment">// 定位HashEntry所使用的hash算法</span></div></pre></td></tr></table></figure><p><strong>（2）put操作</strong></p><p>由于put方法里需要对共享变量进行写入操作，所以<strong>为了线程安全</strong>，在<strong>操作共享变量时必须加锁</strong>。put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤：</p><ul><li>第一步判断是否需要对Segment里的HashEntry数组进行扩容。</li><li>第二步定位添加元素的位置，然后将其放在HashEntry数组里。</li></ul><p><strong>是否需要扩容：</strong>在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阈值，则对数组进行扩容。（Segment的<strong>扩容判断比HashMap更恰当</strong>，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容）</p><p><strong>如何扩容：</strong>在扩容的时候，首先会<strong>创建</strong>一个<strong>容量是原来容量两倍</strong>的<strong>数组</strong>，然后<strong>将原数组里的元素</strong>进行<strong>再散列后插入到新的数组</strong>里。为了高效，<strong>ConcurrentHashMap不会对整个容器进行扩容</strong>，而<strong>只对某个segment进行扩容</strong>。</p><p><strong>（3）size操作</strong></p><p>如果要统计整个ConcurrentHashMap里元素的大小，就<strong>必须统计所有Segment里元素的大小后求和</strong>。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是可能累加前使用的count发生了变化，那么统计结果就不准了。所以，<strong>最安全的做法是在统计size的时候把所有Segment的put、remove和clean方法全部锁住，但是这种做法显然非常低效</strong>。</p><p>因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是<strong>先尝试2次通过不锁住Segment的方式来统计</strong>各个Segment大小，<strong>如果统计的过程中</strong>，<strong>容器的count发生了变化</strong>，则<strong>再采用加锁的方式来统计</strong>所有Segment的大小。</p><p>ConcurrentHashMap<strong>如何判断在统计的时候容器是否发生了变化</strong>：使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>实现一个线程安全的队列有两种方式：</p><ul><li>一种是使用<strong>阻塞算法</strong>。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</li><li>另一种是使用<strong>非阻塞算法</strong>。非阻塞的实现方式则可以使用循环CAS的方式来实现。</li></ul><p><strong>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列</strong>，它<strong>采用先进先出的规则</strong>对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当获取一个元素时，它会返回队列头部的元素。它采用“wait-free”算法（即CAS算法）来实现。</p><h3 id="容器结构分析-1"><a href="#容器结构分析-1" class="headerlink" title="容器结构分析"></a>容器结构分析</h3><p><img src="/images/并发编程/2019100701.png" alt=""></p><p>ConcurrentLinkedQueue由<strong>head节点</strong>和<strong>tail节点</strong>组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//默认情况下head节点存储的元素为空，tail节点等于head节点。</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail = head;</div></pre></td></tr></table></figure><h3 id="入队列剖析"><a href="#入队列剖析" class="headerlink" title="入队列剖析"></a>入队列剖析</h3><p><strong>入队列的过程</strong></p><p><strong>入队列就是将入队节点添加到队列的尾部</strong>。为了方便理解入队时队列的变化，以及head节点和tail节点的变化，这里以一个示例来展开介绍：</p><p><img src="/images/并发编程/2019100702.png" alt=""></p><p>假设我们在一个队列中依次插入4个节点：</p><ol><li>添加元素1。队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。</li><li>添加元素2。队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。</li><li>添加元素3，设置tail节点的next节点为元素3节点。</li><li>添加元素4，设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。</li></ol><p>通过调试入队过程并观察head节点和tail节点的变化，发现<strong>入队主要做两件事情</strong>：</p><ol><li>第一是将入队节点设置成当前队列尾节点的下一个节点；</li><li>第二是更新tail节点：<ul><li>如果tail节点的next节点不为空，则将入队节点设置成tail节点；</li><li>如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点（理解这一点对于我们研究源码会非常有帮助）。</li></ul></li></ol><p>通过对上面的分析，我们从单线程入队的角度理解了入队过程，但是<strong>多个线程同时进行入队</strong>的情况就变得更加复杂了，因为<strong>可能会出现其他线程插队的情况</strong>。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。让我们再<strong>通过源码来详细分析</strong>一下它是<strong>如何使用CAS算法来入队</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line"><span class="comment">// 入队前，创建一个入队节点</span></div><div class="line">Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</div><div class="line">retry:</div><div class="line"><span class="comment">// 死循环，入队不成功反复入队。</span></div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line"><span class="comment">// 创建一个指向tail节点的引用</span></div><div class="line">Node&lt;E&gt; t = tail;</div><div class="line"><span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></div><div class="line">Node&lt;E&gt; p = t;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>;; hops++) &#123;</div><div class="line"><span class="comment">// 获得p节点的下一个节点。</span></div><div class="line">Node&lt;E&gt; next = succ(p);</div><div class="line"><span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></div><div class="line"><span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></div><div class="line"><span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</div><div class="line"><span class="keyword">continue</span> retry;</div><div class="line">p = next;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</div><div class="line"> * 更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点</div><div class="line"> */</div><div class="line"><span class="keyword">if</span> (hops &gt;= HOPS)</div><div class="line">casTail(t, n); <span class="comment">// 更新tail节点，允许失败</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">p = succ(p);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从源代码角度来看，整个<strong>入队</strong>过程<strong>主要做两件事情</strong>：</p><ul><li>第一是<strong>定位出尾节点</strong>；</li><li>第二是使<strong>用CAS算法将入队节点设置成尾节点的next节点</strong>，如<strong>不成功则重试</strong>。</li></ul><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><h3 id="什么是Fork-Join框架"><a href="#什么是Fork-Join框架" class="headerlink" title="什么是Fork/Join框架"></a>什么是Fork/Join框架</h3><p>Fork/Join框架是Java 7提供的一个<strong>用于并行执行任务的框架</strong>，是一个<strong>把大任务分割成若干个小任务</strong>，<strong>最终汇总每个小任务结果后得到大任务结果</strong>的框架。</p><p><strong>Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。</strong>比如计算1+2+…+10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。Fork/Join的运行流程如下：</p><p><img src="/images/并发编程/2019101201.png" alt=""></p><h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p>工作窃取（work-stealing）算法是指<strong>某个线程从其他队列里窃取任务来执行</strong>。</p><p><strong>为什么需要使用工作窃取算法</strong>呢？</p><ol><li>假如我们需要做一个比较大的任务，可以把这个任务<strong>分割为若干互不依赖的子任务</strong>，为了减少线程间的竞争，把这些子任务<strong>分别放到不同的队列里</strong>，并<strong>为每个队列创建一个单独的线程来执行</strong>队列里的任务，线程和队列一一对应。比如A线程负责处理A队列里的任务。</li><li>但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。<strong>干完活的线程</strong>与其等着，不如<strong>去帮其他线程干活</strong>，于是它就<strong>去其他线程的队列里窃取一个任务来执行</strong>。</li><li>而在这时它们会访问同一个队列，所以<strong>为了减少窃取任务线程和被窃取任务线程之间的竞争</strong>，通常会使用双端队列，<strong>被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行</strong>。</li></ol><p>工作窃取的运行流程如下：</p><p><img src="/images/并发编程/2019101202.png" alt=""></p><ul><li>工作窃取算法的<strong>优点</strong>：充分利用线程进行并行计算，减少了线程间的竞争。</li><li>工作窃取算法的<strong>缺点</strong>：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</li></ul><h3 id="Fork-Join框架的设计"><a href="#Fork-Join框架的设计" class="headerlink" title="Fork/Join框架的设计"></a>Fork/Join框架的设计</h3><ol><li><strong>分割任务</strong>。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。</li><li><strong>执行任务并合并结果</strong>。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</li></ol><p>Fork/Join使用两个类来完成以上两件事情：</p><ul><li><p><strong>ForkJoinTask</strong>：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。</p><ul><li>RecursiveAction：用于没有返回结果的任务。</li><li>RecursiveTask：用于有返回结果的任务。</li></ul></li><li><p><strong>ForkJoinPool</strong>：ForkJoinTask需要通过ForkJoinPool来执行。</p><p>任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p></li></ul><h3 id="使用Fork-Join框架"><a href="#使用Fork-Join框架" class="headerlink" title="使用Fork/Join框架"></a>使用Fork/Join框架</h3><p>让我们通过一个简单的需求来使用Fork/Join框架，需求是：计算1+2+3+4的结果。</p><p>使用Fork/Join框架首先要考虑到的是如何分割任务，如果希望每个子任务最多执行两个数的相加，那么我们<strong>设置分割的阈值是2</strong>，由于是4个数字相加，所以Fork/Join框架会把这个任务<strong>fork成两个子任务</strong>，子任务一负责计算1+2，子任务二负责计算3+4，然后再join两个子任务的结果。因为是<strong>有结果的任务</strong>，所以<strong>必须继承RecursiveTask</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;<span class="comment">// 阈值</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> start;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> end;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.start = start;</div><div class="line"><span class="keyword">this</span>.end = end;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line"><span class="comment">// 如果任务足够小就计算任务</span></div><div class="line"><span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</div><div class="line"><span class="keyword">if</span> (canCompute) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</div><div class="line">sum += i;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></div><div class="line"><span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</div><div class="line">CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</div><div class="line">CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</div><div class="line"><span class="comment">// 执行子任务</span></div><div class="line">leftTask.fork();</div><div class="line">rightTask.fork();</div><div class="line"><span class="comment">// 等待子任务执行完，并得到其结果</span></div><div class="line"><span class="keyword">int</span> leftResult = leftTask.join();</div><div class="line"><span class="keyword">int</span> rightResult = rightTask.join();</div><div class="line"><span class="comment">// 合并子任务</span></div><div class="line">sum = leftResult + rightResult;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</div><div class="line"><span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></div><div class="line">CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</div><div class="line"><span class="comment">// 执行一个任务</span></div><div class="line">Future&lt;Integer&gt; result = forkJoinPool.submit(task);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(result.get());</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ForkJoinTask与一般任务的主要区别在于它需要<strong>实现compute方法</strong>：</p><ol><li>首先需要判断任务是否足够小，如果足够小就直接执行任务。</li><li>如果不足够小，就必须分割成两个子任务，每个子任务<strong>在调用fork方法时</strong>，<strong>又会进入compute方法</strong>：看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。</li><li>使用join方法会等待子任务执行完并得到其结果。</li></ol><h3 id="Fork-Join框架的异常处理"><a href="#Fork-Join框架的异常处理" class="headerlink" title="Fork/Join框架的异常处理"></a>Fork/Join框架的异常处理</h3><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们<strong>没办法在主线程里直接捕获异常</strong>，所以ForkJoinTask提供了<strong>isCompletedAbnormally()方法</strong>来<strong>检查任务是否已经抛出异常或已经被取消</strong>了，并且可以通过ForkJoinTask的<strong>getException方法获取异常</strong>。使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(task.isCompletedAbnormally())&#123;</div><div class="line">System.out.println(task.getException());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>getException方法返回Throwable对象：</p><ul><li>如果任务被取消了则返回CancellationException。</li><li>如果任务没有完成或者没有抛出异常则返回null。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发总结-锁</title>
      <link href="/2019/09/20/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E9%94%81/"/>
      <url>/2019/09/20/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h1><p>锁能够<strong>防止多个线程同时访问共享资源</strong>（但是有些锁<strong>可以允许多个线程并发的访问共享资源</strong>，比如<strong>读写锁</strong>）。</p><p>在<strong>Lock</strong>接口出现之前，Java程序是靠<strong>synchronized</strong>关键字实现锁功能的，而<strong>Java SE 5之后</strong>，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字<strong>类似的同步功能</strong>，只是在使用时<strong>需要显式地获取和释放锁</strong>。</p><p>虽然它<strong>缺少了</strong>（通过synchronized块或者方法所提供的）<strong>隐式获取释放锁的便捷性</strong>，但是<strong>却拥有了锁获取与释放的可操作性</strong>、<strong>可中断的获取锁</strong>以及<strong>超时获取锁</strong>等多种synchronized关键字所不具备的同步特性。</p><p>使用<strong>synchronized</strong>关键字将会<strong>隐式地获取锁</strong>，但是它<strong>将锁的获取和释放固化</strong>了，也就是先获取再释放。当然，这种方式简化了同步的管理，可是扩展性没有<strong>显示的锁获取和释放</strong>来的好。</p><p><strong>例如：</strong>手把手进行锁获取和释放，先获得锁A，然后再获取锁B，当锁B获得后，释放锁A同时获取锁C，当锁C获得后，再释放B同时获取锁D，以此类推。这种场景下，<strong>synchronized</strong>关键字就<strong>不那么容易实现</strong>了，而使用<strong>Lock</strong>却<strong>容易许多</strong>。</p><p>Lock的使用的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">lock.lock();</div><div class="line"><span class="comment">//不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//TODO</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="comment">//在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。</span></div><div class="line">lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>Lock接口提供的<strong>synchronized关键字所不具备的</strong>主要特性如下图：</p><p><img src="/images/并发编程/2019092101.png" alt=""></p><p>Lock是一个接口，它定义了<strong>锁获取和释放</strong>的基本操作，Lock的<strong>API</strong>如下：</p><p><img src="/images/并发编程/2019092102.png" alt=""></p><p><strong>lockInterruptibly()中断</strong>情况： </p><ol><li>线程在<strong>请求lock</strong>并<strong>被阻塞时</strong>，如果<strong>被interrupt</strong>，则“此线程会<strong>被唤醒</strong>并被<strong>要求处理InterruptedException</strong>”。</li><li>并且如果线程<strong>已经被interrupt</strong>，<strong>再使用lockInterruptibly</strong>的时候，此线程也会<strong>被要求处理interruptedException</strong>。</li></ol><p>Lock接口的实现基本都是通过<strong>聚合了一个同步器的子类</strong>来<strong>完成线程访问控制</strong>的。</p><h1 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h1><p><strong>队列同步器AbstractQueuedSynchronizer</strong>（以下简称同步器），是<strong>用来构建锁或者其他同步组件的基础框架</strong>，它使用了一个<strong>int成员变量表示同步状态</strong>，通过<strong>内置的FIFO队列</strong>来完成资源获取线程的排队工作，是<strong>实现大部分同步需求的基础</strong>。</p><p>同步器的<strong>主要使用方式是继承</strong>：</p><ul><li>子类通过<strong>继承同步器</strong>并<strong>实现它的抽象方法</strong>来<strong>管理同步状态</strong>，同步器提供3个方法（<strong>getState()</strong>、<strong>setState(int newState)</strong>和<strong>compareAndSetState(int expect,int update)</strong>）来对同步状态进行更改，它们能够保证状态的改变是安全的。</li><li>子类推荐被定义为<strong>自定义同步组件的静态内部类</strong>，同步器自身没有实现任何同步接口，它仅仅是定义了<strong>若干同步状态获取和释放的方法</strong>来供自定义同步组件使用，同步器既可以<strong>支持独占式地获取同步状态</strong>，也可以<strong>支持共享式地获取同步状态</strong>，这样就可以方便实现不同类型的同步组件（<strong>ReentrantLock</strong>、<strong>ReentrantReadWriteLock</strong>和<strong>CountDownLatch</strong>等）。</li></ul><p>同步器是<strong>实现锁</strong>（也可以是任意同步组件）的关键，在<strong>锁的实现中聚合同步器</strong>，利用同步器实现锁的语义。可以这样理解二者之间的关系：</p><ul><li><strong>锁是面向使用者的</strong>，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节。</li><li><strong>同步器面向的是锁的实现者</strong>，它<strong>简化</strong>了<strong>锁的实现方式</strong>，<strong>屏蔽</strong>了同步状态管理、线程的排队、等待与唤醒等<strong>底层操作</strong>。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</li></ul><h2 id="接口与示例"><a href="#接口与示例" class="headerlink" title="接口与示例"></a>接口与示例</h2><p>同步器的设计是基于<strong>模板方法模式</strong>的：</p><ol><li>使用者需要继承同步器并重写指定的方法。</li><li>随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法。</li><li>这些模板方法将会调用使用者重写的方法。</li></ol><p>重写同步器指定的方法时，需要使用同步器提供的如下3个方法来<strong>访问或修改同步状态</strong>：</p><ul><li>getState()：获取当前同步状态。</li><li>setState(int newState)：设置当前同步状态。</li><li>compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。</li></ul><p>同步器<strong>可重写的方法与描述</strong>如下：</p><p><img src="/images/并发编程/2019092103.png" alt=""></p><p>实现自定义同步组件时，将会调用同步器提供的模板方法，这些（部分）<strong>模板方法与描述</strong>如下：</p><p><img src="/images/并发编程/2019092104.png" alt=""></p><p>同步器提供的模板方法基本上分为3类：<strong>独占式获取与释放同步状态</strong>、<strong>共享式获取与释放同步状态</strong>和<strong>查询同步队列中的等待线程情况</strong>。自定义同步组件将使用同步器提供的模板方法来<strong>实现自己的同步语义</strong>。</p><p>下面通过一个独占锁的示例来深入了解同步器的工作原理，独占锁就是在<strong>同一时刻只能有一个线程获取到锁</strong>，而<strong>其他</strong>获取锁的线程只能<strong>处于同步队列中等待</strong>，只有获取锁的线程<strong>释放了锁</strong>，后继的线程<strong>才能够获取锁</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</div><div class="line"><span class="comment">// 静态内部类，自定义同步器</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line"><span class="comment">// 是否处于占用状态</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> getState() == <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 当状态为0的时候获取锁</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">setExclusiveOwnerThread(Thread.currentThread());</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 释放锁，将状态设置为0</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (getState() == <span class="number">0</span>)&#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">&#125;</div><div class="line">setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">setState(<span class="number">0</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></div><div class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; </div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 仅需要将操作代理到Sync上即可</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; sync.release(<span class="number">1</span>); &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">sync.acquireInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"><span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述示例中：</p><ul><li>独占锁Mutex是一个自定义同步组件，它在同一时刻只允许一个线程占有锁。</li><li>Mutex中定义了一个静态内部类，该内部类继承了同步器并实现了独占式获取和释放同步状态：<ul><li>在tryAcquire(int acquires)方法中，如果经过CAS设置成功（同步状态设置为1），则代表获取了同步状态。</li><li>在tryRelease(int releases)方法中只是将同步状态重置为0。</li></ul></li><li>用户使用Mutex时并不会直接和内部同步器的实现打交道，而是调用Mutex提供的方法。在Mutex的实现中，以获取锁的lock()方法为例，只需要在方法实现中调用同步器的模板方法acquire(int args)即可，当前线程调用该方法获取同步状态失败后会被加入到同步队列中等待，这样大大降低了实现一个可靠自定义同步组件的门槛。</li></ul><h1 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h1><p>重入锁ReentrantLock，就是<strong>支持重进入的锁</strong>，表示该锁能够<strong>支持一个线程对资源的重复加锁</strong>。除此之外，该锁的<strong>还支持获取锁时的公平和非公平性选择</strong>。</p><p><strong>可重入性：</strong></p><ul><li>回忆在同步器一节中的示例（Mutex），同时考虑如下场景：当一个线程调用Mutex的lock()方法获取锁之后，如果再次调用lock()方法，则该线程将会被自己所阻塞，原因是Mutex在实现tryAcquire(int acquires)方法时没有考虑占有锁的线程再次获取锁的场景，而在调用tryAcquire(int acquires)方法时返回了false，导致该线程被阻塞。</li><li>简单地说，Mutex是一个不支持重进入的锁。而<strong>synchronized关键字隐式的支持重进入</strong>，比如一个<strong>synchronized修饰的递归方法</strong>，在方法执行时，执行线程在<strong>获取了锁之后仍能连续多次地获得该锁</strong>，而不像Mutex由于获取了锁，而在下一次获取锁时出现阻塞自己的情况。</li><li><strong>ReentrantLock</strong>虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</li></ul><p><strong>公平性：</strong></p><ul><li>这里提到一个锁获取的公平性问题，如果<strong>在绝对时间上</strong>，<strong>先对锁进行获取的请求一定先被满足</strong>，那么这个<strong>锁是公平的</strong>，反之，是不公平的。公平的获取锁，也就是<strong>等待时间最长的线程最优先获取锁</strong>，也可以说<strong>锁获取是顺序的</strong>。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。</li><li>事实上，<strong>公平的锁机制往往没有非公平的效率高</strong>，<strong>但是</strong>，并不是任何场景都是以TPS作为唯一的指标，<strong>公平锁能够减少“饥饿”发生的概率</strong>，等待越久的请求越是能够得到优先满足。</li></ul><p>下面将着重分析<strong>ReentrantLock</strong>是<strong>如何实现重进入和公平性获取锁</strong>的特性。</p><h2 id="实现重进入"><a href="#实现重进入" class="headerlink" title="实现重进入"></a>实现重进入</h2><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的<strong>实现需要解决以下两个问题</strong>。</p><ol><li>线程再次获取锁。锁需要去<strong>识别获取锁的线程是否为当前占据锁的线程</strong>，如果是，则再次成功获取。</li><li>锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求<strong>锁对于获取进行计数自增</strong>，计数表示当前锁被重复获取的次数，而<strong>锁被释放时，计数自减</strong>，当<strong>计数等于0时</strong>表示锁已经<strong>成功释放</strong>。</li></ol><p>ReentrantLock是通过<strong>组合自定义同步器</strong>来实现锁的获取与释放，以非公平性（默认的）实现为例，<strong>获取同步状态的代码</strong>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line"><span class="keyword">int</span> c = getState();</div><div class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">setExclusiveOwnerThread(current);</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line"><span class="keyword">int</span> nextc = c + acquires;</div><div class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)&#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">&#125;</div><div class="line">setState(nextc);</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。</p><p>成功获取锁的线程<strong>再次获取锁</strong>，只是<strong>增加了同步状态值</strong>，这也就要求ReentrantLock在<strong>释放同步状态时减少同步状态值</strong>，该方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> c = getState() - releases;</div><div class="line"><span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())&#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">&#125;</div><div class="line"><span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">free = <span class="keyword">true</span>;</div><div class="line">setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line">setState(c);</div><div class="line"><span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果该<strong>锁被获取了n次</strong>，那么<strong>前(n-1)次tryRelease(int releases)方法必须返回false</strong>，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当<strong>同步状态为0时</strong>，<strong>将占有线程设置为null</strong>，并<strong>返回true</strong>，表示<strong>释放成功</strong>。</p><h2 id="公与非公平锁"><a href="#公与非公平锁" class="headerlink" title="公与非公平锁"></a>公与非公平锁</h2><p>公平性与否是针<strong>对获取锁而言</strong>的，如果一个<strong>锁是公平的</strong>，那么<strong>锁的获取顺序</strong>就应该<strong>符合请求的绝对时间顺序</strong>，也就是<strong>FIFO</strong>。</p><p>回顾上一小节中介绍的<strong>nonfairTryAcquire(int acquires)</strong>方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line"><span class="keyword">int</span> c = getState();</div><div class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">setExclusiveOwnerThread(current);</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line"><span class="keyword">int</span> nextc = c + acquires;</div><div class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)&#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">&#125;</div><div class="line">setState(nextc);</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该方法与nonfairTryAcquire(int acquires)比较，<strong>唯一不同</strong>的位置为判断条件多了<strong>hasQueuedPredecessors()</strong>方法，即<strong>加入了同步队列中当前节点是否有前驱节点的判断</strong>，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p><p><strong>公平性锁</strong>保证了锁的获取按照<strong>FIFO原则</strong>，而<strong>代价是</strong>进行<strong>大量的线程切换</strong>。<strong>非公平性锁</strong>虽然可能造成线程“饥饿”，但刚释放锁的线程再次获同步状态的几率会非常大，<strong>极少的线程切换</strong>，保证了其<strong>更大的吞吐量</strong>。</p><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p>之前提到锁（如Mutex和ReentrantLock）基本都是<strong>排他锁</strong>，这些锁在<strong>同一时刻只允许一个线程进行访问</strong>，而<strong>读写锁</strong>在<strong>同一时刻可以允许多个读线程访问</strong>。但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p><p><strong>使用场景：</strong></p><ul><li>保证写操作对读操作的可见性以及并发性的提升之外。</li><li>简化读写交互场景的编程方式：假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。</li></ul><p><strong>优点比较：</strong></p><ul><li>在没有读写锁支持的（Java 5之前）时候，如果需要完成上述工作就要使用Java的<strong>等待通知机制</strong>：当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。</li><li>改用读写锁实现上述功能：只需要在读操作时获取读锁，写操作时获取写锁即可。当<strong>写锁被获取</strong>到时，后续（非当前写操作线程）的<strong>读写操作都会被阻塞</strong>，<strong>写锁释放</strong>之后，<strong>所有操作继续执行</strong>，编程方式相对于使用<strong>等待通知机制</strong>的实现方式而言简单明了。</li></ul><p>在<strong>读多于写</strong>的情况下，读写锁的性能都会比排它锁好，读写锁能够提供比排它锁<strong>更好的并发性和吞吐量</strong>。Java并发包提供读写锁的实现是<strong>ReentrantReadWriteLock</strong>，它提供的特性如下：</p><p><img src="/images/并发编程/2019092701.png" alt=""></p><h2 id="接口与示例-1"><a href="#接口与示例-1" class="headerlink" title="接口与示例"></a>接口与示例</h2><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，即<strong>readLock()</strong>方法和<strong>writeLock()</strong>方法，而其实现<strong>ReentrantReadWriteLock</strong>，除了接口方法之外，还提供了一些<strong>便于外界监控其内部工作状态的方法</strong>，这些方法以及描述；如下：</p><p><img src="/images/并发编程/2019092702.png" alt=""></p><p>接下来，通过一个<strong>缓存示例</strong>说明读写锁的使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line"><span class="keyword">static</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line"><span class="keyword">static</span> Lock r = rwl.readLock();</div><div class="line"><span class="keyword">static</span> Lock w = rwl.writeLock();</div><div class="line"></div><div class="line"><span class="comment">// 获取一个key对应的value</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">r.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">return</span> map.get(key);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">r.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 设置key对应的value，并返回旧的value</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</div><div class="line">w.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">return</span> map.put(key, value);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">w.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 清空所有的内容</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">w.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">map.clear();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">w.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<strong>读操作</strong>get(String key)方法中，需要<strong>获取读锁</strong>，这使得<strong>并发访问该方法</strong>时<strong>不会被阻塞</strong>。</p><p><strong>写操作</strong>put(String key,Object value)方法和clear()方法，在更新HashMap时<strong>必须提前获取写锁</strong>，当<strong>获取写锁后</strong>，<strong>其他线程</strong>对于<strong>读锁和写锁的获取均被阻塞</strong>，而只有<strong>写锁被释放</strong>之后，<strong>其他读写操作才能继续</strong>。</p><p>Cache使用读写锁<strong>提升读操作的并发性</strong>，也保证每次<strong>写操作对所有的读写操作的可见性</strong>，同时简化了编程方式。</p><h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>接下来分析<strong>ReentrantReadWriteLock</strong>的实现，主要包括：<strong>读写状态的设计</strong>、<strong>写锁的获取与释放</strong>、<strong>读锁的获取与释放</strong>以及<strong>锁降级</strong>。</p><h3 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h3><p>读写锁同样依赖自定义同步器来实现同步功能，而<strong>读写状态就是其同步器的同步状态</strong>。回想<strong>ReentrantLock</strong>中自定义同步器的实现，<strong>同步状态</strong>表示<strong>锁被一个线程重复获取的次数</strong>，而读写锁的自定义同步器需要<strong>在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态</strong>，使得该状态的设计成为读写锁实现的关键。</p><p>如果在一个整型变量上维护多种状态，就一定需要<strong>“按位切割使用”</strong>这个变量，读写锁将变量切分成了两个部分，<strong>高16位表示读</strong>，<strong>低16位表示写</strong>，划分方式如下：</p><p><img src="/images/并发编程/2019092703.png" alt=""></p><p>当前同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。读写锁是如何迅速确定读和写各自的状态呢？</p><p>答案是通过位运算。假设当前同步状态值为S，<strong>写状态等于S&amp;0x0000FFFF（将高16位全部抹去）</strong>，<strong>读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）</strong>。当<strong>写状态增加1时</strong>，<strong>等于S+1</strong>，当<strong>读状态增加1时</strong>，<strong>等于S+(1&lt;&lt;16)</strong>，也就是S+0x00010000。</p><p>根据状态的划分能得出一个<strong>推论</strong>：S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</p><h3 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h3><p><strong>写锁是一个支持重进入的排它锁</strong>：</p><ul><li>如果当前线程已经<strong>获取了写锁</strong>，则<strong>增加写状态</strong>。</li><li>如果当前线程在<strong>获取写锁时</strong>，<strong>读锁已经被获取</strong>（读状态不为0）<strong>或者该线程不是已经获取写锁的线程</strong>，则当前线程<strong>进入等待状态</strong>。</li></ul><p>获取写锁的代码如下<strong>ReentrantReadWriteLock</strong>的<strong>tryAcquire</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">Thread current = Thread.currentThread();</div><div class="line"><span class="keyword">int</span> c = getState();</div><div class="line"><span class="keyword">int</span> w = exclusiveCount(c);</div><div class="line"><span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</div><div class="line"><span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></div><div class="line"><span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">setState(c + acquires);</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">setExclusiveOwnerThread(current);</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。<strong>如果存在读锁，则写锁不能被获取</strong>，<strong>原因</strong>在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程<strong>都释放了读锁</strong>，<strong>写锁才能被当前线程获取</strong>，而<strong>写锁一旦被获取</strong>，则<strong>其他读写线程的后续访问均被阻塞</strong>。</p><p>写锁的释放与ReentrantLock的释放过程基本类似，<strong>每次释放均减少写状态</strong>，当<strong>写状态为0时表示写锁已被释放</strong>，从而<strong>等待的读写线程能够继续访问读写锁</strong>，同时<strong>前次写线程的修改对后续读写线程可见</strong>。</p><h3 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h3><p><strong>读锁是一个支持重进入的共享锁</strong>：</p><ul><li>它<strong>能够被多个线程同时获取</strong>，在没<strong>有其他写线程访问</strong>（或者写状态为0）时，<strong>读锁总会被成功地获取</strong>，而所做的也只是<strong>（线程安全的）增加读状态</strong>。</li><li>如果当前线程<strong>已经获取了读锁</strong>，则<strong>增加读状态</strong>。</li><li>如果当前线程在<strong>获取读锁时</strong>，<strong>写锁已被其他线程获取</strong>，则<strong>进入等待状态</strong>。</li></ul><p>获取读锁的实现从Java 5到Java 6变得<strong>复杂</strong>许多，主要原因是新增了一些功能，例如<strong>getReadHoldCount()</strong>方法，作用是<strong>返回当前线程获取读锁的次数</strong>。<strong>读状态是所有线程获取读锁次数的总和</strong>，而每个<strong>线程各自获取读锁的次数</strong>只能选择<strong>保存在ThreadLocal中</strong>，由线程自身维护，这使获取读锁的实现变得复杂。因此，这里将获取读锁的代码做了删减，保留必要的部分，如下ReentrantReadWriteLock的tryAcquireShared方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line"><span class="keyword">int</span> c = getState();</div><div class="line"><span class="keyword">int</span> nextc = c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</div><div class="line"><span class="keyword">if</span> (nextc &lt; c)</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"><span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</div><div class="line"><span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"><span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<strong>tryAcquireShared(int unused)</strong>方法中：</p><ul><li>如果<strong>其他线程</strong>已经<strong>获取了写锁</strong>，则当<strong>前线程获取读锁失败</strong>，<strong>进入等待状态</strong>。</li><li>如果<strong>当前线程获取了写锁</strong>或者<strong>写锁未被获取</strong>，则当前线程（线程安全，依靠CAS保证）<strong>增加读状态</strong>，<strong>成功获取读锁</strong>。</li><li><strong>读锁的每次释放</strong>（<strong>线程安全</strong>的，可能有多个读线程同时释放读锁）<strong>均减少读状态</strong>，<strong>减少的值是（1&lt;&lt;16）</strong>。</li></ul><h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p><strong>锁降级指的是写锁降级成为读锁</strong>：</p><ul><li>如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种<strong>分段完成</strong>的过程不能称之为锁降级。</li><li>锁降级是指<strong>把持住（当前拥有的）写锁</strong>，<strong>再获取到读锁</strong>，<strong>随后释放（先前拥有的）写锁</strong>的过程。</li></ul><p>接下来看一个锁降级的示例。因为数据不常变化，多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</div><div class="line">readLock.lock();</div><div class="line"><span class="keyword">if</span> (!update) &#123;</div><div class="line"><span class="comment">// 必须先释放读锁</span></div><div class="line">readLock.unlock();</div><div class="line"><span class="comment">// 锁降级从写锁获取到开始</span></div><div class="line">writeLock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">if</span> (!update) &#123;</div><div class="line"><span class="comment">// 准备数据的流程（略）</span></div><div class="line">update = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line">readLock.lock();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">writeLock.unlock();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 锁降级完成，写锁降级为读锁</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">// 使用数据的流程（略）</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">readLock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述示例中，当数据发生变更后，<strong>update变量（布尔类型且volatile修饰）</strong>被设置为false，此时所有访问processData()方法的<strong>线程都能够感知到变化</strong>，但<strong>只有一个线程能够获取到写锁</strong>，<strong>其他线程会被阻塞在读锁和写锁的lock()方法上</strong>。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。</p><p><strong>锁降级中读锁的获取是否必要呢</strong>？答案是必要的。主要是为了<strong>保证数据的可见性</strong>：</p><ul><li>如果<strong>当前线程不获取读锁</strong>而是<strong>直接释放写锁</strong>，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程<strong>无法感知</strong>线程T的<strong>数据更新</strong>。</li><li>如果<strong>当前线程获取读锁</strong>，即遵循锁降级的步骤，则<strong>线程T将会被阻塞</strong>，直到<strong>当前线程使用数据并释放读锁</strong>之后，<strong>线程T才能获取写锁</strong>进行数据更新。</li></ul><p><strong>RentrantReadWriteLock不支持锁升级</strong>（把持读锁、获取写锁，最后释放读锁的过程）。目的也是<strong>保证数据可见性</strong>，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p><h1 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h1><p>任意一个Java对象，都拥有<strong>一组监视器方法</strong>（定义在java.lang.Object上），主要包括<strong>wait()、wait(long timeout)、notify()以及notifyAll()方法</strong>，这些方法<strong>与synchronized同步关键字配合</strong>，可以<strong>实现等待/通知模式</strong>。<strong>Condition接口</strong>也提供了类似Object的监视器方法，<strong>与Lock配合</strong>可以<strong>实现等待/通知模式</strong>，但是这两者在使用方式以及功能特性上还是有差别的。</p><p>通过对比Object的监视器方法和Condition接口，可以更详细地了解Condition的特性，对比项与结果如下：</p><p><img src="/images/并发编程/2019092704.png" alt=""></p><h2 id="接口与示例-2"><a href="#接口与示例-2" class="headerlink" title="接口与示例"></a>接口与示例</h2><p>Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要<strong>提前获取到Condition对象关联的锁</strong>。Condition对象是由Lock对象（<strong>调用Lock对象的newCondition()方法</strong>）创建出来的，换句话说，Condition是依赖Lock对象的。</p><p>Condition的使用方式比较简单，需要注意<strong>在调用方法前获取锁</strong>，使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionUseCase</span> </span>&#123;</div><div class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">Condition condition = lock.newCondition();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">condition.await();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">condition.signal();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如示例所示，一般都会将Condition对象作为成员变量。当<strong>调用await()方法</strong>后，当前线程会<strong>释放锁并在此等待</strong>，而其他线程调用Condition对象的<strong>signal()方法</strong>，通知当前线程后，当前线程才<strong>从await()方法返回</strong>，并且<strong>在返回前已经获取了锁</strong>。</p><p>Condition定义的（部分）方法以及描述如下：</p><p><img src="/images/并发编程/2019092901.png" alt=""></p><p>获取一个Condition必须通过Lock的newCondition()方法。下面通过一个<strong>有界队列</strong>的示例来深入了解Condition的使用方式。<strong>有界队列</strong>是一种特殊的队列，当<strong>队列为空</strong>时，队列的<strong>获取操作将会阻塞</strong>获取线程，直到队列中有新增元素，当<strong>队列已满</strong>时，队列的<strong>插入操作将会阻塞</strong>插入线程，直到队列出现“空位”，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"><span class="keyword">private</span> Object[] items;</div><div class="line"><span class="comment">// 添加的下标，删除的下标和数组当前数量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> addIndex, removeIndex, count;</div><div class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">private</span> Condition notEmpty = lock.newCondition();</div><div class="line"><span class="keyword">private</span> Condition notFull = lock.newCondition();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BoundedQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">items = <span class="keyword">new</span> Object[size];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 添加一个元素，如果数组满，则添加线程进入等待状态，直到有"空位"</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">while</span> (count == items.length)</div><div class="line">notFull.await();</div><div class="line">items[addIndex] = t;</div><div class="line"><span class="keyword">if</span> (++addIndex == items.length)</div><div class="line">addIndex = <span class="number">0</span>;</div><div class="line">++count;</div><div class="line">notEmpty.signal();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">notEmpty.await();</div><div class="line">Object x = items[removeIndex];</div><div class="line"><span class="keyword">if</span> (++removeIndex == items.length)</div><div class="line">removeIndex = <span class="number">0</span>;</div><div class="line">--count;</div><div class="line">notFull.signal();</div><div class="line"><span class="keyword">return</span> (T) x;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述示例中，<strong>首先需要获得锁</strong>，目的是确保数组修改的<strong>可见性和排他性</strong>。在添加和删除方法中使用while循环而非if判断，目的是<strong>防止过早或意外的通知</strong>，只有条件符合才能够退出循环。与之前提到的<strong>等待/通知的经典范式</strong>，二者非常类似。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发总结-线程应用实例</title>
      <link href="/2019/09/19/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/09/19/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a>等待超时模式</h2><p><strong>使用场景</strong>：调用一个方法时等待一段时间（一般来说是给定一个时间段），如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。</p><p>前面的章节介绍了<strong>等待/通知的经典范式</strong>，即<strong>加锁</strong>、<strong>条件循环</strong>和<strong>处理逻辑</strong>3个步骤，而这种范式<strong>无法做到超时等待</strong>。而超时等待的加入，只需要对经典范式做出非常小的改动，改动内容如下所示：</p><p>假设<strong>超时时间段是T</strong>，那么可以推断出在当前时间<strong>now+T之后就会超时</strong>。</p><p>定义如下变量：</p><ul><li>等待持续时间：<strong>REMAINING</strong>=T。</li><li>超时时间：<strong>FUTURE</strong>=now+T。</li></ul><p>这时仅需要<strong>wait(REMAINING)</strong>即可，在<strong>wait(REMAINING)</strong>返回之后会将执行：<strong>REMAINING=FUTURE–now</strong>。如果<strong>REMAINING</strong>小于等于0，表示已经超时，直接退出，否则将继续执行<strong>wait(REMAINING)</strong>。</p><a id="more"></a><p>上述等待超时模式的<strong>伪代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对当前对象加锁</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"><span class="keyword">long</span> future = System.currentTimeMillis() + mills;</div><div class="line"><span class="keyword">long</span> remaining = mills;</div><div class="line"><span class="comment">// 当超时大于0并且result返回值不满足要求</span></div><div class="line"><span class="keyword">while</span> ((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</div><div class="line">wait(remaining);</div><div class="line">remaining = future - System.currentTimeMillis();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>等待超时模式就是在<strong>等待/通知范式</strong>基础上增加了<strong>超时控制</strong>，这使得该模式相比原有范式更具有灵活性，因为即使方法执行时间过长，也不会“永久”阻塞调用者，而是会按照调用者的要求“按时”返回。</p><h2 id="数据库连接池示例"><a href="#数据库连接池示例" class="headerlink" title="数据库连接池示例"></a>数据库连接池示例</h2><p>我们使用<strong>等待超时模式</strong>来构造一个简单的数据库连接池，在示例中模拟从连接池中<strong>获取</strong>、<strong>使用</strong>和<strong>释放</strong>连接的过程，而客户端获取连接的过程被设定为<strong>等待超时的模式</strong>，也就是在1000毫秒内如果无法获取到可用连接，将会返回给客户端一个null。设定连接池的大小为10个，然后通过调节客户端的线程数来模拟无法获取连接的场景。</p><p><strong>首先</strong>看一下连接池的定义。它通过构造函数初始化连接的最大上限，通过一个<strong>双向队列</strong>来维护连接，调用方需要先调用<strong>fetchConnection(long)</strong>方法来指定在多少毫秒内超时获取连接，当连接使用完成后，需要调用<strong>releaseConnection(Connection)</strong>方法将连接放回线程池，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</div><div class="line">pool.addLast(ConnectionDriver.createConnection());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">synchronized</span> (pool) &#123;</div><div class="line"><span class="comment">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span></div><div class="line">pool.addLast(connection);</div><div class="line">pool.notifyAll();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在mills内无法获取到连接，将会返回null</span></div><div class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (pool) &#123;</div><div class="line"><span class="comment">// 完全超时</span></div><div class="line"><span class="keyword">if</span> (mills &lt;= <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">while</span> (pool.isEmpty()) &#123;</div><div class="line">pool.wait();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> pool.removeFirst();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">long</span> future = System.currentTimeMillis() + mills;</div><div class="line"><span class="keyword">long</span> remaining = mills;</div><div class="line"><span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</div><div class="line">pool.wait(remaining);</div><div class="line">remaining = future - System.currentTimeMillis();</div><div class="line">&#125;</div><div class="line">Connection result = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span> (!pool.isEmpty()) &#123;</div><div class="line">result = pool.removeFirst();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于<strong>java.sql.Connection</strong>是一个接口，最终的实现是由数据库驱动提供方来实现的，考虑到只是个示例，我们通过动态代理构造了一个Connection，该Connection的代理实现仅仅是在commit()方法调用时休眠100毫秒，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionDriver</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line"><span class="keyword">throws</span> Throwable &#123;</div><div class="line"><span class="keyword">if</span> (method.getName().equals(<span class="string">"commit"</span>)) &#123;</div><div class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个Connection的代理，在commit时休眠100毫秒</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Connection <span class="title">createConnection</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;Connection.class&#125;, <span class="keyword">new</span> ConnectionHandler());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面通过一个示例来测试简易数据库连接池的工作情况，模拟客户端ConnectionRunner<strong>获取</strong>、<strong>使用</strong>、最后<strong>释放</strong>连接的过程，当它使用时连接将会增加获取到连接的数量，反之，将会增加未获取到连接的数量，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPoolTest</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> ConnectionPool pool = <span class="keyword">new</span> ConnectionPool(<span class="number">10</span>);</div><div class="line"><span class="comment">// 保证所有ConnectionRunner能够同时开始</span></div><div class="line"><span class="keyword">static</span> CountDownLatch start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"><span class="comment">// main线程将会等待所有ConnectionRunner结束后才能继续执行</span></div><div class="line"><span class="keyword">static</span> CountDownLatch end;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"><span class="comment">// 线程数量，可以修改线程数量进行观察</span></div><div class="line"><span class="keyword">int</span> threadCount = <span class="number">10</span>;</div><div class="line">end = <span class="keyword">new</span> CountDownLatch(threadCount);</div><div class="line"><span class="keyword">int</span> count = <span class="number">20</span>;</div><div class="line">AtomicInteger got = <span class="keyword">new</span> AtomicInteger();</div><div class="line">AtomicInteger notGot = <span class="keyword">new</span> AtomicInteger();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</div><div class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConnetionRunner(count, got, notGot),</div><div class="line"><span class="string">"ConnectionRunnerThread"</span>);</div><div class="line">thread.start();</div><div class="line">&#125;</div><div class="line">start.countDown();</div><div class="line">end.await();</div><div class="line">System.out.println(<span class="string">"total invoke: "</span> + (threadCount * count));</div><div class="line">System.out.println(<span class="string">"got connection: "</span> + got);</div><div class="line">System.out.println(<span class="string">"not got connection "</span> + notGot);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnetionRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> count;</div><div class="line">AtomicInteger got;</div><div class="line">AtomicInteger notGot;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConnetionRunner</span><span class="params">(<span class="keyword">int</span> count, AtomicInteger got,</span></span></div><div class="line">AtomicInteger notGot) &#123;</div><div class="line"><span class="keyword">this</span>.count = count;</div><div class="line"><span class="keyword">this</span>.got = got;</div><div class="line"><span class="keyword">this</span>.notGot = notGot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">start.await();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">// 从线程池中获取连接，如果1000ms内无法获取到，将会返回null</span></div><div class="line"><span class="comment">// 分别统计连接获取的数量got和未获取到的数量notGot</span></div><div class="line">Connection connection = pool.fetchConnection(<span class="number">1000</span>);</div><div class="line"><span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">connection.createStatement();</div><div class="line">connection.commit();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">pool.releaseConnection(connection);</div><div class="line">got.incrementAndGet();</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">notGot.incrementAndGet();</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">count--;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">end.countDown();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述示例中使用了<strong>CountDownLatch</strong>来确保ConnectionRunnerThread能够<strong>同时开始执行</strong>，并且在全部结束之后，才使main线程从等待状态中返回。</p><p>当前设定的场景是10个线程同时运行获取连接池（10个连接）中的连接，通过调节线程数量来观察未获取到连接的情况：线程数、总获取次数、获取到的数量、未获取到的数量以及未获取到的比率（实际输出可能与此表不同）。</p><p><img src="/images/并发编程/2019091903.png" alt=""></p><p>从表中的数据统计可以看出，在<strong>资源一定</strong>的情况下（连接池中的10个连接），随着<strong>客户端线程的逐步增加</strong>，客户端出现超时<strong>无法获取连接的比率不断升高</strong>。虽然客户端线程在这种超时获取的模式下<strong>会出现连接无法获取的情况</strong>，<strong>但是</strong>它能够保证客户端线程<strong>不会一直挂在连接获取的操作</strong>上，而是<strong>“按时”返回</strong>，并告知客户端连接获取出现问题，是系统的一种<strong>自我保护机制</strong>。数据库连接池的设计也可以<strong>复用到其他的资源获取</strong>的场景，针对<strong>昂贵资源</strong>（比如<strong>数据库连接</strong>）的获取都应该加以超时限制。</p><h2 id="线程池技术及示例"><a href="#线程池技术及示例" class="headerlink" title="线程池技术及示例"></a>线程池技术及示例</h2><p><strong>应用场景：</strong></p><p>对于服务端的程序，经常面对的是客户端传入的短小（<strong>执行时间短</strong>、<strong>工作内容较为单一</strong>）任务，需要服务端<strong>快速处理并返回结果</strong>。如果服务端每次接受到一个任务，创建一个线程，然后进行执行，这在原型阶段是个不错的选择。</p><p>但是面对<strong>成千上万的任务</strong>递交进服务器时，如果还是采用一个任务一个线程的方式，那么将会创建数以万记的线程，这会使操作系统<strong>频繁的进行线程上下文切换</strong>，无故<strong>增加系统的负载</strong>，而<strong>线程的创建和消亡</strong>都是需要耗费系统资源的，也无疑<strong>浪费了系统资源</strong>。</p><p><strong>解决方案：</strong></p><p>线程池技术能够很好地解决这个问题，它<strong>预先创建了若干数量的线程</strong>，并且不能由用户直接对线程的创建进行控制，在这个前提下<strong>重复使用固定或较为固定数目的线程</strong>来完成任务的执行。</p><p>这样做的好处是，一方面，<strong>消除</strong>了频繁创建和消亡线程的<strong>系统资源开销</strong>，另一方面，面对<strong>过量任务</strong>的提交能够<strong>平缓</strong>的劣化。</p><p>先看一个简单的线程池接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</div><div class="line"><span class="comment">// 执行一个Job，这个Job需要实现Runnable</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</div><div class="line"><span class="comment">// 关闭线程池</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">// 增加工作者线程</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</div><div class="line"><span class="comment">// 减少工作者线程</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</div><div class="line"><span class="comment">// 得到正在等待执行的任务数量</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>客户端可以通过<strong>execute(Job)</strong>方法<strong>将Job提交入线程池执行</strong>，而客户端自身<strong>不用等待Job的执行完成</strong>。除了execute(Job)方法以外，线程池接口提供了<strong>增大/减少工作者线程</strong>以及<strong>关闭线程池的方法</strong>。这里工作者线程代表着<strong>一个重复执行Job的线程</strong>，而每个由客户端提交的Job都将<strong>进入到一个工作队列</strong>中等待工作者线程的处理。</p><p>以下是线程池接口的默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</div><div class="line"><span class="comment">// 线程池最大限制数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS = <span class="number">10</span>;</div><div class="line"><span class="comment">// 线程池默认的数量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</div><div class="line"><span class="comment">// 线程池最小的数量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</div><div class="line"><span class="comment">// 这是一个工作列表，将会向里面插入工作</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;Job&gt;();</div><div class="line"><span class="comment">// 工作者列表</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections</div><div class="line">.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());</div><div class="line"><span class="comment">// 工作者线程的数量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</div><div class="line"><span class="comment">// 线程编号生成</span></div><div class="line"><span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">initializeWokers(DEFAULT_WORKER_NUMBERS);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS</div><div class="line">: num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;</div><div class="line">initializeWokers(workerNum);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="comment">// 添加一个工作，然后进行通知</span></div><div class="line"><span class="keyword">synchronized</span> (jobs) &#123;</div><div class="line">jobs.addLast(job);</div><div class="line">jobs.notify();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (Worker worker : workers) &#123;</div><div class="line">worker.shutdown();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (jobs) &#123;</div><div class="line"><span class="comment">// 限制新增的Worker数量不能超过最大值</span></div><div class="line"><span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</div><div class="line">num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</div><div class="line">&#125;</div><div class="line">initializeWokers(num);</div><div class="line"><span class="keyword">this</span>.workerNum += num;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (jobs) &#123;</div><div class="line"><span class="keyword">if</span> (num &gt;= <span class="keyword">this</span>.workerNum) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 按照给定的数量停止Worker</span></div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (count &lt; num) &#123;</div><div class="line">Worker worker = workers.get(count);</div><div class="line"><span class="keyword">if</span> (workers.remove(worker)) &#123;</div><div class="line">worker.shutdown();</div><div class="line">count++;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>.workerNum -= count;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> jobs.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化线程工作者</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWokers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</div><div class="line">Worker worker = <span class="keyword">new</span> Worker();</div><div class="line">workers.add(worker);</div><div class="line">Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">"ThreadPool-Worker-"</span></div><div class="line">+ threadNum.incrementAndGet());</div><div class="line">thread.start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 工作者，负责消费任务</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="comment">// 是否工作</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span> (running) &#123;</div><div class="line">Job job = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">synchronized</span> (jobs) &#123;</div><div class="line"><span class="comment">// 如果工作者列表是空的，那么就wait</span></div><div class="line"><span class="keyword">while</span> (jobs.isEmpty()) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">jobs.wait();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line"><span class="comment">// 感知到外部对WorkerThread的中断操作，返回</span></div><div class="line">Thread.currentThread().interrupt();</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 取出一个Job</span></div><div class="line">job = jobs.removeFirst();</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">job.run();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line"><span class="comment">// 忽略Job执行中的Exception</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">running = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当客户端调用execute(Job)方法时，会不断地向任务列表jobs中添加Job，而每个工作者线程会<strong>不断地</strong>从jobs上<strong>取出一个Job进行执行</strong>，当<strong>jobs为空时</strong>，<strong>工作者线程进入等待状态</strong>。</p><p>添加一个Job后，对工作队列jobs调用了其notify()方法，而不是notifyAll()方法，因为能够确定有工作者线程被唤醒，这时使用<strong>notify()</strong>方法将会<strong>比notifyAll()</strong>方法获得<strong>更小的开销</strong>（<strong>避免将等待队列中的线程全部移动到阻塞队列中</strong>）。</p><p><strong>线程池的本质</strong>就是使用了<strong>一个线程安全的工作队列</strong>连接<strong>工作者线程</strong>和<strong>客户端线程</strong>，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作队列上取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者线程，随着大量的任务被提交，更多的工作者线程会被唤醒。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发总结-线程间通信</title>
      <link href="/2019/09/17/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/09/17/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h2><p><strong>volatile</strong>和<strong>synchronized</strong></p><p>关键字<strong>volatile</strong>可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从<strong>共享内存</strong>中获取，而对它的改变<strong>必须同步刷新回共享内存</strong>，它能保证所有线程对变量访问的<strong>可见性</strong>。但是不必过多使用<strong>volatile</strong>，因为它会<strong>降低程序执行的效率</strong>。</p><p>关键字<strong>synchronized</strong>可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的<strong>可见性</strong>和<strong>排他性</strong>。</p><p>如下使用了同步块和同步方法，通过使用<strong>javap</strong>工具查看生成的<strong>class</strong>文件信息来分析<strong>synchronized</strong>关键字的实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronized</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// 对Synchronized Class对象进行加锁</span></div><div class="line"><span class="keyword">synchronized</span> (Synchronized.class) &#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 静态同步方法，对Synchronized Class对象进行加锁</span></div><div class="line">m();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// TODO</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>在<strong>Synchronized.class</strong>同级目录执行<strong>javap –v Synchronized.class</strong>，部分相关输出如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static void main(java.lang.String[]);</div><div class="line">// 方法修饰符，表示：public staticflags: ACC_PUBLIC, ACC_STATIC</div><div class="line">Code:</div><div class="line">stack=2, locals=1, args_size=1</div><div class="line">0: ldc #1　　// class com/murdock/books/multithread/book/Synchronized</div><div class="line">2: dup</div><div class="line">3: monitorenter　　// monitorenter：监视器进入，获取锁</div><div class="line">4: monitorexit　　 // monitorexit：监视器退出，释放锁</div><div class="line">5: invokestatic　　#16 // Method m:()V</div><div class="line">8: return</div><div class="line">public static synchronized void m();</div><div class="line">// 方法修饰符，表示： public static synchronized</div><div class="line">flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</div><div class="line">Code:</div><div class="line">stack=0, locals=0, args_size=0</div><div class="line">0: return</div></pre></td></tr></table></figure><p>上面<strong>class</strong>信息中，对于同步块的实现使用了<strong>monitorenter</strong>和<strong>monitorexit</strong>指令，而同步方法则是依靠方法修饰符上的<strong>ACC_SYNCHRONIZED</strong>来完成的。无论采用哪种方式，其本质是对一个对象的监视器（<strong>monitor</strong>）进行获取，而这个<strong>获取过程是排他的</strong>，也就是同一时刻只能有一个线程获取到由<strong>synchronized</strong>所保护对象的监视器。</p><p>任意一个<strong>对象都拥有自己的监视器</strong>，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先<strong>获取到该对象的监视器</strong>才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程将会<strong>被阻塞</strong>在同步块和同步方法的入口处，进入<strong>BLOCKED状态</strong>。</p><p>下图描述了对象、对象的监视器、同步队列和执行线程之间的关系。</p><p><img src="/images/并发编程/2019091701.png" alt=""></p><p>从上图可以看到，任意线程对Object（Object由synchronized保护）的访问，首先要<strong>获得Object的监视器</strong>。如果获取失败，线程<strong>进入同步队列</strong>，线程<strong>状态变为BLOCKED</strong>。当访问Object的前驱（获得了锁的线程）释放了锁，则<strong>该释放操作唤醒阻塞在同步队列中的线程</strong>，使其<strong>重新尝试对监视器的获取</strong>。</p><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。</p><p>前者是<strong>生产者</strong>，后者就是<strong>消费者</strong>，这种模式隔离了<strong>“做什么”（what）</strong>和<strong>“怎么做”（How）</strong>，在功能层面上实现了解耦，体系结构上具备了良好的伸缩性，但是在Java语言中如何实现类似的功能呢？</p><p>简单的办法是让消费者线程不断地<strong>循环检查</strong>变量<strong>是否符合预期</strong>，如下代码所示，在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (value != desire) &#123;</div><div class="line">Thread.sleep(<span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line">doSomething();</div></pre></td></tr></table></figure><p>上面这段伪代码在条件不满足时就睡眠一段时间，这样做的目的是防止过快的“无效”尝试，这种方式看似能够解实现所需的功能，但是却存在如下问题：</p><ol><li><strong>难以确保及时性</strong>。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时发现条件已经变化，也就是及时性难以保证。</li><li><strong>难以降低开销</strong>。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。</li></ol><p>以上两个问题，看似矛盾难以调和，但是Java通过内置的<strong>等待/通知机制</strong>能够很好地解决这个矛盾并实现所需的功能。</p><p><strong>等待/通知</strong>的相关方法是<strong>任意Java对象都具备</strong>的，因为这些方法被定义在所有对象的<strong>超类java.lang.Object</strong>上，方法和描述如下图：</p><p><img src="/images/并发编程/2019091901.png" alt=""></p><p><strong>等待/通知机制</strong>，是指一个线程A调用了<strong>对象O的wait()方法</strong>进入<strong>等待状态</strong>，而另一个线程B调用了<strong>对象O</strong>的<strong>notify()</strong>或者<strong>notifyAll()</strong>方法，线程A收到通知后从<strong>对象O的wait()</strong>方法返回，进而执行后续操作。</p><p>上述两个线程通过<strong>对象O</strong>来完成交互，而对象上的<strong>wait()</strong>和<strong>notify/notifyAll()</strong>的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p><p>下例中，创建了两个线程——<strong>WaitThread</strong>和<strong>NotifyThread</strong>，前者检查flag值是否为false，如果符合要求，进行后续操作，否则在lock上等待，后者在睡眠了一段时间后对lock进行通知，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(), <span class="string">"WaitThread"</span>);</div><div class="line">waitThread.start();</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(), <span class="string">"NotifyThread"</span>);</div><div class="line">notifyThread.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// 加锁，拥有lock的Monitor</span></div><div class="line"><span class="keyword">synchronized</span> (lock) &#123;</div><div class="line"><span class="comment">// 当条件不满足时，继续wait，同时释放了lock的锁</span></div><div class="line"><span class="keyword">while</span> (flag) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(Thread.currentThread()</div><div class="line">+ <span class="string">" flag is true. wait@ "</span></div><div class="line">+ <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>)</div><div class="line">.format(<span class="keyword">new</span> Date()));</div><div class="line">lock.wait();</div><div class="line">System.out.println(Thread.currentThread()+<span class="string">"拿到锁，继续执行。"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 条件满足时，完成工作</span></div><div class="line">System.out.println(Thread.currentThread()</div><div class="line">+ <span class="string">" flag is false. running@ "</span></div><div class="line">+ <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// 加锁，拥有lock的Monitor</span></div><div class="line"><span class="keyword">synchronized</span> (lock) &#123;</div><div class="line"><span class="comment">// 获取lock的锁，然后进行通知，通知时不会释放lock的锁，</span></div><div class="line"><span class="comment">// 直到当前线程释放了lock后，WaitThread才能从wait方法中返回</span></div><div class="line">System.out.println(Thread.currentThread()</div><div class="line">+ <span class="string">" hold lock. notify@ "</span></div><div class="line">+ <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</div><div class="line">lock.notifyAll();</div><div class="line">flag = <span class="keyword">false</span>;</div><div class="line">SleepUtils.second(<span class="number">5</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 再次加锁</span></div><div class="line"><span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">System.out.println(Thread.currentThread()</div><div class="line">+ <span class="string">" hold lock again. sleep@ "</span></div><div class="line">+ <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</div><div class="line">SleepUtils.second(<span class="number">5</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Thread[WaitThread,5,main] flag is true. wait@ 08:32:25</div><div class="line">Thread[NotifyThread,5,main] hold lock. notify@ 08:32:26</div><div class="line">Thread[NotifyThread,5,main] hold lock again. sleep@ 08:32:31 //3</div><div class="line">Thread[WaitThread,5,main]拿到锁，继续执行。 //4</div><div class="line">Thread[WaitThread,5,main] flag is false. running@ 08:32:36 //4</div></pre></td></tr></table></figure><p>上述3和4输出的顺序可能会互换，上述例子主要说明了调用<strong>wait()</strong>、<strong>notify()</strong>以及<strong>notifyAll()</strong>时需要注意的细节：</p><ol><li>使用wait()、notify()和notifyAll()时需要<strong>先对调用对象加锁</strong>。</li><li>调用wait()方法后，线程状态<strong>由RUNNING变为WAITING</strong>，并将当前线程放置到对象的等待队列。</li><li>notify()或notifyAll()方法调用后，<strong>等待线程依旧不会从wait()返回</strong>，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。</li><li>notify()方法将等待队列中的一个等待线程<strong>从等待队列中移到同步队列中</strong>，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的<strong>线程状态由WAITING变为BLOCKED</strong>。</li><li>从wait()方法返回的前提是<strong>获得了调用对象的锁</strong>。</li></ol><p>上述细节中可以看到，<strong>等待/通知机制依托于同步机制</strong>，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改。下图描述了上例的运行过程：</p><p><img src="/images/并发编程/2019091902.png" alt=""></p><p>图中执行顺序：</p><ol><li><strong>WaitThread</strong>首先获取了对象的锁，然后调用<strong>对象的wait()方法</strong>，从而放弃了锁并进入了对象的<strong>等待队列WaitQueue</strong>中，进入等待状态。</li><li>由于<strong>WaitThread</strong>释放了对象的锁，<strong>NotifyThread</strong>随后获取了对象的锁，并调用<strong>对象的notify()方法</strong>，将<strong>WaitThread</strong>从<strong>WaitQueue</strong>移到<strong>SynchronizedQueue</strong>中，此时<strong>WaitThread</strong>的状态变为<strong>阻塞</strong>状态。</li><li><strong>NotifyThread</strong>释放了锁之后，<strong>WaitThread</strong>再次获取到锁并从<strong>wait()</strong>方法返回继续执行。</li></ol><h2 id="等待-通知-经典范式"><a href="#等待-通知-经典范式" class="headerlink" title="等待/通知-经典范式"></a>等待/通知-经典范式</h2><p>等待方遵循如下原则：</p><ol><li><p>获取对象的锁。</p></li><li><p>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</p></li><li><p>条件满足则执行对应的逻辑。</p><p>对应的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(对象) &#123;</div><div class="line"><span class="keyword">while</span>(条件不满足) &#123;</div><div class="line">对象.wait();</div><div class="line">&#125;</div><div class="line">对应的处理逻辑</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>通知方遵循如下原则：</p><ol><li><p>获得对象的锁。</p></li><li><p>改变条件。</p></li><li><p>通知所有等待在对象上的线程。</p><p>对应的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(对象) &#123;</div><div class="line">改变条件</div><div class="line">对象.notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a>管道输入/输出流</h2><p><strong>管道输入/输出流</strong>和普通的<strong>文件输入/输出流</strong>或者<strong>网络输入/输出流</strong>不同之处在于，它主要用于<strong>线程之间的数据传输</strong>，而<strong>传输的媒介为内存</strong>。</p><p>管道输入/输出流主要包括如下4种具体实现：<strong>PipedOutputStream</strong>、<strong>PipedInputStream</strong>、<strong>PipedReader</strong>和<strong>PipedWriter</strong>，前两种面向字节，后两种面向字符。</p><p>如下例子中，创建了<strong>printThread</strong>，它用来接受main线程的输入，任何main线程的输入均通过<strong>PipedWriter</strong>写入，而<strong>printThread</strong>在另一端通过<strong>PipedReader</strong>将内容读出并打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">PipedWriter out = <span class="keyword">new</span> PipedWriter();</div><div class="line">PipedReader in = <span class="keyword">new</span> PipedReader();</div><div class="line"><span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></div><div class="line">out.connect(in);</div><div class="line">Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</div><div class="line">printThread.start();</div><div class="line"><span class="keyword">int</span> receive = <span class="number">0</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</div><div class="line">out.write(receive);</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">out.close();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> PipedReader in;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.in = in;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> receive = <span class="number">0</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;</div><div class="line">System.out.print((<span class="keyword">char</span>) receive);</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行该示例，输入一组字符串，可以看到被printThread进行了原样输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Repeat my words.</div><div class="line">Repeat my words.</div></pre></td></tr></table></figure><p>对于<strong>Piped</strong>类型的流，必须先要进行<strong>绑定</strong>，也就是<strong>调用connect()方法</strong>，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。</p><h2 id="Thread-join-的使用"><a href="#Thread-join-的使用" class="headerlink" title="Thread.join()的使用"></a>Thread.join()的使用</h2><p>如果一个<strong>线程A</strong>执行了<strong>thread.join()</strong>语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。</p><p>线程Thread除了提供join()方法之外，还提供了<strong>join(long millis)</strong>和<strong>join(long millis,int nanos)</strong>两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。</p><p>下例中，创建了10个线程，编号0~9，每个线程调用前一个线程的join()方法，也就是线程0结束了，线程1才能从join()方法中返回，而线程0需要等待main线程结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">Thread previous = Thread.currentThread();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line"><span class="comment">// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span></div><div class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Domino(previous), String.valueOf(i));</div><div class="line">thread.start();</div><div class="line">previous = thread;</div><div class="line">&#125;</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</div><div class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" terminate."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Domino</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> Thread thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Domino</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.thread = thread;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">thread.join();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">&#125;</div><div class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" terminate."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">main terminate.</div><div class="line">0 terminate.</div><div class="line">1 terminate.</div><div class="line">2 terminate.</div><div class="line">3 terminate.</div><div class="line">4 terminate.</div><div class="line">5 terminate.</div><div class="line">6 terminate.</div><div class="line">7 terminate.</div><div class="line">8 terminate.</div><div class="line">9 terminate.</div></pre></td></tr></table></figure><p>从上述输出可以看到，每个线程终止的前提是前驱线程的终止，每个线程等待前驱线程终止后，才从join()方法返回，这里涉及了等待/通知机制（<strong>等待前驱线程结束，接收前驱线程结束通知</strong>）。</p><p>以下是<strong>JDK</strong>中<strong>Thread.join()</strong>方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加锁当前线程对象</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"><span class="comment">// 条件不满足，继续等待</span></div><div class="line"><span class="keyword">while</span> (isAlive()) &#123;</div><div class="line">wait(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 条件符合，方法返回</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当线程终止时，会调用线程自身的<strong>notifyAll()</strong>方法，会通知所有等待在该线程对象上的线程。可以看到join()方法的逻辑结构与上述的<strong>等待/通知经典范式</strong>一致，即加锁、循环和处理逻辑3个步骤。</p><h2 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h2><p><strong>ThreadLocal</strong>，即线程变量，是一个以<strong>ThreadLocal对象为键</strong>、<strong>任意对象为值</strong>的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p><p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p><p>在下例中，构建了一个常用的<strong>Profiler</strong>类，它具有<strong>begin()</strong>和<strong>end()</strong>两个方法，而<strong>end()</strong>方法返回从<strong>begin()</strong>方法调用开始到<strong>end()</strong>方法被调用时的时间差，单位是毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</div><div class="line"><span class="comment">// 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;</div><div class="line"><span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> System.currentTimeMillis();</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</div><div class="line">TIME_THREADLOCAL.set(System.currentTimeMillis());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">Profiler.begin();</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cost: 1002 mills</div></pre></td></tr></table></figure><p>Profiler可以被复用在方法<strong>调用耗时统计</strong>的功能上，在方法的入口前执行begin()方法，在方法调用后执行end()方法，好处是两个方法的调用不用在一个方法或者类中，比如在<strong>AOP</strong>（面向方面编程）中，可以在方法调用前的切入点执行begin()方法，而在方法调用后的切入点执行end()方法，这样依旧可以获得方法的执行耗时。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发总结-线程基础</title>
      <link href="/2019/09/15/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/09/15/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h1><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>一个Java程序的运行不仅仅是main()方法的运行，而是main线程和多个其他线程的同时运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// 获取Java线程管理MXBean</span></div><div class="line">ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</div><div class="line"><span class="comment">// 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息</span></div><div class="line">ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line"><span class="comment">// 遍历线程信息，仅打印线程ID和线程名称信息</span></div><div class="line"><span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</div><div class="line">System.out.println(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"] "</span></div><div class="line">+ threadInfo.getThreadName());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[5] Attach Listener //提供一种jvm进程间通信的能力，能让一个进程传命令给另外一个进程，并让它执行内部的一些操作</div><div class="line">[4] Signal Dispatcher //分发处理发送给JVM信号的线程</div><div class="line">[3] Finalizer //调用对象finalize方法的线程</div><div class="line">[2] Reference Handler //清除Reference的线程</div><div class="line">[1] main //main线程，用户程序入口</div></pre></td></tr></table></figure><a id="more"></a><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>在Java线程中，通过一个整型成员变量<strong>priority</strong>来控制优先级，优先级的范围从<strong>1~10</strong>，在线程构建的时候可以通过<strong>setPriority(int)</strong>方法来修改优先级，默认优先级是<strong>5</strong>，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。</p><p>在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priority</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notStart = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notEnd = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">List&lt;Job&gt; jobs = <span class="keyword">new</span> ArrayList&lt;Job&gt;();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line"><span class="keyword">int</span> priority = i &lt; <span class="number">5</span> ? Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;</div><div class="line">Job job = <span class="keyword">new</span> Job(priority);</div><div class="line">jobs.add(job);</div><div class="line">Thread thread = <span class="keyword">new</span> Thread(job, <span class="string">"Thread:"</span> + i);</div><div class="line">thread.setPriority(priority);</div><div class="line">thread.start();</div><div class="line">&#125;</div><div class="line">notStart = <span class="keyword">false</span>;</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">10</span>);</div><div class="line">notEnd = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">for</span> (Job job : jobs) &#123;</div><div class="line">System.out.println(<span class="string">"Job Priority : "</span> + job.priority + <span class="string">",Count : "</span></div><div class="line">+ job.jobCount);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> priority;</div><div class="line"><span class="keyword">private</span> <span class="keyword">long</span> jobCount;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.priority = priority;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span> (notStart) &#123;</div><div class="line">Thread.yield();</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span> (notEnd) &#123;</div><div class="line">Thread.yield();</div><div class="line">jobCount++;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Job Priority : 1,Count : 6448504</div><div class="line">Job Priority : 1,Count : 6249883</div><div class="line">Job Priority : 1,Count : 6839805</div><div class="line">Job Priority : 1,Count : 6840118</div><div class="line">Job Priority : 1,Count : 6413121</div><div class="line">Job Priority : 10,Count : 6660078</div><div class="line">Job Priority : 10,Count : 7158961</div><div class="line">Job Priority : 10,Count : 6964939</div><div class="line">Job Priority : 10,Count : 6565578</div><div class="line">Job Priority : 10,Count : 6588944</div></pre></td></tr></table></figure><p>从输出可以看到线程优先级没有生效，优先级1和优先级10的Job计数的结果非常相近，没有明显差距。这表示程序正确性不能依赖线程的优先级高低。</p><p><strong>注意：</strong>线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定。</p><p>经验证，<strong>Mac OS X 10.10</strong>，Java版本为<strong>1.7.0_71</strong>环境下所有Java线程优先级均为5（通过<strong>jstack</strong>查看），对线程优先级的设置会被忽略。另外，尝试在<strong>Ubuntu 14.04</strong>环境下运行该示例，输出结果也表示该环境忽略了线程优先级的设置。</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>下图所示的6种不同状态，在给定的一个时刻，线程只能处于其中的一个状态。</p><p><img src="/images/并发编程/2019091601.png" alt=""></p><p>下面我们使用<strong>jstack</strong>工具（可以选择打开终端，键入<strong>jstack</strong>或者到JDK安装目录的bin目录下执行命令），尝试查看示例代码运行时的线程信息，更加深入地理解线程状态，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(<span class="keyword">long</span> seconds)</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">TimeUnit.SECONDS.sleep(seconds);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting(), <span class="string">"TimeWaitingThread"</span>).start();</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">"WaitingThread"</span>).start();</div><div class="line"><span class="comment">// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞</span></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-1"</span>).start();</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-2"</span>).start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 该线程不断地进行睡眠</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">SleepUtils.second(<span class="number">100</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 该线程在Waiting.class实例上等待</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line"><span class="keyword">synchronized</span> (Waiting.class) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Waiting.class.wait();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 该线程在Blocked.class实例上加锁后，不会释放该锁</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (Blocked.class) &#123;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">SleepUtils.second(<span class="number">100</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行该示例，打开终端或者命令提示符，键入<strong>“jps”</strong>，输出如下：</p><p><img src="/images/并发编程/2019091602.png" alt=""></p><p>可以看到运行示例对应的进程ID是<strong>12632</strong>，接着再键入<strong>“jstack 12632”</strong>（这里的进程ID需要和读者自己键入jps得出的ID一致），部分输出如下所示：</p><p><img src="/images/并发编程/2019091603.png" alt=""></p><p>通过示例，我们了解到Java程序运行中线程状态的具体含义。线程在自身的生命周期中，并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，<strong>Java线程状态变迁</strong>如下所示：</p><p><img src="/images/并发编程/2019091604.png" alt=""></p><p><strong>注意：</strong>Java将操作系统中的<strong>运行</strong>和<strong>就绪</strong>两个状态合并称为<strong>运行状态</strong>。阻塞状态是线程阻塞在进入<strong>synchronized</strong>关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在<strong>java.concurrent</strong>包中<strong>Lock</strong>接口的线程状态却是等待状态，因为<strong>java.concurrent</strong>包中Lock接口对于阻塞的实现均使用了<strong>LockSupport</strong>类中的相关方法。</p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><h3 id="守护线程简述"><a href="#守护线程简述" class="headerlink" title="守护线程简述"></a>守护线程简述</h3><ul><li>指的是程序运行时在后台提供的一种通用服务的线程。</li><li>在操作系统里面是没有所谓的守护线程的概念，只有守护进程一说。</li><li>Java平台把操作系统的底层给屏蔽了，在它自己虚拟的JVM平台里面构造出对自己有利的机制。</li></ul><p><strong>守护线程是一种支持型线程</strong>，它主要被用作程序中<strong>后台调度</strong>以及<strong>支持性工作</strong>。比如<strong>垃圾回收线程</strong>就是一个很称职的守护者，并且这种线程并不是程序中不可或缺的部分。</p><p>User Thread（用户线程）和Daemon Thread（守护线程）本质没有区别，<strong>唯一不同</strong>之处在于虚拟机的退出：</p><ul><li>当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程，Java虚拟机将会退出（守护线程也就没有工作可做了，也就没有继续运行程序的必要了）。</li><li>反过来说，只要任何非守护线程还在运行，程序就不会终止。</li><li>可以通过调用<strong>Thread.setDaemon(true)</strong>将线程设置为守护线程。</li></ul><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><strong>thread.setDaemon(true)必须在thread.start()之前设置</strong>，否则会抛出一个IllegalThreadStateException异常。这也就意味着不能把正在运行的常规线程设置为守护线程。 这点与操作系统中的守护进程有着明显的区别，守护进程是创建后，让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别。</li><li><strong>在Daemon线程中产生的新线程也是Daemon的</strong>。关于这一点又是与操作系统中的守护进程有着本质的区别：守护进程fork()出来的子进程不再是守护进程，尽管它把父进程的进程相关信息复制过去了，但是子进程的进程的父进程不是init进程，所谓的守护进程本质上说就是，当父进程挂掉，init就会收养该进程，然后文件0、1和2都是/dev/null，当前目录到/。</li><li>不是所有的应用都可以分配给Daemon线程来进行服务的，比如读写操作或者计算逻辑。因为这种应用可能在Daemon Thread还没来得及进行操作时，虚拟机已经退出了。这也就意味着，<strong>守护线程应该永远不去访问固有资源，如文件、数据库</strong>，因为它会在任何时候甚至在一个操作的中间发生中断。</li></ul><p><strong>示例1</strong>： 一个完成文件输出的守护线程任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 守护线程阻塞1秒后运行  </span></div><div class="line">            File f = <span class="keyword">new</span> File(<span class="string">"daemon.txt"</span>);</div><div class="line">            FileOutputStream os = <span class="keyword">new</span> FileOutputStream(f,<span class="keyword">true</span>);</div><div class="line">            os.write(<span class="string">"daemon"</span>.getBytes());</div><div class="line">        &#125; <span class="keyword">catch</span>(IOException e1) &#123;  </div><div class="line">            e1.printStackTrace();  </div><div class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e2) &#123;  </div><div class="line">            e2.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Runnable tr = <span class="keyword">new</span> TestRunnable();</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(tr);</div><div class="line">        thread.setDaemon(<span class="keyword">true</span>); <span class="comment">// 设置守护线程（必须在thread.start()之前）</span></div><div class="line">        thread.start(); <span class="comment">// 开始执行分进程</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面这段代码的运行结果是文件daemon.txt中没有daemon字符串。</p><p>但是如果把thread.setDaemon(true);这行代码注释掉，文件daemon.txt是可以被写入daemon字符串的，因为这个时候这个线程就是普通的用户线程了。</p><p>简单理解就是，<strong>JRE判断程序是否执行结束的标准是所有的前台线程（用户线程）执行完毕了，而不管后台线程（守护线程）的状态</strong>。</p><p><strong>示例2</strong>：Daemon线程被用作完成支持性工作，在Java虚拟机退出时Daemon线程中的<strong>finally</strong>块并不一定会执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(), <span class="string">"DaemonRunner"</span>);</div><div class="line">thread.setDaemon(<span class="keyword">true</span>);</div><div class="line">thread.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">SleepUtils.second(<span class="number">10</span>);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">System.out.println(<span class="string">"DaemonThread finally run."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行Daemon程序，可以看到在终端或者命令提示符上没有任何输出。main线程（<strong>非Daemon线程</strong>）在启动了线程<strong>DaemonRunner</strong>之后随着main方法执行完毕而终止，而此时Java虚拟机中已经没有<strong>非Daemon线程</strong>，虚拟机需要退出。Java虚拟机中的<strong>所有Daemon线程</strong>都需要立即终止，因此<strong>DaemonRunner</strong>立即终止，但是<strong>DaemonRunner</strong>中的<strong>finally</strong>块并没有执行。</p><p><strong>注意：</strong>在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p> Web服务器中的Servlet，在容器启动时，后台都会初始化一个服务线程，即调度线程，负责处理http请求，然后每个请求过来，调度线程就会从线程池中取出一个工作者线程来处理该请求，从而实现并发控制的目的。也就是说，一个实际应用在Java的线程池中的调度线程。 </p><p><img src="/images/并发编程/2019110701.jpg" alt=""></p><h1 id="启动和终止"><a href="#启动和终止" class="headerlink" title="启动和终止"></a>启动和终止</h1><h2 id="构造线程"><a href="#构造线程" class="headerlink" title="构造线程"></a>构造线程</h2><p>如下摘自<strong>java.lang.Thread</strong>中对线程进行初始化的部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></div><div class="line"><span class="keyword">long</span> stackSize, AccessControlContext acc) &#123;</div><div class="line"><span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 当前线程就是该线程的父线程</span></div><div class="line">Thread parent = currentThread();</div><div class="line"><span class="keyword">this</span>.group = g;</div><div class="line"><span class="comment">// 将daemon、priority属性设置为父线程的对应属性</span></div><div class="line"><span class="keyword">this</span>.daemon = parent.isDaemon();</div><div class="line"><span class="keyword">this</span>.priority = parent.getPriority();</div><div class="line"><span class="keyword">this</span>.name = name.toCharArray();</div><div class="line"><span class="keyword">this</span>.target = target;</div><div class="line">setPriority(priority);</div><div class="line"><span class="comment">// 将父线程的InheritableThreadLocal复制过来</span></div><div class="line"><span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</div><div class="line"><span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal</div><div class="line">.createInheritedMap(parent.inheritableThreadLocals);</div><div class="line"><span class="comment">// 分配一个线程ID</span></div><div class="line">tid = nextThreadID();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述过程中，一个新构造的线程对象是由其<strong>parent线程</strong>来进行空间分配的，而<strong>child线程</strong>继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</p><h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><p>线程对象在初始化完成之后，调用<strong>start()方法</strong>就可以启动这个线程。线程<strong>start()方法</strong>的含义是：当前线程（<strong>即parent线程</strong>）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用<strong>start()方法</strong>的线程。</p><p><strong>注意：</strong>启动一个线程前，最好为这个线程设置线程名称，因为这样在使用jstack分析程序或者进行问题排查时，就会给开发人员提供一些提示，自定义的线程最好能够起个名字。</p><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的<strong>interrupt()方法</strong>对其进行中断操作。</p><p>线程通过检查自身是否被中断来进行响应，线程通过方法<strong>isInterrupted()</strong>来进行判断是否被中断，也可以调用静态方法<strong>Thread.interrupted()</strong>对当前线程的中断标识位进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的<strong>isInterrupted()</strong>时依旧会返回false。</p><p>从Java的API中可以看到，许多声明抛出<strong>InterruptedException</strong>的方法（例如<strong>Thread.sleep(long millis)</strong>方法）这些方法在抛出<strong>InterruptedException</strong>之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出<strong>InterruptedException</strong>，此时调用<strong>isInterrupted()方法</strong>将会返回false。</p><p>如下创建了两个线程，<strong>SleepThread</strong>和<strong>BusyThread</strong>，前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupted</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"><span class="comment">// sleepThread不停的尝试睡眠</span></div><div class="line">Thread sleepThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepRunner(), <span class="string">"SleepThread"</span>);</div><div class="line">sleepThread.setDaemon(<span class="keyword">true</span>);</div><div class="line"><span class="comment">// busyThread不停的运行</span></div><div class="line">Thread busyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BusyRunner(), <span class="string">"BusyThread"</span>);</div><div class="line">busyThread.setDaemon(<span class="keyword">true</span>);</div><div class="line">sleepThread.start();</div><div class="line">busyThread.start();</div><div class="line"><span class="comment">// 休眠5秒，让sleepThread和busyThread充分运行</span></div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</div><div class="line">sleepThread.interrupt();</div><div class="line">busyThread.interrupt();</div><div class="line">System.out.println(<span class="string">"SleepThread interrupted is "</span></div><div class="line">+ sleepThread.isInterrupted());</div><div class="line">System.out.println(<span class="string">"BusyThread interrupted is "</span></div><div class="line">+ busyThread.isInterrupted());</div><div class="line"><span class="comment">// 防止sleepThread和busyThread立刻退出</span></div><div class="line">SleepUtils.second(<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">SleepUtils.second(<span class="number">10</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SleepThread interrupted is false</div><div class="line">BusyThread interrupted is true</div></pre></td></tr></table></figure><p>从结果可以看出，抛出InterruptedException的线程SleepThread，其中断标识位被清除了，而一直忙碌运作的线程BusyThread，中断标识位没有被清除。</p><p><strong>线程中断这里分两种情况：</strong></p><ol><li>线程在<strong>sleep或wait、join</strong>，此时如果别的进程<strong>调用此进程的interrupt()方法</strong>，此线程会被唤醒并被要求处理<strong>InterruptedException</strong>；(thread在做IO操作时也可能有类似行为，见java thread api)</li><li>线程在<strong>运行中</strong>，则<strong>不会收到提醒</strong>。但是 此线程的<strong>中断标识位会被设置</strong>，可以通过<strong>isInterrupted()查看</strong>并作出处理。</li></ol><h2 id="过期方法"><a href="#过期方法" class="headerlink" title="过期方法"></a>过期方法</h2><p>过期的<strong>suspend()</strong>、<strong>resume()</strong>和<strong>stop()</strong></p><p>如果把它<strong>播放音乐</strong>比作一个<strong>线程的运作</strong>，那么对音乐播放做出的<strong>暂停</strong>、<strong>恢复</strong>和<strong>停止</strong>操作对应在线程Thread的API就是<strong>suspend()</strong>、<strong>resume()</strong>和<strong>stop()</strong>。</p><p>如下例子以1秒的频率进行打印，而主线程对其进行暂停、恢复和停止操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deprecated</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</div><div class="line">Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runner(), <span class="string">"PrintThread"</span>);</div><div class="line">printThread.setDaemon(<span class="keyword">true</span>);</div><div class="line">printThread.start();</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</div><div class="line"><span class="comment">// 将PrintThread进行暂停，输出内容工作停止</span></div><div class="line">printThread.suspend();</div><div class="line">System.out.println(<span class="string">"main suspend PrintThread at "</span></div><div class="line">+ format.format(<span class="keyword">new</span> Date()));</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</div><div class="line"><span class="comment">// 将PrintThread进行恢复，输出内容继续</span></div><div class="line">printThread.resume();</div><div class="line">System.out.println(<span class="string">"main resume PrintThread at "</span></div><div class="line">+ format.format(<span class="keyword">new</span> Date()));</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</div><div class="line"><span class="comment">// 将PrintThread进行终止，输出内容停止</span></div><div class="line">printThread.stop();</div><div class="line">System.out.println(<span class="string">"main stop PrintThread at "</span></div><div class="line">+ format.format(<span class="keyword">new</span> Date()));</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">System.out.println(Thread.currentThread().getName()</div><div class="line">+ <span class="string">" Run at "</span> + format.format(<span class="keyword">new</span> Date()));</div><div class="line">SleepUtils.second(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PrintThread Run at 19:26:14</div><div class="line">PrintThread Run at 19:26:15</div><div class="line">PrintThread Run at 19:26:16</div><div class="line">main suspend PrintThread at 19:26:17</div><div class="line">main resume PrintThread at 19:26:20</div><div class="line">PrintThread Run at 19:26:20</div><div class="line">PrintThread Run at 19:26:21</div><div class="line">PrintThread Run at 19:26:22</div><div class="line">main stop PrintThread at 19:26:23</div></pre></td></tr></table></figure><p>可以看到，<strong>suspend()</strong>、<strong>resume()</strong>和<strong>stop()</strong>方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。</p><p>不建议使用的原因主要有：以<strong>suspend()</strong>方法为例，在调用后，线程<strong>不会释放</strong>已经占有的资源（比如<strong>锁</strong>），而是<strong>占有着资源进入睡眠状态</strong>，这样<strong>容易引发死锁</strong>问题。同样，<strong>stop()</strong>方法在终结一个线程时<strong>不会保证线程的资源正常释放</strong>，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p><p><strong>注意：</strong>正因为<strong>suspend()</strong>、<strong>resume()</strong>和<strong>stop()</strong>方法带来的副作用，这些方法才被标注为不建议使用的过期方法，而暂停和恢复操作可以用后面提到的<strong>等待/通知机制来替代</strong>。</p><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p>上述提到的中断状态是线程的一个标识位，而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来<strong>取消或停止</strong>任务。除了中断以外，还可以利用一个<strong>boolean</strong>变量来控制是否需要<strong>停止任务并终止该线程</strong>。</p><p>如下创建了一个线程<strong>CountThread</strong>，它不断地进行变量累加，而主线程尝试对其进行中断操作和停止操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shutdown</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">Runner one = <span class="keyword">new</span> Runner();</div><div class="line">Thread countThread = <span class="keyword">new</span> Thread(one, <span class="string">"CountThread"</span>);</div><div class="line">countThread.start();</div><div class="line"><span class="comment">// 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span></div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">countThread.interrupt();</div><div class="line">Runner two = <span class="keyword">new</span> Runner();</div><div class="line">countThread = <span class="keyword">new</span> Thread(two, <span class="string">"CountThread"</span>);</div><div class="line">countThread.start();</div><div class="line"><span class="comment">// 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span></div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">two.cancel();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">long</span> i;</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"Count i = "</span> + i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">on = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Count i = 737662019</div><div class="line">Count i = 736997287</div></pre></td></tr></table></figure><p>示例在执行过程中，main线程通过<strong>中断操作</strong>和<strong>cancel()方法</strong>均可使<strong>CountThread</strong>得以终止。这种通过<strong>标识位</strong>或者<strong>中断操作</strong>的方式能够使线程在终止时有机会去<strong>清理资源</strong>，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发总结-底层原理</title>
      <link href="/2019/08/31/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/31/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="并发常见问题"><a href="#并发常见问题" class="headerlink" title="并发常见问题"></a>并发常见问题</h2><h3 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h3><p>减少上下文切换的方法有<strong>无锁并发编程</strong>、<strong>CAS算法</strong>、使用最少线程和使用<strong>协程</strong>。</p><ul><li><p><strong>无锁并发编程</strong>。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</p></li><li><p><strong>CAS算法</strong>。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。</p></li><li><p><strong>使用最少线程</strong>。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</p></li><li><p><strong>协程</strong>。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p><a id="more"></a></li></ul><h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><ul><li>避免一个线程同时获取多个锁。</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li></ul><h2 id="原子操作实现原理"><a href="#原子操作实现原理" class="headerlink" title="原子操作实现原理"></a>原子操作实现原理</h2><p>原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。</p><h3 id="处理器如何实现"><a href="#处理器如何实现" class="headerlink" title="处理器如何实现"></a>处理器如何实现</h3><ol><li><p><strong>使用总线锁保证原子性</strong></p><p>如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致。</p><p>处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p></li><li><p><strong>使用缓存锁保证原子性</strong></p><p>在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p><p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。</p><p>所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。</p><p>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能同时缓存i的缓存行。</p></li></ol><p><strong>以下两种情况下处理器不会使用缓存锁定：</strong></p><ol><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。</li><li>有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</li></ol><h3 id="Java如何实现"><a href="#Java如何实现" class="headerlink" title="Java如何实现"></a>Java如何实现</h3><p>在Java中可以通过<strong>循环CAS</strong>和<strong>锁</strong>的方式来实现原子操作。</p><h4 id="CAS线程安全的计数器"><a href="#CAS线程安全的计数器" class="headerlink" title="CAS线程安全的计数器"></a>CAS线程安全的计数器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> AtomicInteger atomicI = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> Counter cas = <span class="keyword">new</span> Counter();</div><div class="line">List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="number">600</span>);</div><div class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</div><div class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">cas.count();</div><div class="line">cas.safeCount();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">ts.add(t);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (Thread t : ts) &#123;</div><div class="line">t.start();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 等待所有线程执行完成</span></div><div class="line"><span class="keyword">for</span> (Thread t : ts) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">t.join();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">System.out.println(cas.i);</div><div class="line">System.out.println(cas.atomicI.get());</div><div class="line">System.out.println(System.currentTimeMillis() - start);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** * 使用CAS实现线程安全计数器 */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line"><span class="keyword">int</span> i = atomicI.get();</div><div class="line"><span class="keyword">boolean</span> suc = atomicI.compareAndSet(i, ++i);</div><div class="line"><span class="keyword">if</span> (suc) &#123;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 非线程安全计数器</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h4><ol><li><p><strong>ABA问题。</strong></p><p>因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p><p>从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(</span></span></div><div class="line">V expectedReference, // 预期引用</div><div class="line">V newReference, // 更新后的引用</div><div class="line"><span class="keyword">int</span> expectedStamp, // 预期标志</div><div class="line"><span class="keyword">int</span> newStamp // 更新后的标志</div><div class="line">)</div></pre></td></tr></table></figure></li><li><p><strong>循环时间长开销大。</strong></p><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。</p><p>pause指令有两个作用：</p><p>第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；</p><p>第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。</p></li><li><p><strong>只能保证一个共享变量的原子操作。</strong></p><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p></li></ol><h4 id="锁机制实现原子操作"><a href="#锁机制实现原子操作" class="headerlink" title="锁机制实现原子操作"></a>锁机制实现原子操作</h4><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p><h2 id="Java并发底层实现"><a href="#Java并发底层实现" class="headerlink" title="Java并发底层实现"></a>Java并发底层实现</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p><p>如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的，线程通过排他锁单独获得这个变量，共享变量能被准确和一致地更新。</p><p>如果对声明了volatile的变量进行写操作：</p><ol><li>JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li></ol><p>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存<br>里。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>Java中的每一个对象都可以作为锁，synchronized实现同步具体有以下3种形式：</p><ul><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。</li></ul><p>在多线程并发编程中synchronized一直是元老级角色，很多人都会称呼它为重量级锁。Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p><p><img src="/images/并发编程/2019091501.PNG" alt=""></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取并打印当前JVM是32位还是64位的</span></div><div class="line">String arch = System.getProperty(<span class="string">"sun.arch.data.model"</span>);</div><div class="line">System.out.println(arch+<span class="string">"-bit"</span>);</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据治理</title>
      <link href="/2019/07/22/Oracle%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/"/>
      <url>/2019/07/22/Oracle%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="表相关"><a href="#表相关" class="headerlink" title="表相关"></a>表相关</h3><p>| 系统名 | 表名 | 表类型 | 记录数 | 是否空表 | 表说明 |</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">t1.SYSTEM_NAME 系统名,</div><div class="line">t1.OBJECT_NAME 表名,</div><div class="line">t1.OBJECT_TYPE 表类型,</div><div class="line">t2.num_rows 记录数,</div><div class="line">t2.ISNULLTB 是否空表,</div><div class="line">t3.COMMENTS 表说明</div><div class="line"><span class="keyword">FROM</span></div><div class="line">(<span class="keyword">SELECT</span></div><div class="line"><span class="string">'Alex'</span> SYSTEM_NAME,</div><div class="line">OBJECT_NAME,</div><div class="line">OBJECT_TYPE</div><div class="line"><span class="keyword">FROM</span> USER_OBJECTS <span class="keyword">WHERE</span> OBJECT_TYPE=<span class="string">'TABLE'</span> <span class="keyword">OR</span> OBJECT_TYPE=<span class="string">'VIEW'</span></div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> OBJECT_TYPE,OBJECT_NAME) t1</div><div class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></div><div class="line">(<span class="keyword">SELECT</span></div><div class="line">TABLE_NAME,</div><div class="line">num_rows,</div><div class="line">(<span class="keyword">CASE</span> num_rows <span class="keyword">WHEN</span> <span class="number">0</span> <span class="keyword">THEN</span> <span class="string">'Y'</span> <span class="keyword">ELSE</span> <span class="string">'N'</span> <span class="keyword">END</span>) ISNULLTB</div><div class="line"><span class="keyword">FROM</span> user_tables) t2</div><div class="line"><span class="keyword">ON</span> t1.OBJECT_NAME = t2.TABLE_NAME</div><div class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> USER_TAB_COMMENTS t3</div><div class="line"><span class="keyword">ON</span> t1.OBJECT_NAME = t3.TABLE_NAME;</div></pre></td></tr></table></figure><a id="more"></a><h3 id="字段相关"><a href="#字段相关" class="headerlink" title="字段相关"></a>字段相关</h3><p>| 系统名称 | 表名称 | 表类型 | 字段名称 | 字段类型 | 是否允许空 | 是否主键 |</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span></div><div class="line"><span class="string">'Alex'</span> <span class="keyword">as</span> 系统名称,</div><div class="line">an.TABLE_NAME <span class="keyword">as</span> 表名称,</div><div class="line">an.TABLE_TYPE <span class="keyword">as</span> 表类型,</div><div class="line">an.COLUMN_NAME <span class="keyword">AS</span> 字段名称,</div><div class="line">an.THE_TYPE <span class="keyword">as</span> 字段类型,</div><div class="line">an.NULLABLE <span class="keyword">as</span> 是否允许空,</div><div class="line">(<span class="keyword">case</span> <span class="keyword">when</span> an.TABLE_NAME=b.TABLE_NAME <span class="keyword">and</span> an.COLUMN_NAME = b.COLUMN_NAME <span class="keyword">THEN</span> <span class="string">'Y'</span> <span class="keyword">ELSE</span> <span class="string">'N'</span> <span class="keyword">END</span> ) <span class="keyword">as</span> 是否主键</div><div class="line"><span class="keyword">from</span></div><div class="line">(<span class="keyword">select</span></div><div class="line">t1.TABLE_NAME,</div><div class="line">(<span class="keyword">case</span> t2.OBJECT_TYPE <span class="keyword">when</span> <span class="string">'TABLE'</span> <span class="keyword">THEN</span> <span class="string">'原表'</span> <span class="keyword">else</span> <span class="string">'视图'</span> <span class="keyword">end</span>) TABLE_TYPE,</div><div class="line">t1.COLUMN_NAME,</div><div class="line">t1.DATA_TYPE || <span class="string">'('</span> || t1.DATA_LENGTH || <span class="string">')'</span> <span class="keyword">AS</span> THE_TYPE,</div><div class="line">t1.NULLABLE</div><div class="line"><span class="keyword">from</span> USER_TAB_COLS t1,</div><div class="line">(<span class="keyword">SELECT</span> OBJECT_NAME,OBJECT_TYPE <span class="keyword">FROM</span> USER_OBJECTS <span class="keyword">WHERE</span> OBJECT_TYPE = <span class="string">'TABLE'</span> <span class="keyword">OR</span> OBJECT_TYPE=<span class="string">'VIEW'</span>) t2</div><div class="line"><span class="keyword">where</span> t1.TABLE_NAME = t2.OBJECT_NAME) an <span class="keyword">left</span> <span class="keyword">join</span></div><div class="line">(<span class="keyword">SELECT</span> cu.TABLE_NAME,cu.COLUMN_NAME <span class="keyword">FROM</span> USER_CONS_COLUMNS cu,USER_CONSTRAINTS au</div><div class="line"><span class="keyword">WHERE</span> cu.constraint_name = au.constraint_name</div><div class="line"><span class="keyword">and</span> cu.table_name = au.table_name</div><div class="line"><span class="keyword">and</span> cu.owner =au.owner</div><div class="line"><span class="keyword">and</span> CONSTRAINT_TYPE = <span class="string">'P'</span>) b</div><div class="line"><span class="keyword">on</span> an.table_name = b.table_name <span class="keyword">and</span> an.column_name = b.column_name</div><div class="line"><span class="keyword">order</span> <span class="keyword">by</span> 表名称;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">b.TABLE_NAME <span class="keyword">AS</span> 表名,</div><div class="line">b.COLUMN_NAME <span class="keyword">AS</span> 列名,</div><div class="line">b.DATA_TYPE <span class="keyword">AS</span> 类型,</div><div class="line">b.DATA_LENGTH <span class="keyword">AS</span> 长度,</div><div class="line">A .COMMENTS <span class="keyword">AS</span> 描述,</div><div class="line">b.NULLABLE <span class="keyword">AS</span> 是否可空</div><div class="line"><span class="keyword">FROM</span></div><div class="line">USER_TAB_COLUMNS b,</div><div class="line">USER_COL_COMMENTS A</div><div class="line"><span class="keyword">WHERE</span></div><div class="line">b.TABLE_NAME <span class="keyword">IN</span> (<span class="string">'TABLENAME'</span>)</div><div class="line"><span class="keyword">AND</span> b.TABLE_NAME = A .TABLE_NAME</div><div class="line"><span class="keyword">AND</span> b.COLUMN_NAME = A .COLUMN_NAME</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></div><div class="line">b.TABLE_NAME,</div><div class="line">b.COLUMN_ID</div></pre></td></tr></table></figure><h3 id="表使用情况"><a href="#表使用情况" class="headerlink" title="表使用情况"></a>表使用情况</h3><p>| 系统名 | 数据库类型 | 用户名 | 表名 | 字段数 | 记录数 | B    | KB   | MB   | 是否空表 |</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line"><span class="string">'Alex'</span> <span class="keyword">AS</span> 系统名,</div><div class="line"><span class="string">'oracle'</span> <span class="keyword">AS</span> 数据库类型,</div><div class="line">t1.TABLESPACE_NAME <span class="keyword">AS</span> 用户名,</div><div class="line">t1.TABLE_NAME <span class="keyword">AS</span> 表名,</div><div class="line">t2.column_num <span class="keyword">AS</span> 字段数,</div><div class="line">t1.num_rows <span class="keyword">AS</span> 记录数,</div><div class="line"><span class="keyword">ROUND</span>((t1.num_rows*t1.avg_row_len)/<span class="number">8</span>,<span class="number">0</span>) <span class="keyword">AS</span> B,</div><div class="line"><span class="keyword">ROUND</span>((t1.num_rows*t1.avg_row_len)/<span class="number">8</span>/<span class="number">1024</span>,<span class="number">8</span>) <span class="keyword">AS</span> KB,</div><div class="line"><span class="keyword">ROUND</span>((t1.num_rows*t1.avg_row_len)/<span class="number">8</span>/<span class="number">1024</span>/<span class="number">1024</span>,<span class="number">8</span>) <span class="keyword">AS</span> MB,</div><div class="line">(<span class="keyword">CASE</span> num_rows <span class="keyword">WHEN</span> <span class="number">0</span> <span class="keyword">THEN</span> <span class="string">'Y'</span> <span class="keyword">ELSE</span> <span class="string">'N'</span> <span class="keyword">END</span>) <span class="keyword">AS</span> 是否空表</div><div class="line"><span class="keyword">from</span> user_tables t1</div><div class="line"><span class="keyword">JOIN</span></div><div class="line">(<span class="keyword">select</span> table_name,<span class="keyword">count</span>(*) column_num <span class="keyword">from</span> user_tab_columns <span class="keyword">GROUP</span> <span class="keyword">BY</span> table_name) t2</div><div class="line"><span class="keyword">ON</span> t1.TABLE_NAME = t2.table_name;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象克隆</title>
      <link href="/2019/07/20/%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86/"/>
      <url>/2019/07/20/%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要克隆？"><a href="#为什么要克隆？" class="headerlink" title="为什么要克隆？"></a>为什么要克隆？</h3><ol><li>new出来的对象的属性都是初始化时候的值，当需要一个新的对象来保存当前状态的对象就要靠clone方法。</li><li>把这个对象的临时属性一个一个的赋值给我新new的对象可以是可以，但是一是麻烦，二是，通过源码发现clone是一个native方法，在底层实现，速度快。</li></ol><p>注意：我们常见的<code>Object a = new Object(); Object b = a;</code>这种形式的代码复制的是引用，即对象在内存中的地址，a和b对象仍然指向了同一个对象。而通过clone方法赋值的对象跟原来的对象是同时独立存在的。</p><p><img src="/images/Java/2019072001.jpg" alt=""></p><a id="more"></a><h3 id="如何实现克隆"><a href="#如何实现克隆" class="headerlink" title="如何实现克隆"></a>如何实现克隆</h3><p>在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，值类型包括int、double、byte、boolean、char等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制，下面将对两者进行详细介绍。</p><h4 id="浅克隆-ShallowClone"><a href="#浅克隆-ShallowClone" class="headerlink" title="浅克隆(ShallowClone)"></a>浅克隆(ShallowClone)</h4><p>在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p><ol><li>被复制的类需要实现Clonenable接口（不实现的话在调用clone方法会抛出CloneNotSupportedException异常)， 该接口为标记接口(不含任何方法）</li><li>覆盖clone()方法，访问修饰符设为public。方法中调用super.clone()方法得到需要的复制对象。（native为本地方法）</li></ol><p><img src="/images/Java/2019072002.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> number;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.number = number;</div><div class="line">    &#125;</div><div class="line">      </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        Student stu = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            stu = (Student)<span class="keyword">super</span>.clone();</div><div class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stu;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        Student stu1 = <span class="keyword">new</span> Student();</div><div class="line">        stu1.setNumber(<span class="number">12345</span>);</div><div class="line">        Student stu2 = (Student)stu1.clone();</div><div class="line">          </div><div class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber());<span class="comment">//学生1:12345</span></div><div class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber());<span class="comment">//学生2:12345</span></div><div class="line">          </div><div class="line">        stu2.setNumber(<span class="number">54321</span>);</div><div class="line">      </div><div class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber());<span class="comment">//学生1:12345</span></div><div class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber());<span class="comment">//学生2:54321</span></div><div class="line">        </div><div class="line">        System.out.println(stu1 == stu2); <span class="comment">// false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="深克隆-DeepClone"><a href="#深克隆-DeepClone" class="headerlink" title="深克隆(DeepClone)"></a>深克隆(DeepClone)</h4><p>在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p><p><img src="/images/Java/2019072003.png" alt=""> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String add;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAdd</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> add;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdd</span><span class="params">(String add)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.add = add;</div><div class="line">    &#125;</div><div class="line">      </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        Address addr = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            addr = (Address)<span class="keyword">super</span>.clone();</div><div class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> addr;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</div><div class="line">  </div><div class="line">    <span class="keyword">private</span> Address addr;</div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">getAddr</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> addr;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddr</span><span class="params">(Address addr)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.addr = addr;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> number;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.number = number;</div><div class="line">    &#125;</div><div class="line">      </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        Student stu = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            stu = (Student)<span class="keyword">super</span>.clone();   <span class="comment">//浅复制</span></div><div class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        stu.addr = (Address)addr.clone();   <span class="comment">//深度复制</span></div><div class="line">        <span class="keyword">return</span> stu;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">          </div><div class="line">        Address addr = <span class="keyword">new</span> Address();</div><div class="line">        addr.setAdd(<span class="string">"杭州市"</span>);</div><div class="line">        Student stu1 = <span class="keyword">new</span> Student();</div><div class="line">        stu1.setNumber(<span class="number">123</span>);</div><div class="line">        stu1.setAddr(addr);</div><div class="line">          </div><div class="line">        Student stu2 = (Student)stu1.clone();</div><div class="line">          </div><div class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber() + <span class="string">",地址:"</span> + stu1.getAddr().getAdd());</div><div class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber() + <span class="string">",地址:"</span> + stu2.getAddr().getAdd());</div><div class="line">          </div><div class="line">        addr.setAdd(<span class="string">"西湖区"</span>);</div><div class="line">          </div><div class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber() + <span class="string">",地址:"</span> + stu1.getAddr().getAdd());</div><div class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber() + <span class="string">",地址:"</span> + stu2.getAddr().getAdd());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java.util.Date该类其实也属于深度复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Return a copy of this object.</div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">    Date d = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        d = (Date)<span class="keyword">super</span>.clone();</div><div class="line">        <span class="keyword">if</span> (cdate != <span class="keyword">null</span>) &#123;  </div><div class="line">            d.cdate = (BaseCalendar.Date) cdate.clone();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;&#125; <span class="comment">// Won't happen</span></div><div class="line">    <span class="keyword">return</span> d;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在Java语言中，如果需要实现深克隆，可以通过覆盖Object类的clone()方法实现，也可以通过序列化(Serialization)等方式来实现。</p><h3 id="多层克隆问题"><a href="#多层克隆问题" class="headerlink" title="多层克隆问题"></a>多层克隆问题</h3><p>如果引用类型里面还包含很多引用类型，或者内层引用类型的类里面又包含引用类型，使用clone方法就会很麻烦。这时我们可以用序列化的方式来实现对象的深克隆。</p><p>序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369285298572941L</span>;  <span class="comment">//最好是显式声明ID</span></div><div class="line">  <span class="keyword">public</span> Inner inner;</div><div class="line">　<span class="comment">//Discription:[深度复制方法,需要对象及对象所有的对象属性都实现序列化]　</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Outer <span class="title">myclone</span><span class="params">()</span> </span>&#123;</div><div class="line">      Outer outer = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">try</span> &#123; <span class="comment">// 将该对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。所以利用这个特性可以实现对象的深拷贝</span></div><div class="line">          ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">          ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</div><div class="line">          oos.writeObject(<span class="keyword">this</span>);</div><div class="line">　　　　　　<span class="comment">// 将流序列化成对象</span></div><div class="line">          ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</div><div class="line">          ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</div><div class="line">          outer = (Outer) ois.readObject();</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">          e.printStackTrace();</div><div class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">          e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> outer;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Inner也必须实现Serializable，否则无法序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">872390113109L</span>; <span class="comment">//最好是显式声明ID</span></div><div class="line">  <span class="keyword">public</span> String name = <span class="string">""</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">"Inner的name值为："</span> + name;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样也能使两个对象在内存空间内完全独立存在，互不影响对方的值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>实现对象克隆有两种方式：</p><ol><li>实现Cloneable接口并重写Object类中的clone()方法；</li><li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li></ol><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li>Cloneable接口和Serializable接口，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。</li><li>基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是优于把问题留到运行时。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象克隆与序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决问题的一般套路</title>
      <link href="/2019/07/20/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/"/>
      <url>/2019/07/20/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是问题"><a href="#什么是问题" class="headerlink" title="什么是问题"></a>什么是问题</h2><ol><li>上下文 – 和问题相关的场景，指一组已经是明确已知的，关于问题的条件的描述（比如订单-产品-支付-库存肯定有关系）。</li><li>目标 – 指关于构成问题的结论的明确的描述（让系统更流畅，更高速的，更稳定的运行）。</li><li>障碍 – 指问题的正确解决方法不是显而易见的，必须通过一定的思维活动，才能找到答案。</li></ol><h2 id="如何定义问题"><a href="#如何定义问题" class="headerlink" title="如何定义问题"></a>如何定义问题</h2><ol><li><p>定义问题就是鉴别期望和现状的差异：</p></li><li><p>收集整理关于现状的可信的信息，而不要假设已经拥有完备的可信信息；</p></li><li><p>不暗示倾向于某种原因或者解决方法；</p><a id="more"></a></li><li><p>只陈述现状和期望的状态；</p></li><li><p>在解决问题的过程中，问题的定义可能（有必要）会不断的改进或者转换形式。</p></li><li><p>把问题描述理解清楚，不要掩盖问题，把问题公开化，透明化，解决完问题最好自己再总结一下(高中时候的纠错本)。</p></li></ol><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><p>静心：在定位问题之前，先安静下来，摒除杂念。放下自己的身份（项目经理、开发），以解决当前问题为中心。静心之后，将问题现象在脑中过一遍，弄清问题。</p><h3 id="不轻信，不盲从"><a href="#不轻信，不盲从" class="headerlink" title="不轻信，不盲从"></a><strong>不轻信，不盲从</strong></h3><p>不确定问题的时候，不要说大概是什么问题， 绝不因为一句“应该是对的”，“大概没有变化”，“我昨天没发版，之前都是好的”，而抛弃一个怀疑的点。</p><h3 id="不尽早的陷入细节"><a href="#不尽早的陷入细节" class="headerlink" title="不尽早的陷入细节"></a><strong>不尽早的陷入细节</strong></h3><p>实际上，在整个问题定位和解决的过程中，都应该尽量在头脑中对整个系统的映像以及当前位置保持清晰的认知。这样有助于前后、上下联系，在更高更广阔的空间中发现问题。在解决问题的时候提醒自己：我现在处于一个什么位置？如果不启动调试环境我能不能解决掉这个问题？</p><h3 id="预判断，然后验证"><a href="#预判断，然后验证" class="headerlink" title="预判断，然后验证"></a><strong>预判断，然后验证</strong></h3><p>让我们一起debug,注意environment(dev,qa), zone,region,contextPath等，尽量将日志、调试、Postman等都用作验证问题的工具——首先对问题的原因做预判断（猜测），然后确定该原因会导致什么现象，然后验证该现象（日志等）。预判断比验证更应被关注。</p><p>当很难预判断问题位置时，可以采用排除法：每次排除系统范围的一半左右，逐步将包围圈缩小到问题原因本身。应注意：排除的过程中，同样要注意验证排除的是否正确，即：排除、验证、排除、验证……</p><h2 id="关注日志"><a href="#关注日志" class="headerlink" title="关注日志"></a>关注日志</h2><p>日志一定要看明白NumberFormatException: For input string，NumberFormatException: Value out of range，Duplicate entry，Data truncation: Data too long for column……，很多问题解决过程中其实打开日志文件就能马上得到结论，但是开发人员宁可自己猜也不愿意动手打开日志，那么日志该怎么打印？留个悬念，以后说。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h2><p>工具是让人用的，善于借助监控和运维工具排查问题，会有一些童鞋说，我压根就没权限看到这些东西，springbootadmin，zipkin，log history，zabbix等，记住我们是解决问题的，没有权限也是问题，我们要去解决。</p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其它 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal源码剖析</title>
      <link href="/2019/07/14/ThreadLocal%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2019/07/14/ThreadLocal%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>常用方法</strong></p><ul><li>get()方法用来获取ThreadLocal在当前线程中保存副本变量。</li><li>set()用来设置当前线程中副本变量。</li><li>remove()用来移除当前线程中副本变量。</li><li>initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法。</li></ul><a id="more"></a><p><img src="/images/并发编程/2019071401.jpg" alt=""></p><p>我们来看一下ThreadLocal类是如何为每个线程创建一个变量的副本的。</p><p>先看下get方法的实现：</p><p><img src="/images/并发编程/2019071402.jpg" alt=""></p><p>第一句是取得当前线程。再看一下getMap方法中做了什么：</p><p><img src="/images/并发编程/2019071403.jpg" alt=""></p><p>在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals，继续去Thread类中的成员变量threadLocals看一下是什么：</p><p><img src="/images/并发编程/2019071404.jpg" alt=""></p><p>实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，继续去看ThreadLocalMap的实现：</p><p><img src="/images/并发编程/2019071405.jpg" alt=""></p><p>可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。再继续看setInitialValue方法的具体实现：</p><p><img src="/images/并发编程/2019071406.jpg" alt=""></p><p>很容易了解，就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现：</p><p><img src="/images/并发编程/2019071407.jpg" alt=""></p><p><strong>总结</strong></p><ul><li>实际通过ThreadLocal创建的副本是存储在每个线程Thread内部的一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals中的，键值为当前ThreadLocal变量，value为副本变量（即T类型的变量）。</li><li>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。可以通过get方法在threadLocals里面查找使用副本变量。</li><li>为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量为其提供多种副本变量。</li><li>在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。因为在上面的代码分析过程中，我们发现如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimpleDateFormat线程安全问题</title>
      <link href="/2019/07/12/SimpleDateFormat%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/12/SimpleDateFormat%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h3><p>官方说明：simple beautiful strong immutable thread-safe。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatTest</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span><span class="params">(Date date)</span> <span class="keyword">throws</span> ParseException </span>&#123;</div><div class="line">        <span class="keyword">return</span> sdf.format(date);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String strDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</div><div class="line">        <span class="keyword">return</span> sdf.parse(strDate);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ParseException </span>&#123;</div><div class="line">     ExecutorService service = Executors.newFixedThreadPool(<span class="number">100</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</div><div class="line">            service.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        System.out.println(parse(<span class="string">"2018-01-02 09:45:59"</span>));</div><div class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 等待上述的线程执行完</span></div><div class="line">        service.shutdown();</div><div class="line">        service.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>每次创建一个新实例，就没有线程安全问题。不过加重了创建对象的负担，会频繁地创建和销毁对象，效率较低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span><span class="params">(Date date)</span> <span class="keyword">throws</span> ParseException </span>&#123;</div><div class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">    <span class="keyword">return</span> sdf.format(date);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String strDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</div><div class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">    <span class="keyword">return</span> sdf.parse(strDate);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>synchronized往上一套也可以解决线程安全问题，缺点自然就是并发量大的时候会对性能有影响，线程阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span><span class="params">(Date date)</span> <span class="keyword">throws</span> ParseException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(sdf)&#123;</div><div class="line">        <span class="keyword">return</span> sdf.format(date);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String strDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(sdf)&#123;</div><div class="line">        <span class="keyword">return</span> sdf.parse(strDate);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>ThreadLocal可以确保每个线程都可以得到单独的一个SimpleDateFormat的对象，自然也就不存在竞争问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String dateStr)</span> <span class="keyword">throws</span> ParseException </span>&#123;</div><div class="line">    <span class="keyword">return</span> threadLocal.get().parse(dateStr);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(Date date)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> threadLocal.get().format(date);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h4><p>JDK8中，使用Instant代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替SimpleDateFormat，也就是《阿里巴巴开发手册》给我们的解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate2</span><span class="params">(LocalDateTime date)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> formatter.format(date);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">parse2</span><span class="params">(String dateNow)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> LocalDateTime.parse(dateNow, formatter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ParseException </span>&#123;</div><div class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">100</span>);</div><div class="line">        <span class="comment">// 20个线程</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</div><div class="line">            service.execute(() -&gt; &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        System.out.println(parse2(formatDate2(LocalDateTime.now())));</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 等待上述的线程执行完</span></div><div class="line">        service.shutdown();</div><div class="line">        service.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码解析</title>
      <link href="/2019/07/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/07/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="容量和扩容"><a href="#容量和扩容" class="headerlink" title="容量和扩容"></a>容量和扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* The default initial capacity ‐ MUST be a power of two.</div><div class="line">*/</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* The maximum capacity, used if a higher value is implicitly specified</div><div class="line">* by either of the constructors with arguments.</div><div class="line">* MUST be a power of two &lt;= 1&lt;&lt;30.</div><div class="line">*/</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line">* The load factor used when none specified in constructor.</div><div class="line">*/</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div></pre></td></tr></table></figure><p>我们这里能看到，和 HashTable 一样有 Capacity 和 Factor 的设定，这里面我们的默认值也是 16 和 0.75 的值。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* The bin count threshold for using a tree rather than list for a</div><div class="line">* bin. Bins are converted to trees when adding an element to a</div><div class="line">* bin with at least this many nodes. The value must be greater</div><div class="line">* than 2 and should be at least 8 to mesh with assumptions in</div><div class="line">* tree removal about conversion back to plain bins upon</div><div class="line">* shrinkage.</div><div class="line">*/</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line">* The bin count threshold for untreeifying a (split) bin during a</div><div class="line">* resize operation. Should be less than TREEIFY_THRESHOLD, and at</div><div class="line">* most 6 to mesh with shrinkage detection under removal.</div><div class="line">*/</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line">* The smallest table capacity for which bins may be treeified.</div><div class="line">* (Otherwise the table is resized if too many nodes in a bin.)</div><div class="line">* Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</div><div class="line">* between resizing and treeification thresholds.</div><div class="line">*/</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</div></pre></td></tr></table></figure><p>这个就是我们说的链表成树的门限，我们在大小超过 THRESHOLD(8) 的时候会把列表变成一棵树，还有 UNTREEIFY_THRESHOLD 就是树返回链表的门限，MIN_TREEIFY_CAPACITY 这个是树化的最小的 HashMap 容量。</p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line"><span class="keyword">final</span> K key;</div><div class="line">V value;</div><div class="line">Node&lt;K,V&gt; next;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们每一个 Node 都是这样的一个数据节点，包含K-V和子节点，这个和 Hashtable 没啥区别。</p><h3 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Computes key.hashCode() and spreads (XORs) higher bits of hash</div><div class="line">* to lower. Because the table uses power‐of‐two masking, sets of</div><div class="line">* hashes that vary only in bits above the current mask will</div><div class="line">* always collide. (Among known examples are sets of Float keys</div><div class="line">* holding consecutive whole numbers in small tables.) So we</div><div class="line">* apply a transform that spreads the impact of higher bits</div><div class="line">* downward. There is a tradeoff between speed, utility, and</div><div class="line">* quality of bit‐spreading. Because many common sets of hashes</div><div class="line">* are already reasonably distributed (so don't benefit from</div><div class="line">* spreading), and because we use trees to handle large sets of</div><div class="line">* collisions in bins, we just XOR some shifted bits in the</div><div class="line">* cheapest possible way to reduce systematic lossage, as well as</div><div class="line">* to incorporate impact of the highest bits that would otherwise</div><div class="line">* never be used in index calculations because of table bounds.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> h;</div><div class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JDK7、JDK8 的 HashMap 的 hash 方法是不同的，但是实现的原理其实是一样的东西，我们在程序中实现了一个<strong>扰动函数</strong>，在这里面我们解释一下这个<strong>扰动函数</strong>的具体实现细节：</p><p><img src="/images/Java/2019070601.png" alt=""></p><p>我们先使用默认的HashCode方法求出了返回的Int类型的hash，但是我们的 hash 本身是一个 32bit 的数据，二次幂的话，会有 40亿的 hash 空间，但是 40亿 的 hash 空间是没办法存储的开的，所以我们本身就用通过掩模的方式去的降低我们的数位。</p><p>我们先右移 16 位和自己的 hash 本身异或一下，能让我们的数据更为分散一些。这也揭示了我们的 HashMap 的大小为什么都是取 2 的次幂进行处理，那样我们的 (table.length ‐ 1) 能成为我们的 低位掩模 。我们最后在进行一次 (table.length - 1) &amp; hash 之后我们就能求出位数较小的 hash 值。我们通过 &gt;&gt;&gt; 的方式，让我们的低位值也能保留出高位数据的值，能让我们的 hash 更加平均。</p><h3 id="Field数据"><a href="#Field数据" class="headerlink" title="Field数据"></a>Field数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* The table, initialized on first use, and resized as</div><div class="line">* necessary. When allocated, length is always a power of two.</div><div class="line">* (We also tolerate length zero in some operations to allow</div><div class="line">* bootstrapping mechanics that are currently not needed.)</div><div class="line">*/</div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="comment">/**</span></div><div class="line">* Holds cached entrySet(). Note that AbstractMap fields are used</div><div class="line">* for keySet() and values().</div><div class="line">*/</div><div class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</div><div class="line"><span class="comment">/**</span></div><div class="line">* The number of key‐value mappings contained in this map.</div><div class="line">*/</div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"><span class="comment">/**</span></div><div class="line">* The number of times this HashMap has been structurally modified</div><div class="line">* Structural modifications are those that change the number of mappings in</div><div class="line">* the HashMap or otherwise modify its internal structure (e.g.,</div><div class="line">* rehash). This field is used to make iterators on Collection‐views of</div><div class="line">* the HashMap fail‐fast. (See ConcurrentModificationException).</div><div class="line">*/</div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line"><span class="comment">/**</span></div><div class="line">* The next size value at which to resize (capacity * load factor).</div><div class="line">*</div><div class="line">* <span class="doctag">@serial</span></div><div class="line">*/</div><div class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></div><div class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></div><div class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></div><div class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"><span class="comment">/**</span></div><div class="line">* The load factor for the hash table.</div><div class="line">*</div><div class="line">* <span class="doctag">@serial</span></div><div class="line">*/</div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div></pre></td></tr></table></figure><p>这些数据我们都很熟悉，各种的存储的 table ，用作缓存的 entrySet，还有用作判断同步的 modCount 参数，还有门限和加载因子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Returns a power of two size for the given target capacity.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> n = cap ‐ <span class="number">1</span>;</div><div class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line"><span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们在构造函数中通过这个算法找到了大于等于我们给定参数的最小的二次幂方的参数，这个算法的分析很多人节写的比较麻烦，我们可以简单地理解为我们收到的结果参数都是将数位的所有的位数都变成 1，这样子二进制再加以就会进位，那就肯定是一个 1 全 0 的情况，然后我们拿到值就全是 2 的幂了，这样和 之前介绍的 hash 方法的结合，我们的 HashMap 的容量就能被控制在 2 的幂次了。</p>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>敏捷开发</title>
      <link href="/2019/07/05/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
      <url>/2019/07/05/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="关于敏捷开发"><a href="#关于敏捷开发" class="headerlink" title="关于敏捷开发"></a>关于敏捷开发</h3><p>一般敏捷开发以两周为一个周期，称为一个迭代。在一个迭代中快速完成预估的工作量。敏捷开发的步骤如下：</p><ol><li>需求澄清会：搞清楚用户需求。</li><li>迭代会：提炼出核心需求，把每个工作分解，并估算完成点数（人数×天数），开完会后录入Jira中管理。</li><li>站会：每天早上开一个短会，每个人讲一下昨天做了什么、今天要做什么、遇到了什么困难。根据站会的内容，同步Jira中对应任务的进度。</li><li>回顾会：让领导对这个迭代内做的产品进行评估，提出问题，同时每个人说一下这个迭代收获或者需要改进的地方。</li></ol><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其它 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件开发常用词汇</title>
      <link href="/2019/06/16/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AF%8D%E6%B1%87/"/>
      <url>/2019/06/16/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AF%8D%E6%B1%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/justxzm/Note/blob/master/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AF%8D%E6%B1%871.pdf" target="_blank" rel="external">软件开发常用词汇(一)</a>（点击预览pdf）</p><p><a href="https://github.com/justxzm/Note/blob/master/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AF%8D%E6%B1%872.pdf" target="_blank" rel="external">软件开发常用词汇(二)</a>（点击预览pdf）</p><p><a href="https://github.com/justxzm/Note/blob/master/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AF%8D%E6%B1%873.docx" target="_blank" rel="external">软件开发常用词汇(三)</a>（点击下载word）</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件开发常用词汇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板模式</title>
      <link href="/2019/04/23/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/23/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在模板模式中，一个抽象类公开定义了执行它的方法的方式/模板。</p><p>它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p><p><strong>如何解决：</strong>将这些通用算法抽象出来，在抽象类实现，其他步骤在子类实现。</p><p><strong>应用实例：</strong> </p><ul><li><p>在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。</p></li><li><p>西游记里面菩萨定好的81难，这就是一个顶层的逻辑骨架。</p></li><li><p>spring 中对Hibernate的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p><a id="more"></a></li></ul><p><strong>优点：</strong> </p><ul><li>封装不变部分，扩展可变部分。 </li><li>提取公共代码，便于维护。 </li><li>行为由父类控制，子类实现。</li></ul><p><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><p><strong>使用场景：</strong> </p><ul><li>有多个子类共有的方法，且逻辑相同。 </li><li>重要的、复杂的方法，可以考虑作为模板方法。</li></ul><p><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上final关键词。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h4><p>创建一个抽象类，它的模板方法被设置为final。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</div><div class="line"> </div><div class="line">   <span class="comment">//模板</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</div><div class="line"> </div><div class="line">      <span class="comment">//初始化游戏</span></div><div class="line">      initialize();</div><div class="line"> </div><div class="line">      <span class="comment">//开始游戏</span></div><div class="line">      startPlay();</div><div class="line"> </div><div class="line">      <span class="comment">//结束游戏</span></div><div class="line">      endPlay();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h4><p>创建扩展了上述类的实体类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Cricket Game Finished!"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Cricket Game Initialized! Start playing."</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Cricket Game Started. Enjoy the game!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Football Game Finished!"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Football Game Initialized! Start playing."</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Football Game Started. Enjoy the game!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h4><p>使用Game的模板方法play()来演示游戏的定义方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">      Game game = <span class="keyword">new</span> Cricket();</div><div class="line">      game.play();</div><div class="line">      System.out.println();</div><div class="line">      game = <span class="keyword">new</span> Football();</div><div class="line">      game.play();      </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Cricket Game Initialized! Start playing.</div><div class="line">Cricket Game Started. Enjoy the game!</div><div class="line">Cricket Game Finished!</div><div class="line"></div><div class="line">Football Game Initialized! Start playing.</div><div class="line">Football Game Started. Enjoy the game!</div><div class="line">Football Game Finished!</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2019/04/23/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/23/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</p><p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p><p><strong>何时使用：</strong>想在访问一个类时做一些控制。</p><p><strong>如何实现：</strong>增加中间层，实现与被代理类组合。</p><p><strong>应用实例：</strong> </p><ul><li><p>Windows 里面的快捷方式。 </p></li><li><p>猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 </p></li><li><p>买火车票不一定在火车站买，也可以去代售点。 </p></li><li><p>一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。</p></li><li><p>spring aop。</p><a id="more"></a></li></ul><p><strong>注意事项：</strong> </p><ul><li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 </li><li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</div><div class="line">    </div><div class="line">   <span class="keyword">private</span> String fileName;</div><div class="line">    </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String fileName)</span></span>&#123;</div><div class="line">      <span class="keyword">this</span>.fileName = fileName;</div><div class="line">      loadFromDisk(fileName);</div><div class="line">   &#125;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Displaying "</span> + fileName);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String fileName)</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"Loading "</span> + fileName);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span></span>&#123;</div><div class="line">    </div><div class="line">   <span class="keyword">private</span> RealImage realImage;</div><div class="line">    </div><div class="line">   <span class="keyword">private</span> String fileName;</div><div class="line">    </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(String fileName)</span></span>&#123;</div><div class="line">      <span class="keyword">this</span>.fileName = fileName;</div><div class="line">   &#125;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span>(realImage == <span class="keyword">null</span>)&#123;</div><div class="line">         realImage = <span class="keyword">new</span> RealImage(fileName);</div><div class="line">      &#125;</div><div class="line">      realImage.display();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      Image image = <span class="keyword">new</span> ProxyImage(<span class="string">"test_10mb.jpg"</span>);<span class="comment">//Loading test_10mb.jpg</span></div><div class="line">      <span class="comment">// 图像将从磁盘加载</span></div><div class="line">      image.display();<span class="comment">//Displaying test_10mb.jpg</span></div><div class="line">      System.out.println(<span class="string">""</span>);</div><div class="line">      <span class="comment">// 图像不需要从磁盘加载</span></div><div class="line">      image.display();<span class="comment">//Displaying test_10mb.jpg</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><ul><li>java.lang.reflect.Proxy:生成动态代理类和对象；</li><li>java.lang.reflect.InvocationHandler（处理器接口）:可以通过invoke方法实现对真实角色的代理访问。</li><li>每次通过Proxy生成的代理类对象都要指定对应的处理器对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// InvocationHandler接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line">        <span class="keyword">throws</span> Throwable;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>proxy表示被代理的对象 </li><li>method表示被代理对象的方法 </li><li>args表示方法的参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Proxy类的newProxyInstance方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></div></pre></td></tr></table></figure><ul><li>loader表示委托类的类加载器 </li><li>interfaces表示委托类实现的接口（这就说明委托类一定要实现了接口才能使用） </li><li>h表示InvocationHandler接口的子实例，也就是动态代理类的实例</li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sellBooks</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">speak</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="真实对象"><a href="#真实对象" class="headerlink" title="真实对象"></a>真实对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sellBooks</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"卖书"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">speak</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"说话"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"张三"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="处理器对象"><a href="#处理器对象" class="headerlink" title="处理器对象"></a>处理器对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 定义一个处理器</div><div class="line"> * <span class="doctag">@author</span> gnehcgnaw</div><div class="line"> * <span class="doctag">@date</span> 2018/11/5 19:26</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 因为需要处理真实角色，所以要把真实角色传进来</div><div class="line">     */</div><div class="line">    Subject realSubject ;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Subject realSubject)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.realSubject = realSubject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> proxy    代理类</div><div class="line">     * <span class="doctag">@param</span> method    正在调用的方法</div><div class="line">     * <span class="doctag">@param</span> args      方法的参数</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> Throwable</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"调用代理类"</span>);</div><div class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">"sellBooks"</span>))&#123;</div><div class="line">            <span class="keyword">int</span> invoke = (<span class="keyword">int</span>)method.invoke(realSubject, args);</div><div class="line">            System.out.println(<span class="string">"调用的是卖书的方法"</span>);</div><div class="line">            <span class="keyword">return</span> invoke ;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            String string = (String) method.invoke(realSubject,args) ;</div><div class="line">            System.out.println(<span class="string">"调用的是说话的方法"</span>);</div><div class="line">            <span class="keyword">return</span>  string ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="调用端"><a href="#调用端" class="headerlink" title="调用端"></a>调用端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 调用类</div><div class="line"> * <span class="doctag">@author</span> gnehcgnaw</div><div class="line"> * <span class="doctag">@date</span> 2018/11/7 20:26</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//真实对象</span></div><div class="line">        Subject realSubject =  <span class="keyword">new</span> RealSubject();</div><div class="line"></div><div class="line">        MyInvocationHandler myInvocationHandler = <span class="keyword">new</span> MyInvocationHandler(realSubject);</div><div class="line">        <span class="comment">//代理对象</span></div><div class="line">        Subject proxyClass = (Subject)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> Class[]&#123;Subject.class&#125;, myInvocationHandler);</div><div class="line"></div><div class="line">        proxyClass.sellBooks();</div><div class="line"></div><div class="line">        proxyClass.speak();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object target;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 绑定一个委托对象并获得一个代理类对象</div><div class="line">     * <span class="doctag">@param</span> target [description]</div><div class="line">     * <span class="doctag">@return</span> [description]</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">        <span class="comment">// 取得代理对象</span></div><div class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), </div><div class="line">           <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">//这个方法并不是我们自己去调用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line">       <span class="keyword">throws</span> Throwable &#123;</div><div class="line">        System.out.println(<span class="string">"该客户是否是vip客户"</span>);</div><div class="line">        <span class="comment">// 执行委托类的方法</span></div><div class="line">        Object result = method.invoke(target,args);</div><div class="line">        System.out.println(<span class="string">"该客户买车完成"</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        CarProxy cp = <span class="keyword">new</span> CarProxy();</div><div class="line">        <span class="comment">// 传入一个实现了该接口的实例就行</span></div><div class="line">        Car car = (Car)cp.bind(<span class="keyword">new</span> CarImp1());</div><div class="line">        <span class="comment">// Car car = (Car)cp.bind(new CarImp2());</span></div><div class="line">        car.buyCar();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h3><p>Cglib动态代理是针对代理的类，动态生成一个子类，然后子类覆盖代理类中的方法，如果是private或是final类修饰的方法，则不会被重写。（方法拦截技术拦截所有父类方法的调用）</p><p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。</p><p>CGLIB作为一个开源项目，其代码托管在github，地址为：<a href="https://github.com/cglib/cglib" target="_blank" rel="external">https://github.com/cglib/cglib</a></p><h4 id="需要代理的类"><a href="#需要代理的类" class="headerlink" title="需要代理的类"></a>需要代理的类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> </span>&#123;</div><div class="line">    <span class="comment">// 可以被代理</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"工程师正在吃饭"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// final 方法不会被生成的字类覆盖</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"工程师正在工作"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// private 方法不会被生成的字类覆盖</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"this engineer is playing game"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Cglib代理类"><a href="#Cglib代理类" class="headerlink" title="Cglib代理类"></a>Cglib代理类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object target;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxy</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"###   before invocation"</span>);</div><div class="line">        Object result = method.invoke(target, objects);</div><div class="line">        System.out.println(<span class="string">"###   end invocation"</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">        <span class="comment">// 设置需要代理的对象</span></div><div class="line">        enhancer.setSuperclass(target.getClass());</div><div class="line">        <span class="comment">// 设置代理人</span></div><div class="line">        enhancer.setCallback(<span class="keyword">new</span> CglibProxy(target));</div><div class="line">        <span class="keyword">return</span> enhancer.create();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMainTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 生成 Cglib 代理类</span></div><div class="line">        Engineer engineerProxy = (Engineer) CglibProxy.getProxy(<span class="keyword">new</span> Engineer());</div><div class="line">        <span class="comment">// 调用相关方法</span></div><div class="line">        engineerProxy.eat();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###   before invocation</div><div class="line">工程师正在吃饭</div><div class="line">###   end invocation</div></pre></td></tr></table></figure><h4 id="优化实现-1"><a href="#优化实现-1" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获得代理类</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置创建子类的类</span></div><div class="line">        enhancer.setSuperclass(c);</div><div class="line">        <span class="comment">// 回调方法</span></div><div class="line">        enhancer.setCallback(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">// 返回代理对象</span></div><div class="line">        <span class="keyword">return</span> enhancer.create();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 拦截所有目标方法的调用</div><div class="line">     * obj 目标类的实例</div><div class="line">     * m 目标方法的反射对象</div><div class="line">     * args 方法的参数</div><div class="line">     * proxy 代理类的实例</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method m, Object[] args,</span></span></div><div class="line">       MethodProxy proxy) <span class="keyword">throws</span> Throwable &#123;</div><div class="line">        System.out.println(<span class="string">"火车启动啦！！"</span>);</div><div class="line">        <span class="comment">// 代理类调用父类的方法</span></div><div class="line">        Object result = proxy.invokeSuper(obj, args);</div><div class="line">        System.out.println(<span class="string">"火车停止啦！！"</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        CglibProxy proxy = <span class="keyword">new</span> CglibProxy();</div><div class="line">        Train t = (Train)proxy.getProxy(Train.class);</div><div class="line">        t.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>委托模式</title>
      <link href="/2019/04/22/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/22/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h3><ul><li>在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。</li><li>委托模式使得我们可以用聚合来替代继承。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPrinter</span> </span>&#123; <span class="comment">// the "delegate"</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </div><div class="line">System.out.print(<span class="string">"something"</span>); </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123; <span class="comment">// the "delegator"</span></div><div class="line">RealPrinter p = <span class="keyword">new</span> RealPrinter(); <span class="comment">// create the delegate </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </div><div class="line">p.print(); <span class="comment">// delegation</span></div><div class="line">&#125; </div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"><span class="comment">// to the outside world it looks like Printer actually prints.</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Printer printer = <span class="keyword">new</span> Printer();</div><div class="line">printer.print();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><h3 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a>Demo2</h3><ul><li>通过使用接口，委托可以做到类型安全并且更加灵活。</li><li>委托的缺点是需要更多的代码。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">I</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"A: doing f()"</span>); &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"A: doing g()"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"B: doing f()"</span>); &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"B: doing g()"</span>); &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I</span> </span>&#123;</div><div class="line"><span class="comment">// delegation</span></div><div class="line">I i = <span class="keyword">new</span> A();</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; i.f(); &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; i.g(); &#125;</div><div class="line"> </div><div class="line"><span class="comment">// normal attributes</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toA</span><span class="params">()</span> </span>&#123; i = <span class="keyword">new</span> A(); &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toB</span><span class="params">()</span> </span>&#123; i = <span class="keyword">new</span> B(); &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//类别C可以委托类别A或类别B，类别C拥有方法使自己可以在类别A或类别B间选择。</span></div><div class="line"><span class="comment">//因为类别A或类别B必须实现接口I规定的方法，所以在这里委托是类型安全的。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">C c = <span class="keyword">new</span> C();</div><div class="line">c.f();     <span class="comment">// output: A: doing f()</span></div><div class="line">c.g();     <span class="comment">// output: A: doing g()</span></div><div class="line">c.toB();</div><div class="line">c.f();     <span class="comment">// output: B: doing f()</span></div><div class="line">c.g();     <span class="comment">// output: B: doing g()</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring5：容器的基本实现</title>
      <link href="/2019/03/13/Spring5%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/03/13/Spring5%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="容器基本用法"><a href="#容器基本用法" class="headerlink" title="容器基本用法"></a>容器基本用法</h2><p><strong>bean是Spring 中最核心的东西，Spring就像是个大水桶，而bean就像是容器中的水。</strong></p><h3 id="bean定义"><a href="#bean定义" class="headerlink" title="bean定义"></a>bean定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestBean</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> String testStr = <span class="string">"testStr"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTestStr</span> <span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> testStr ;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestStr</span><span class="params">(String testStr)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.testStr = testStr ;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><h3 id="bean配置"><a href="#bean配置" class="headerlink" title="bean配置"></a>bean配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">xml</span> <span class="attr">version</span>=<span class="string">"1.0"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>?&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.Springframework.org/schema/beans"</span></span></div><div class="line"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.Springframework.org/schema/beans</span></div><div class="line">http://www.Spring:ramework.org/schema/beεns/Spring-beans.xsd"&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myTestBean"</span> <span class="attr">class</span>=<span class="string">"bean.MyTestBean"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleLoad</span><span class="params">()</span> </span>&#123;</div><div class="line">BeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">"beanFactoryTest.xml"</span>));</div><div class="line">MyTestBean bean = (MyTestBean)bf.getBean(<span class="string">"myTestBean"</span>);</div><div class="line">assertEquals(<span class="string">"testStr"</span>, bean.getTestStr());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2><ol><li>读取配置文件beanFactoryTest.xml。</li><li>根据beanFactoryTest.xml中的配置找到对应的类的配置，并实例化。</li><li>调用实例化后的实例。</li></ol><p><img src="/images/Spring/2019031407.png" alt=""></p><ul><li>ConfigReader：用于读取及验证配置文件，然后放置在内存中。</li><li>ReflectionUtil：用于根据配置文件中的配置进行反射实例化。</li><li>App：用于完成整个逻辑的串联。</li></ul><h2 id="Spring结构组成"><a href="#Spring结构组成" class="headerlink" title="Spring结构组成"></a>Spring结构组成</h2><h3 id="beans包的层级结构"><a href="#beans包的层级结构" class="headerlink" title="beans包的层级结构"></a>beans包的层级结构</h3><p><img src="/images/Spring/2019031408.png" alt=""></p><ul><li>src/main/java用于展现Spring的主要逻辑。</li><li>src/main/resources用于存放系统的配置文件。</li><li>src/test/java用于对主要逻辑进行单元测试。</li><li>src/test/resources用于存放测试用的配置文件。</li></ul><h3 id="核心类介绍"><a href="#核心类介绍" class="headerlink" title="核心类介绍"></a>核心类介绍</h3><h4 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h4><p>DefaultListableBeanFactory是整个bean加载的核心部分，是Spring注册及加载bean的默认实现.</p><h4 id="XmlBeanFactory"><a href="#XmlBeanFactory" class="headerlink" title="XmlBeanFactory"></a>XmlBeanFactory</h4><p>XmlBeanFactory继承自DefaultListableBeanFactory，主要用于从XML文档中读取BeanDefinition，对于注册及获取bean都是使用从父类DefaultListableBeanFactory继承的方法去实现。与父类不同的是，在XmlBeanFactory中使用了自定义的XML读取器XmlBeanDefinitionReader，通过XmlBeanDefinitionReader类型的reader属性对资源文件进行读取和注册，实现个性化的BeanDefinitionReader读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Deprecated</span></div><div class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"serial"</span>, <span class="string">"all"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Create a new XmlBeanFactory with the given resource,</div><div class="line"> * which must be parsable using dom.</div><div class="line"> * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</div><div class="line"> * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line"><span class="keyword">this</span>(resource, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Create a new XmlBeanFactory with the given input stream,</div><div class="line"> * which must be parsable using DOM.</div><div class="line"> * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</div><div class="line"> * <span class="doctag">@param</span> parentBeanFactory parent bean factory</div><div class="line"> * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line"><span class="keyword">super</span>(parentBeanFactory);</div><div class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="/images/Spring/2019031409.png" alt=""></p><h4 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h4><p><img src="/images/Spring/2019040701.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</div><div class="line">    <span class="comment">//2</span></div><div class="line">    <span class="keyword">private</span> DocumentLoader documentLoader = <span class="keyword">new</span> DefaultDocumentLoader();</div><div class="line">    <span class="comment">//3</span></div><div class="line">    <span class="keyword">private</span> Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass =</div><div class="line">DefaultBeanDefinitionDocumentReader.class;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionReader</span>, <span class="title">EnvironmentCapable</span> </span>&#123;</div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;<span class="comment">//1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDocumentReader</span> </span>&#123;</div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="keyword">private</span> BeanDefinitionParserDelegate delegate;<span class="comment">//4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>通过继承向AbstractBeanDefinitionReader中的方法，来使用ResourLoader将资源文件路径转换为对应的Resource文件。</li><li>通过DocumentLoader对Resource 文件进行转换，将Resource 文件转换为Document文件。</li><li>通过实现接口BeanDefinitionDocumentReader的DefaultBeanDefinitionDocumentReader类对Document进行解析注册，并使用BeanDefinitionParserDelegate对Element进行解析。</li></ol><h2 id="容器实现准备"><a href="#容器实现准备" class="headerlink" title="容器实现准备"></a>容器实现准备</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">"beanFactoryTest.xml"</span>));</div></pre></td></tr></table></figure><p>首先调用ClassPathResource的构造函数来构造Resource资源文件的实例对象，后续的资源处理就可以用Resource提供的各种服务来操作了，有了Resource后就可以进行XmlBeanFactory的初始化了。</p><h3 id="配置文件封装"><a href="#配置文件封装" class="headerlink" title="配置文件封装"></a>配置文件封装</h3><p>Spring对其内部使用到的资源实现了自己的抽象结构：Resource接口封装底层资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;</div><div class="line"><span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> exists();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function">URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function"><span class="keyword">default</span> ReadableByteChannel <span class="title">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">return</span> Channels.newChannel(getInputStream());</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="meta">@Nullable</span></div><div class="line"><span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</div><div class="line"><span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对不同来源的资源文件都有相应的Resource实现：文件(FileSystemResource)、Classpath资源(ClassPathResource)、URL资源(UrlResource)、InputStream资源(InputStreamResource)、Byte数组(ByteArrayResource)等。</p><p><img src="/images/Spring/2019040801.png" alt=""></p><p>在日常开发工作中，资源文件的加载可以直接使用Spring提供的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"beanFactoryTest.xml"</span>);</div><div class="line">InputStream inputStream = resource.getInputStream();</div></pre></td></tr></table></figure><p>Resource及其子类为我们提供了诸多特性，方便可以对所有资源文件进行统一处理。但实现非常简单，以getInputStream为例：</p><h4 id="ClassPathResource-java"><a href="#ClassPathResource-java" class="headerlink" title="ClassPathResource.java"></a>ClassPathResource.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathResource</span><span class="params">(String path)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>(path, (ClassLoader) <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathResource</span><span class="params">(String path, @Nullable ClassLoader classLoader)</span> </span>&#123;</div><div class="line">Assert.notNull(path, <span class="string">"Path must not be null"</span>);</div><div class="line">String pathToUse = StringUtils.cleanPath(path);</div><div class="line"><span class="keyword">if</span> (pathToUse.startsWith(<span class="string">"/"</span>)) &#123;</div><div class="line">pathToUse = pathToUse.substring(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>.path = pathToUse;</div><div class="line"><span class="keyword">this</span>.classLoader = (classLoader != <span class="keyword">null</span> ? classLoader : ClassUtils.getDefaultClassLoader());</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathResource</span><span class="params">(String path, @Nullable Class&lt;?&gt; clazz)</span> </span>&#123;</div><div class="line">Assert.notNull(path, <span class="string">"Path must not be null"</span>);</div><div class="line"><span class="keyword">this</span>.path = StringUtils.cleanPath(path);</div><div class="line"><span class="keyword">this</span>.clazz = clazz;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Deprecated</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassPathResource</span><span class="params">(String path, @Nullable ClassLoader classLoader, @Nullable Class&lt;?&gt; clazz)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.path = StringUtils.cleanPath(path);</div><div class="line"><span class="keyword">this</span>.classLoader = classLoader;</div><div class="line"><span class="keyword">this</span>.clazz = clazz;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    InputStream is;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.clazz != <span class="keyword">null</span>) &#123;</div><div class="line">    is = <span class="keyword">this</span>.clazz.getResourceAsStream(<span class="keyword">this</span>.path);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.classLoader != <span class="keyword">null</span>) &#123;</div><div class="line">    is = <span class="keyword">this</span>.classLoader.getResourceAsStream(<span class="keyword">this</span>.path);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">    is = ClassLoader.getSystemResourceAsStream(<span class="keyword">this</span>.path);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(getDescription() + <span class="string">" cannot be opened because it does not exist"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="FileSystemResource-java"><a href="#FileSystemResource-java" class="headerlink" title="FileSystemResource.java"></a>FileSystemResource.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">return</span> Files.newInputStream(<span class="keyword">this</span>.filePath);</div><div class="line">&#125;<span class="keyword">catch</span> (NoSuchFileException ex) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(ex.getMessage());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="传入配置资源"><a href="#传入配置资源" class="headerlink" title="传入配置资源"></a>传入配置资源</h3><p><strong>XmlBeanFactory.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line"><span class="keyword">this</span>(resource, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//parentBeanFactory为父类BeanFactory用于factory合并，可以为空</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line"><span class="keyword">super</span>(parentBeanFactory);</div><div class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(resource);<span class="comment">//加载资源的真正实现</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在加载数据前有一个调用父类构造函数初始化的过程super(parentBeanFactory)，跟踪代码到父类DefaultListableBeanFactory的父类AbstractAutowireCapableBeanFactory的构造函数中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultListableBeanFactory</span><span class="params">(@Nullable BeanFactory parentBeanFactory)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>(parentBeanFactory);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>();</div><div class="line">ignoreDependencyInterface(BeanNameAware.class);</div><div class="line">ignoreDependencyInterface(BeanFactoryAware.class);</div><div class="line">ignoreDependencyInterface(BeanClassLoaderAware.class);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">(@Nullable BeanFactory parentBeanFactory)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>();</div><div class="line">setParentBeanFactory(parentBeanFactory);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Ignore the given dependency interface for autowiring.</div><div class="line"> * &lt;p&gt;This will typically be used by application contexts to register</div><div class="line"> * dependencies that are resolved in other ways, like BeanFactory through</div><div class="line"> * BeanFactoryAware or ApplicationContext through ApplicationContextAware.</div><div class="line"> * &lt;p&gt;By default, only the BeanFactoryAware interface is ignored.</div><div class="line"> * For further types to ignore, invoke this method for each type.</div><div class="line"> * <span class="doctag">@see</span> org.springframework.beans.factory.BeanFactoryAware</div><div class="line"> * <span class="doctag">@see</span> org.springframework.context.ApplicationContextAware</div><div class="line"> * 自动装配时忽略给定的依赖接口，典型应用是通过其他方式解析Application上下文</div><div class="line"> * 注册依赖，类似于BeanFactory通过BeanFactoryAware进行注入或者</div><div class="line"> * ApplicationContext通过ApplicationContextAware进行注入。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ignoreDependencyInterface</span><span class="params">(Class&lt;?&gt; ifc)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.ignoredDependencyInterfaces.add(ifc);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里有必要提及ignoreDependencylnterface方法。ignoreDependencyInterface的主要功能是忽略给定接口的向动装配功能。</p><p>举例来说，当A中有属性B，那么当Spring在获取A的Bean的时候如果其属性B还没有初始化，那么Spring会自动初始化B，这也是Spring中提供的一个重要特性。但是，某些情况下，B不会被初始化，其中的一种情况就是B实现了BeanNameAware接口。</p><h3 id="资源转换处理"><a href="#资源转换处理" class="headerlink" title="资源转换处理"></a>资源转换处理</h3><p>（1）XmlBeanFactory构造函数中调用XmlBeanDefinitionReader类型的reader属性提供的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(resource);<span class="comment">//整个资源加载的切入点</span></div></pre></td></tr></table></figure><p>（2）封装资源文件。考虑到Resource可能存在编码要求的情况，当进入XmlBeanDefinitionReader后首先对参数Resource使用EncodedResource类进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line"><span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>EncodeResource主要用于对资源文件的编码进行处理，主要逻辑体现在getReader()方法中，当设置了编码属性的时候Spring会使用相应的编码作为输入流的编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Reader <span class="title">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.charset != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> InputStreamReader(<span class="keyword">this</span>.resource.getInputStream(), <span class="keyword">this</span>.charset);</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.encoding != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> InputStreamReader(<span class="keyword">this</span>.resource.getInputStream(), <span class="keyword">this</span>.encoding);</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> InputStreamReader(<span class="keyword">this</span>.resource.getInputStream());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>（3）获取输入流。从Resource中获取对应的InputStream并构造InputSource。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">   Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</div><div class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">      logger.trace(<span class="string">"Loading XML bean definitions from "</span> + encodedResource);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//通过ThreadLocal属性来记录已经加载的资源</span></div><div class="line">   Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</div><div class="line">   <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</div><div class="line">      currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</div><div class="line">      <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">            <span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//从encodedResource中获取已经封装的Resource对象并再次从Resource中获取其中的inputStream</span></div><div class="line">      InputStream inputStream = encodedResource.getResource().getInputStream();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">         <span class="comment">//InputSource这个类并不来自于Spring，它的全路径是org.xml.sax.InputSource</span></div><div class="line">         <span class="comment">//通过SAX读取XML文件的方式来准备InputSource对象</span></div><div class="line">         InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</div><div class="line">         <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</div><div class="line">            inputSource.setEncoding(encodedResource.getEncoding());</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//真正进入逻辑核心部分</span></div><div class="line">         <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</div><div class="line">      &#125;<span class="keyword">finally</span> &#123;</div><div class="line">         <span class="comment">//关闭输入流</span></div><div class="line">         inputStream.close();</div><div class="line">      &#125;</div><div class="line">   &#125;<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">            <span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</div><div class="line">   &#125;<span class="keyword">finally</span> &#123;</div><div class="line">      currentResources.remove(encodedResource);</div><div class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</div><div class="line">         <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="容器实现核心"><a href="#容器实现核心" class="headerlink" title="容器实现核心"></a>容器实现核心</h2><p>核心处理部分doLoadBeanDefinitions(inputSource,encodedResource.getResource())主要做三件事，每一件都必不可少，在三个步骤支撑着整个Spring容器部分的实现，尤其第三步对配置文件的解析：</p><ol><li>获取对XML文件的验证模式。</li><li>加载XML文件，并得到对应的Document。</li><li>根据返回的Document注册Bean信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">//步骤1、2</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(),</div><div class="line"><span class="keyword">this</span>.errorHandler,getValidationModeForResource(resource), isNamespaceAware());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></div><div class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      Document doc = doLoadDocument(inputSource, resource);<span class="comment">//步骤1、2</span></div><div class="line">      <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);<span class="comment">//步骤3</span></div><div class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">         logger.debug(<span class="string">"Loaded "</span> + count + <span class="string">" bean definitions from "</span> + resource);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> count;</div><div class="line">   &#125;<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> ex;</div><div class="line">   &#125;<span class="keyword">catch</span> (SAXParseException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</div><div class="line">            <span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</div><div class="line">   &#125;<span class="keyword">catch</span> (SAXException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</div><div class="line">            <span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</div><div class="line">   &#125;<span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</div><div class="line">            <span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</div><div class="line">   &#125;<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</div><div class="line">            <span class="string">"IOException parsing XML document from "</span> + resource, ex);</div><div class="line">   &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</div><div class="line">            <span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="获取XML验证模式"><a href="#获取XML验证模式" class="headerlink" title="获取XML验证模式"></a>获取XML验证模式</h3><p>比较常用的XML文件的验证模式有两种：DTD和XSD</p><h4 id="DTD与XSD区别"><a href="#DTD与XSD区别" class="headerlink" title="DTD与XSD区别"></a>DTD与XSD区别</h4><p>DTD（Document Type Definition）即文档类型定义，是一种XML约束模式语言，是XML文件的验证机制，属于XML文件组成的一部分。一个DTD文档包含：元素的定义规则，元素间关系的定义规则，元素可使用的属性，可使用的实体或符号规则。通过比较XML文档和DTD文件来看文档是否符合规范。</p><p>要使用DTD验证模式时需要在XML文件头部声明，以下是在Spring中使用DTD声明方式的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE bean PUBLIC "-//Spring//DTD BEAN 2.0//EN" "http://www.Springframework.org/</span></div><div class="line">dtd/Spring-beans-2.0.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">... ...</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><p>Spring-beans-2.0.dtd部分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;!ELEMENT beans (</div><div class="line">description?,</div><div class="line">(import | alias | bean)*</div><div class="line">)&gt;</div><div class="line">&lt;!--</div><div class="line">Default values for all bean definitions. Can be overridden at</div><div class="line">the &quot;bean&quot; level. See those attribute definitions for details.</div><div class="line">--&gt;</div><div class="line">&lt;!ATTLIST beans default-lazy-init (true | false) &quot;false&quot;&gt;</div><div class="line">&lt;!ATTLIST beans default-autowire (no | byName | byType | constructor | autodetect) &quot;no&quot;&gt;</div><div class="line">&lt;!ATTLIST beans default-dependency-check (none | objects | simple | all) &quot;none&quot;&gt;</div><div class="line">&lt;!ATTLIST beans default-init-method CDATA #IMPLIED&gt;</div><div class="line">&lt;!ATTLIST beans default-destroy-method CDATA #IMPLIED&gt;</div><div class="line">&lt;!ATTLIST beans default-merge (true | false) &quot;false&quot;&gt;</div><div class="line">... ...</div></pre></td></tr></table></figure><p>XSD（XML Schemas Definition）即XML Schema语言，用来描述XML文档的结构。文档设计者可以通过XML Schema指定XML文档所允许的结构和内容，并可据此检查验证XML文档是否是有效的。XML Schema本身是符合XML语法结构的XML文档，可以用通用的XML解析器解析它。</p><p>使用XML Schema文档对XML实例文档进行检查，除了要声明名称空间外（xmlns=<a href="http://www.Srpingframework.org/schema/beans）,还必须指定该名称空间所对应的XML" target="_blank" rel="external">http://www.Srpingframework.org/schema/beans）,还必须指定该名称空间所对应的XML</a> Schema文档的存储位置，它包含两个部分，一部分是名称空间的URI，另一部分是该名称空间所标识的XML Schema文件位置或URL地址(xsi:schemaLocation=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a> <a href="http://www.Springframework.org/schema/beans/Spring-beans.xsd&quot;)。" target="_blank" rel="external">http://www.Springframework.org/schema/beans/Spring-beans.xsd&quot;)。</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.Springframework.org/schema/beans"</span></span></div><div class="line"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.Springframework.org/schema/beans</span></div><div class="line">http://www.Springframework.org/schema/beans/Spring-beans.xsd"&gt;</div><div class="line">... ...</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><p>Spring-beans-3.0.xsd部分代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">            <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></div><div class="line">            <span class="attr">targetNamespace</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.w3.org/XML/1998/namespace"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span></div><div class="line">            &lt;![CDATA[</div><div class="line">            ... ...</div><div class="line">            ]]&gt;</div><div class="line">        <span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></div><div class="line">     <span class="comment">&lt;!--  base types  --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">"identifiedType"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span></div><div class="line">                &lt;![CDATA[</div><div class="line">                ... ...</div><div class="line">                ]]&gt;</div><div class="line">            <span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span></div><div class="line">                    &lt;![CDATA[</div><div class="line">                    ... ...</div><div class="line">                    ]]&gt;</div><div class="line">                <span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></div><div class="line">    ... ...</div><div class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="验证模式的读取"><a href="#验证模式的读取" class="headerlink" title="验证模式的读取"></a>验证模式的读取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//XmlBeanDefinitionReader.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getValidationModeForResource</span><span class="params">(Resource resource)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> validationModeToUse = getValidationMode();</div><div class="line">    <span class="comment">//如果手动指定了验证模式则使用指定的验证模式</span></div><div class="line">    <span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</div><div class="line">        <span class="keyword">return</span> validationModeToUse;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果未指定则使用自动检测</span></div><div class="line">    <span class="keyword">int</span> detectedMode = detectValidationMode(resource);</div><div class="line">    <span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</div><div class="line">        <span class="keyword">return</span> detectedMode;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Hmm, we didn't get a clear indication... Let's assume XSD,</span></div><div class="line">    <span class="comment">// since apparently no DTD declaration has been found up until</span></div><div class="line">    <span class="comment">// detection stopped (before finding the document's root tag).</span></div><div class="line">    <span class="keyword">return</span> VALIDATION_XSD;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//XmlBeanDefinitionReader.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">detectValidationMode</span><span class="params">(Resource resource)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (resource.isOpen()) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">            <span class="string">"Passed-in Resource ["</span> + resource + <span class="string">"] contains an open stream: "</span> +</div><div class="line">            <span class="string">"cannot determine validation mode automatically. Either pass in a Resource "</span> +</div><div class="line">            <span class="string">"that is able to create fresh streams, or explicitly specify the validationMode "</span> +</div><div class="line">            <span class="string">"on your XmlBeanDefinitionReader instance."</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   InputStream inputStream;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      inputStream = resource.getInputStream();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">            <span class="string">"Unable to determine validation mode for ["</span> + resource + <span class="string">"]: cannot open InputStream. "</span> +</div><div class="line">            <span class="string">"Did you attempt to load directly from a SAX InputSource without specifying the "</span> +</div><div class="line">            <span class="string">"validationMode on your XmlBeanDefinitionReader instance?"</span>, ex);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.validationModeDetector.detectValidationMode(inputStream);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Unable to determine validation mode for ["</span> +</div><div class="line">            resource + <span class="string">"]: an error occurred whilst reading from the InputStream."</span>, ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//XmlValidationModeDetector.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">detectValidationMode</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">   <span class="comment">// Peek into the file to look for DOCTYPE.</span></div><div class="line">   BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">boolean</span> isDtdValidated = <span class="keyword">false</span>;</div><div class="line">      String content;</div><div class="line">      <span class="keyword">while</span> ((content = reader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">         content = consumeCommentTokens(content);</div><div class="line">         <span class="comment">//如果读取的行是空或者是注释则略过</span></div><div class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.inComment || !StringUtils.hasText(content)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//如果包含DOCTYPE，就是DTD，否则是XSD</span></div><div class="line">         <span class="keyword">if</span> (hasDoctype(content)) &#123;</div><div class="line">            isDtdValidated = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//读取到&lt;开始符号，验证模式一定会在开始符号之前</span></div><div class="line">         <span class="keyword">if</span> (hasOpeningTag(content)) &#123;</div><div class="line">            <span class="comment">// End of meaningful data...</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">catch</span> (CharConversionException ex) &#123;</div><div class="line">      <span class="comment">// Choked on some character encoding...</span></div><div class="line">      <span class="comment">// Leave the decision up to the caller.</span></div><div class="line">      <span class="keyword">return</span> VALIDATION_AUTO;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">finally</span> &#123;</div><div class="line">      reader.close();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="获取Document"><a href="#获取Document" class="headerlink" title="获取Document"></a>获取Document</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> DocumentLoader documentLoader = <span class="keyword">new</span> DefaultDocumentLoader();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</div><div class="line">         getValidationModeForResource(resource), isNamespaceAware());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>获取了XML的验证模式后，就开始进行Document加载，同样XmlBeanFactoryReader类将文档读取的任务委托给了DocumentLoader去执行，这里的DocumentLoader是个接口，真正调用的是DefaultDocumentLoader：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDocumentLoader</span> <span class="keyword">implements</span> <span class="title">DocumentLoader</span> </span>&#123;</div><div class="line">    ... ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></div><div class="line">          ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware) <span class="keyword">throws</span> Exception &#123;</div><div class="line">       <span class="comment">//通过SAX解析XML文档</span></div><div class="line">       <span class="comment">//1.创建DocumentBuilderFactory</span></div><div class="line">       DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</div><div class="line">       <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">          logger.trace(<span class="string">"Using JAXP provider ["</span> + factory.getClass().getName() + <span class="string">"]"</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">//2.通过DocumentBuilderFactory创建DocumentBuilder</span></div><div class="line">       DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</div><div class="line">       <span class="comment">//3.解析inputSource来返回Document对象</span></div><div class="line">       <span class="keyword">return</span> builder.parse(inputSource);</div><div class="line">    &#125;</div><div class="line">    ... ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="EntityResolver用法"><a href="#EntityResolver用法" class="headerlink" title="EntityResolver用法"></a>EntityResolver用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//XmlBeanDefinitionReader.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> EntityResolver <span class="title">getEntityResolver</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.entityResolver == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// Determine default EntityResolver to use.</span></div><div class="line">      ResourceLoader resourceLoader = getResourceLoader();</div><div class="line">      <span class="keyword">if</span> (resourceLoader != <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">this</span>.entityResolver = <span class="keyword">new</span> ResourceEntityResolver(resourceLoader);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">this</span>.entityResolver = <span class="keyword">new</span> DelegatingEntityResolver(getBeanClassLoader());</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.entityResolver;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于解析一个XML，SAX首先读取该XML文档上的声明，根据声明去寻找相应的DTD定义，以便对文档进行一个验证。默认通过网络（声明的DTD的URI地址）来下载相应的DTD声明进行认证。下载是一个漫长的过程，当网络中断或不可用时，会因为相应DTD声明没有被找到而报错。</p><p>EntityResolver的作用是项目本身就可以提供一个寻找DTD声明的方法，即由程序来实现寻找DTD声明的过程，比如我们将DTD文件放到项目中某处，在实现时直接将此文档读取并返回给SAX即可。这样就避免了通过网络来寻找相应的声明。</p><p>官方说明：如果SAX应用程序需要实现自定义处理外部实体，则必须实现EntityResolver接口并使用setEntityResolver方法向SAX驱动器注册一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xml.sax;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EntityResolver</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> InputSource <span class="title">resolveEntity</span> <span class="params">(String publicId,String systemId)</span></span></div><div class="line">        <span class="keyword">throws</span> SAXException, IOException;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>resolveEntity方法接收两个参数publicId和systemId，并返回一个inputSource对象。</p><p>举例：</p><p>1.解析验证模式未XSD的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.Springframework.org/schema/beans"</span></span></div><div class="line"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.Springframework.org/schema/beans</span></div><div class="line">http://www.Springframework.org/schema/beans/Spring-beans.xsd"&gt;</div><div class="line">... ...</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><p>读取到以下两个参数：</p><ul><li>publicId：null</li><li>systemId：<a href="http://www.springframework.org/schema/beans/Spring-beans.xsd" target="_blank" rel="external">http://www.springframework.org/schema/beans/Spring-beans.xsd</a></li></ul><p>2.解析验证模式为DTD的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE bean PUBLIC "-//Spring//DTD BEAN 2.0//EN" "http://www.Springframework.org/</span></div><div class="line">dtd/Spring-beans-2.0.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">... ...</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><p>读取到以下两个参数：</p><ul><li>publicId：-//Spring//DTD BEAN 2.0//EN</li><li>systemId：<a href="http://www.springframework.org/dtd/Spring-beans-2.0.dtd" target="_blank" rel="external">http://www.springframework.org/dtd/Spring-beans-2.0.dtd</a></li></ul><p>Spring中使用DelegatingEntityResolver类为EntityResolver的实现类，将声明URL转换为自己工程里对应的地址文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//DelegatingEntityResolver.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="meta">@Nullable</span></div><div class="line"><span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(String publicId, @Nullable String systemId)</span> <span class="keyword">throws</span> SAXException, IOException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (systemId != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (systemId.endsWith(DTD_SUFFIX)) &#123;</div><div class="line">         <span class="comment">//如果是dtd从这里解析</span></div><div class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.dtdResolver.resolveEntity(publicId, systemId);</div><div class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (systemId.endsWith(XSD_SUFFIX)) &#123;</div><div class="line">         <span class="comment">//通过调用META-INF/Spring.schemas解析</span></div><div class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.schemaResolver.resolveEntity(publicId, systemId);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeansDtdResolver</span> <span class="keyword">implements</span> <span class="title">EntityResolver</span> </span>&#123;</div><div class="line">    ... ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(String publicId, @Nullable String systemId)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">       <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">          logger.trace(<span class="string">"Trying to resolve XML entity with public ID ["</span> + publicId +</div><div class="line">                <span class="string">"] and system ID ["</span> + systemId + <span class="string">"]"</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (systemId != <span class="keyword">null</span> &amp;&amp; systemId.endsWith(DTD_EXTENSION)) &#123;</div><div class="line">          <span class="keyword">int</span> lastPathSeparator = systemId.lastIndexOf(<span class="string">'/'</span>);</div><div class="line">          <span class="keyword">int</span> dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator);</div><div class="line">          <span class="keyword">if</span> (dtdNameStart != -<span class="number">1</span>) &#123;</div><div class="line">             String dtdFile = DTD_NAME + DTD_EXTENSION;</div><div class="line">             <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">                logger.trace(<span class="string">"Trying to locate ["</span> + dtdFile + <span class="string">"] in Spring jar on classpath"</span>);</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">try</span> &#123;</div><div class="line">                Resource resource = <span class="keyword">new</span> ClassPathResource(dtdFile, getClass());</div><div class="line">                InputSource source = <span class="keyword">new</span> InputSource(resource.getInputStream());</div><div class="line">                source.setPublicId(publicId);</div><div class="line">                source.setSystemId(systemId);</div><div class="line">                <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">                   logger.trace(<span class="string">"Found beans DTD ["</span> + systemId + <span class="string">"] in classpath: "</span> + dtdFile);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> source;</div><div class="line">             &#125;<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">                   logger.debug(<span class="string">"Could not resolve beans DTD ["</span> + systemId + <span class="string">"]: not found in classpath"</span>, ex);</div><div class="line">                &#125;</div><div class="line">             &#125;</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// Fall back to the parser's default behavior.</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    ... ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="解析注册"><a href="#解析注册" class="headerlink" title="解析注册"></a>解析注册</h3><p>当把文件转换为Document后，根据返回的Document注册Bean信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass =</div><div class="line">DefaultBeanDefinitionDocumentReader.class;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">       <span class="comment">//使用DefaultBeanDefinitionDocumentReader实例化BeanDefinitionDocumentReader</span></div><div class="line">       BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</div><div class="line">       <span class="comment">//在实例化BeanDefinitionReader时会将BeanDefinitionRegistry传入，</span></div><div class="line">       <span class="comment">//默认使用继承自DefaultListableBeanFactory的子类</span></div><div class="line">       <span class="comment">//记录统计前BeanDefinition的加载个数</span></div><div class="line">       <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</div><div class="line">       <span class="comment">//加载及注册bean</span></div><div class="line">       documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</div><div class="line">       <span class="comment">//记录本次加载的BeanDefinition个数</span></div><div class="line">       <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDocumentReader</span></span>&#123;</div><div class="line">    ... ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.readerContext = readerContext;</div><div class="line">       <span class="comment">//提取文档元素，将其作为参数注册BeanDefinition</span></div><div class="line">       doRegisterBeanDefinitions(doc.getDocumentElement());</div><div class="line">    &#125;</div><div class="line">    ... ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>doRegisterBeanDefinitions是核心逻辑的底部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDocumentReader</span></span>&#123;</div><div class="line">    ... ...</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</div><div class="line">       <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></div><div class="line">       <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></div><div class="line">       <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></div><div class="line">       <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></div><div class="line">       <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></div><div class="line">       <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></div><div class="line">       <span class="comment">//委托模式，通过已有父委托对象创建新的子委托对象去执行操作</span></div><div class="line">       BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</div><div class="line">       <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</div><div class="line">          <span class="comment">//处理profile属性，步骤1.2.3</span></div><div class="line">          <span class="comment">//1.获取beans节点是否定义了profile属性</span></div><div class="line">          String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</div><div class="line">          <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</div><div class="line">             <span class="comment">//2.因为profile是可以同时指定多个的，需要拆分</span></div><div class="line">             String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</div><div class="line">                   profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</div><div class="line">             <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></div><div class="line">             <span class="comment">// in XML config. See SPR-12458 for details.</span></div><div class="line">             <span class="comment">//3.判断每个profile都是符合环境变量中所定义的，不定义就不会浪费性能去解析</span></div><div class="line">             <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</div><div class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">                   logger.debug(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</div><div class="line">                         <span class="string">"] not matching: "</span> + getReaderContext().getResource());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">             &#125;</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">//解析前处理，留给子类实现</span></div><div class="line">       preProcessXml(root);</div><div class="line">       <span class="comment">//解析注册BeanDefinition</span></div><div class="line">       parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</div><div class="line">       <span class="comment">//解析后处理，留给子类实现</span></div><div class="line">       postProcessXml(root);</div><div class="line"></div><div class="line">       <span class="comment">//最后将父委托对象重置回原引用</span></div><div class="line">       <span class="keyword">this</span>.delegate = parent;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preProcessXml</span><span class="params">(Element root)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessXml</span><span class="params">(Element root)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    ... ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>preProcessXml和postProcessXml是空实现，因为一个类要么是面向继承设计的，要么就用final修饰，在DefaultBeanDefinitionDocumentReader中并没有用final修饰，所以它是面向继承而设计的。这两个方法正是为子类而设计的，如果继承自DefaultBeanDefinitionDocumentReader的子类需要在Bean解析前后做一些处理的话，只需重写这两个方法即可（设计模式：模板方法模式）。</p><h4 id="profile属性的使用"><a href="#profile属性的使用" class="headerlink" title="profile属性的使用"></a>profile属性的使用</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.Springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.Springframework.org/schema/jdbc"</span></div><div class="line">       <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"dev"</span>&gt;</span></div><div class="line">    ... ...</div><div class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span>&gt;</span></div><div class="line">    ... ...</div><div class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><p>集成到Web环境中时，在web.xml中加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>Spring.profiles.active<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div></pre></td></tr></table></figure><p>这个特性，使我们可以在配置文件中部署两套配置来适用于生产环境和开发环境，可以方便的进行切换开发、部署环境、更换不同数据库。</p><h4 id="解析注册BeanDefinition"><a href="#解析注册BeanDefinition" class="headerlink" title="解析注册BeanDefinition"></a>解析注册BeanDefinition</h4><p>处理了profile后就开始进行XML的读取解析，parseBeanDefinitions(root, this.delegate);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDocumentReader</span> </span>&#123;</div><div class="line">    ... ...</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</div><div class="line">       <span class="comment">//对beans的处理&lt;bean id="test" class="test.TestBean"/&gt;</span></div><div class="line">       <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</div><div class="line">          NodeList nl = root.getChildNodes();</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</div><div class="line">             Node node = nl.item(i);</div><div class="line">             <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</div><div class="line">                Element ele = (Element) node;</div><div class="line">                <span class="comment">//判断是否默认命名空间还是自定义的命名空间</span></div><div class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</div><div class="line">                   <span class="comment">//如果采用默认命名空间的根节点或子节点</span></div><div class="line">                   parseDefaultElement(ele, delegate);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="comment">//如果是自定义的，需要实现一些接口及配置</span></div><div class="line">                   delegate.parseCustomElement(ele);</div><div class="line">                &#125;</div><div class="line">             &#125;</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//&lt;tx:annotation-driven/&gt;</span></div><div class="line">          delegate.parseCustomElement(root);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    ... ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionParserDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEANS_NAMESPACE_URI = <span class="string">"http://www.springframework.org/schema/beans"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//3.true:默认，false:自定义</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDefaultNamespace</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> isDefaultNamespace(getNamespaceURI(node));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNamespaceURI</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> node.getNamespaceURI();<span class="comment">//1.获取命名空间</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//2.与静态常量直接比对</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDefaultNamespace</span><span class="params">(@Nullable String namespaceUri)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> (!StringUtils.hasLength(namespaceUri) || BEANS_NAMESPACE_URI.equals(namespaceUri));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>关于默认标签解析与自定义标签解析，重要内容见下篇。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础网络配置</title>
      <link href="/2019/01/10/Linux%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/01/10/Linux%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="设置IP、子网、网关"><a href="#设置IP、子网、网关" class="headerlink" title="设置IP、子网、网关"></a>设置IP、子网、网关</h3><p><strong>vi /etc/sysconfig/network-scripts/ifcfg-eth0</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">##删除UUID和MAC地址 </div><div class="line">ONBOOT=yes </div><div class="line">BOOTPROTO=static </div><div class="line">IPADDR=192.168.9.101 </div><div class="line">NETMASK=255.255.255.0 </div><div class="line">GATEWAY=192.168.9.2 </div><div class="line">DNS1=1921.68.9.2</div></pre></td></tr></table></figure><h3 id="重启网络服务和网卡"><a href="#重启网络服务和网卡" class="headerlink" title="重启网络服务和网卡"></a>重启网络服务和网卡</h3><p><strong>service network restart</strong></p><h3 id="配置主机名"><a href="#配置主机名" class="headerlink" title="配置主机名"></a>配置主机名</h3><p><strong>vi /etc/sysconfig/network</strong></p><a id="more"></a><h3 id="配置hosts"><a href="#配置hosts" class="headerlink" title="配置hosts"></a>配置hosts</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vi /etc/hosts   ##LINUX</div><div class="line">c:/windows/system32/drivers/etc/hosts   ##WINDOWS</div></pre></td></tr></table></figure><h3 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h3><p><strong>init 6</strong></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>rm -fr /etc/udev/rules.d/70-persistent-net.rules</strong></p><p><strong>为什么要删除70-persistent-net.rules</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">VM：</div><div class="line">默认维护，每一台克隆，或，新建的虚拟机，MAC地址不重复</div><div class="line"></div><div class="line">如果虚拟机保留 /etc/udev/rules.d/70-persistent-net.rules这个文件，在通过该虚拟机克隆的时候:</div><div class="line">1.文件被带到新的虚拟机中</div><div class="line">2.vm变更了新的虚拟机的mac地址</div><div class="line">so：新机器不能使用eth0接口</div><div class="line">你配置的/etc/sysconfig/network-scripts/ifcfg-eth0就不能应用</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用存储过程动态同步表数据</title>
      <link href="/2019/01/08/%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%8A%A8%E6%80%81%E5%90%8C%E6%AD%A5%E8%A1%A8%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/01/08/%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%8A%A8%E6%80%81%E5%90%8C%E6%AD%A5%E8%A1%A8%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">CREATE OR REPLACE</div><div class="line">PROCEDURE SYNFINANCIALDATA</div><div class="line">AS</div><div class="line">COUNTT NUMBER;</div><div class="line">BEGIN</div><div class="line"></div><div class="line">-----------------------1.TESTTABLE01数据同步------------------------</div><div class="line">BEGIN</div><div class="line">SELECT COUNT(*) INTO COUNTT FROM TABS WHERE TABLE_NAME=&apos;TESTTABLE01&apos; || TO_CHAR(SYSDATE,&apos;YYYY&apos;);</div><div class="line">IF(COUNTT=0) THEN</div><div class="line">EXECUTE IMMEDIATE &apos;CREATE TABLE TESTTABLE01&apos; || TO_CHAR(SYSDATE,&apos;YYYY&apos;) || &apos; AS SELECT * FROM TESTTABLE WHERE 1=2&apos;;</div><div class="line">END IF;</div><div class="line">EXECUTE IMMEDIATE &apos;DELETE FROM TESTTABLE01&apos; || TO_CHAR(SYSDATE,&apos;YYYY&apos;);</div><div class="line">COMMIT;</div><div class="line">EXECUTE IMMEDIATE &apos;MERGE INTO TESTTABLE01&apos; || TO_CHAR(SYSDATE,&apos;YYYY&apos;) .....</div><div class="line">COMMIT;</div><div class="line">END;</div><div class="line">-----------------------1.TESTTABLE02数据同步------------------------</div><div class="line">BEGIN</div><div class="line">SELECT COUNT(*) INTO COUNTT FROM TABS WHERE TABLE_NAME=&apos;TESTTABLE02&apos; || TO_CHAR(SYSDATE,&apos;YYYY&apos;);</div><div class="line">IF(COUNTT=0) THEN</div><div class="line">EXECUTE IMMEDIATE &apos;CREATE TABLE TESTTABLE02&apos; || TO_CHAR(SYSDATE,&apos;YYYY&apos;) || &apos; AS SELECT * FROM TESTTABLE WHERE 1=2&apos;;</div><div class="line">END IF;</div><div class="line">EXECUTE IMMEDIATE &apos;DELETE FROM TESTTABLE02&apos; || TO_CHAR(SYSDATE,&apos;YYYY&apos;);</div><div class="line">COMMIT;</div><div class="line">EXECUTE IMMEDIATE &apos;MERGE INTO TESTTABLE02&apos; || TO_CHAR(SYSDATE,&apos;YYYY&apos;) .....</div><div class="line">COMMIT;</div><div class="line">END;</div><div class="line"></div><div class="line">END;</div></pre></td></tr></table></figure><a id="more"></a><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CALL SYNFINANCIALDATA();</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DBLINK同步远程数据</title>
      <link href="/2018/10/23/DBLINK%E5%90%8C%E6%AD%A5%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/10/23/DBLINK%E5%90%8C%E6%AD%A5%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="创建DBLINK"><a href="#创建DBLINK" class="headerlink" title="创建DBLINK"></a>创建DBLINK</h3><pre><code>create database link PMS805LINK connect to PMS805 identified by PMS805 using &apos;(DESCRIPTION =    (ADDRESS_LIST =      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.43.51)(PORT = 1521))    )    (CONNECT_DATA =      (SERVICE_NAME = orcl)    ))&apos;;select * from all_db_links;select * from LINKTEST01@PMS805LINK;select * from LINKTEST01@PMS805LINK.REGRESS.RDBMS.DEV.US.ORACLE.COM;drop database link  PMS805LINK;</code></pre><h3 id="创建表-视图-结构"><a href="#创建表-视图-结构" class="headerlink" title="创建表(视图)结构"></a>创建表(视图)结构</h3><pre><code>create table(view) LINKTEST02 as select * from LINKTEST01@PMS805LINK where 1=2;</code></pre><a id="more"></a><h3 id="准备sync-sql文件"><a href="#准备sync-sql文件" class="headerlink" title="准备sync.sql文件"></a>准备sync.sql文件</h3><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><pre><code>//适用表字段少的情况delete from LINKTEST02 b where b.ID not in (select c.ID from LINKTEST02 c inner join LINKTEST01@PMS805LINK d on c.ID=d.ID);merge into LINKTEST02 b using LINKTEST01@PMS805LINK k on (b.ID=k.ID) when matched then update set b.NAME=k.NAME,b.AGE=k.AGE when not matched then insert values(k.ID,k.NAME,k.AGE);commit;quit;</code></pre><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><pre><code>//适用表多、字段多的情况delete from LINKTEST02;insert into LINKTEST02 select * from LINKTEST01@PMS805LINK;commit;</code></pre><h3 id="创建bat执行脚本"><a href="#创建bat执行脚本" class="headerlink" title="创建bat执行脚本"></a>创建bat执行脚本</h3><pre><code>sqlplus PMS805/PMS805@127.0.0.1:1521/ORCL @&quot;E:\sync.sql&quot;</code></pre><h3 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h3><p><img src="/images/数据库/2018102301.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows局域网内建立Git远程仓库</title>
      <link href="/2018/10/21/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E5%BB%BA%E7%AB%8BGit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2018/10/21/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E5%BB%BA%E7%AB%8BGit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<ol><li><p>在公共服务器下创建一个空仓库</p><p>1).创建一个文件夹，如public.git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir public.git</div></pre></td></tr></table></figure><p>2).进入该文件夹，建立裸仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git  --bare init</div></pre></td></tr></table></figure></li><li><p>设置网络访问权限</p><p>1).设置 public.git 为共享文件夹</p><p>2).确认在本机文件管理器中通过“ \IP地址\共享文件夹名称 ”的形式可以访问到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">注意： 共享文件夹名称可以与文件夹名称不同，git访问时，应该使用右斜杠 /</div></pre></td></tr></table></figure></li><li><p>在本机设置远程库</p><a id="more"></a><p>1).git remote add [name] //IP地址/共享文件夹名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   [name] 可以任意起名 如 origin</div><div class="line">利用 git remote 查看一下设置远程库是否成功，一般不会有什么问题</div></pre></td></tr></table></figure><p>2).进入本地库，将本地代码push到远程公共库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push [name]</div></pre></td></tr></table></figure></li></ol><p>项目组其他成员在自己的机器上，参照步骤3设置远程库，大家就可以协助工作了。 </p><p>转载自：<a href="https://blog.csdn.net/cnbizz/article/details/80233410" target="_blank" rel="external">https://blog.csdn.net/cnbizz/article/details/80233410</a></p><p>其他常用协作语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">1.git remote add 自定义的远程版本库名 版本库地址</div><div class="line">  git remote add orgin_local ssh://username@ip:port/repository.git</div><div class="line">2.git pull 远程版本库名 分支名</div><div class="line">  git pull orgin_local project-pms-1.0-dev</div><div class="line">3.git push 远程版本库名 分支名</div><div class="line">  git push orgin_local project-pms-1.0-dev</div><div class="line"></div><div class="line"># 通过远程库初始化本地仓库（方法一）</div><div class="line">git init</div><div class="line">git remote add orgin_local ssh://username@ip:port/repository.git</div><div class="line">git fetch orgin_local project-pms-1.0-dev</div><div class="line">git checkout -b local_pms orgin_local/project-pms-1.0-dev</div><div class="line"></div><div class="line"># 通过远程库初始化本地仓库（方法二）</div><div class="line">git clone ssh://username@ip:port/repository.git</div><div class="line">git checkout -b local_pms origin/project-pms-1.0-dev</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle运维常用操作</title>
      <link href="/2018/10/21/Oracle%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/10/21/Oracle%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sqlplus /nolog</div><div class="line">conn /as sysdba</div><div class="line">附：</div><div class="line">shut immediate; 关机</div><div class="line">startup; 启动</div></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">create tablespace PMSAlex datafile &apos;E:/AlexPMS/tablespace/PMSAlex.DBF&apos; size 100m autoextend on next 20m maxsize 4096m extent management local;</div><div class="line">create tablespace PMSAlex datafile &apos;E:/AlexPMS/tablespace/PMSAlex.DBF&apos; size 500m autoextend on next 50m maxsize unlimited;</div><div class="line">create user PMSAlex identified by PMSAlex default tablespace PMSAlex; 新建用户</div><div class="line">grant connect,resource,dba to PMSAlex;</div><div class="line">quit;</div><div class="line">附：</div><div class="line">drop tablespace PMSAlex including contents and datafiles; 删除表空间</div><div class="line">alter tablespace PRJAlex rename to PMSAlex; 重命名表空间</div><div class="line">alter user PMSAlex identified by u0MWVwS5; 修改连接的用户名和密码</div></pre></td></tr></table></figure><a id="more"></a><h3 id="换库"><a href="#换库" class="headerlink" title="换库"></a>换库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">drop user PMSAlex cascade; 删除用户</div><div class="line">create user PMSAlex identified by PMSAlex default tablespace PMSAlex temporary tablespace temp; 新建用户</div><div class="line">grant connect,resource,dba to prjAlex; 赋权</div><div class="line">quit; 退出</div></pre></td></tr></table></figure><h3 id="导出导入"><a href="#导出导入" class="headerlink" title="导出导入"></a>导出导入</h3><h4 id="exp-imp"><a href="#exp-imp" class="headerlink" title="exp/imp"></a>exp/imp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">exp PMSAlex/PMSAlex file=E:AlexPMS_20181021.dmp;</div><div class="line">imp PMSAlex/PMSAlex file=E:AlexPMS_20181021.dmp full=y ignore=y;</div><div class="line">exp PMSAlex/PMSAlex@192.168.8.169:1521/orcl file=E:AlexPMS_20181021.dmp;</div><div class="line">imp PMSAlex/PMSAlex@192.168.8.169:1521/orcl file=E:AlexPMS_20181021.dmp full=y ignore=y;</div></pre></td></tr></table></figure><h4 id="expdp-impdp"><a href="#expdp-impdp" class="headerlink" title="expdp/impdp"></a>expdp/impdp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">create directory expdp_dir as &apos;E:\oracle\temp_expdp&apos;;</div><div class="line">grant read,write on directory expdp_dir to PMSAlex;</div><div class="line">expdp PMSAlex/PMSAlex@orcl schemas=PMSAlex directory=expdp_dir dumpfile=AlexPMS_20181021.dmp logfile=AlexPMS_20181021.log parallel=4;</div><div class="line">create directory impdp_dir as &apos;E:\oracle\temp_impdp&apos;;</div><div class="line">impdp PMSAlex/PMSAlex@orcl schemas=PMSAlex directory=impdp_dir dumpfile=AlexPMS_20181021.dmp logfile=AlexPMS_20181021.log;</div><div class="line"># 导入时如果需要更换表空间、用户，语句后面加：</div><div class="line">REMAP_SCHEMA=oldUserName:newUserName REMAP_TABLESPACE=oldSpaceName:newSpaceName</div></pre></td></tr></table></figure><h3 id="赋权相关"><a href="#赋权相关" class="headerlink" title="赋权相关"></a>赋权相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">create user PMSAlex identified by PMSAlex;</div><div class="line">grant create session to PMSAlex; 赋予数据库连接权限</div><div class="line">grant insert,update,select,delete on PMSAlex.W_PSDDOCUMENT to PMSAlex;</div><div class="line">conn PMSAlex/PMSAlex;</div><div class="line">select * from PMSAlex.W_PSDDOCUMENT;</div></pre></td></tr></table></figure><h3 id="其它语句"><a href="#其它语句" class="headerlink" title="其它语句"></a>其它语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(1)查目录 ，找不到导入导出路径时用</div><div class="line">select * from dba_directories;</div><div class="line">(2)Oracle 高版本导出到低版本11-&gt;10，在低版本上找到具体版本</div><div class="line">select * from v$version;</div><div class="line">在高版本上导出时加上 version=10.2.0.4.0</div></pre></td></tr></table></figure><h3 id="空表问题"><a href="#空表问题" class="headerlink" title="空表问题"></a>空表问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1、把用户下的表改为statistics模式，使其num_rows的值可信</div><div class="line">select &apos;analyze table &apos;||table_name||&apos; compute statistics;&apos; from user_tables where tablespace_name=&apos;PMSAlex&apos; and INSTR(table_name, &apos;W_&apos;)&gt;0</div><div class="line">2、查询所有有数据的业务表，利用Excel构造成导库的语句</div><div class="line">select &apos;select * from &apos;||table_name FROM user_tables where tablespace_name=&apos;PMSAlex&apos; and INSTR(table_name, &apos;W_&apos;)&gt;0 and num_rows&gt;0;</div></pre></td></tr></table></figure><h3 id="账户锁定问题"><a href="#账户锁定问题" class="headerlink" title="账户锁定问题"></a>账户锁定问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SQL&gt;alter user system account unlock；（解除锁定的方法）</div><div class="line">--为防止多次错误后锁定账户，将次数修改为N/无限次</div><div class="line">SQL&gt;alter profile default limit FAILED_LOGIN_ATTEMPTS N/unlimited;</div><div class="line">--查看被锁时间：</div><div class="line">select username,lock_date from dba_users;</div></pre></td></tr></table></figure><h3 id="ORA-12516错误"><a href="#ORA-12516错误" class="headerlink" title="ORA-12516错误"></a>ORA-12516错误</h3><p>错误代码含义：TNS监听程序找不到符合协议堆栈要求的可用处理器<br>原因及解决方法：修改连接数的限制 –session数不够</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a.已sysdba 登录PL/SQL 或者Worksheet</div><div class="line">b.查询目前连接数</div><div class="line">show parameter processes;</div><div class="line">c.更改系统连接数</div><div class="line">alter system set processes=1000 scope=spfile;//默认的连接数为150</div><div class="line">d.创建pfile</div><div class="line">create pfile from spfile;</div><div class="line">e.重启Oracle服务，或重启Oracle服务器；//reboot</div></pre></td></tr></table></figure><h3 id="编码相关错误"><a href="#编码相关错误" class="headerlink" title="编码相关错误"></a>编码相关错误</h3><p>ORA-39064: 无法写入日志文件 </p><p>ORA-29285: 文件写入错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">解决方案:（导入导出两边都要改，改成一样的）</div><div class="line">1、windows</div><div class="line">运行 -》 regedit -》查找 键值 NLS_LANG </div><div class="line">注册表路径：HKEY_LOCAL_MACHINE\SOFTWARE\ORACLE\HOMExx\NLS_LANG</div><div class="line">将字符集 SIMPLIFIED CHINESE_CHINA.ZHS16GBK 修改为AMERICAN_AMERICA.AL32UTF8</div></pre></td></tr></table></figure><h3 id="自动备份与清除脚本"><a href="#自动备份与清除脚本" class="headerlink" title="自动备份与清除脚本"></a>自动备份与清除脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line"></div><div class="line">rem set backupfile=f_database_%date:~0,4%-%date:~5,2%-%date:~8,2%.dmp</div><div class="line"></div><div class="line">rem set logfile=f_database_%date:~0,4%-%date:~5,2%-%date:~8,2%.log</div><div class="line"></div><div class="line">rem delete 30days files</div><div class="line"></div><div class="line">forfiles /p &quot;D:\temp\dmp&quot; /d -30  /c &quot;cmd /c echo deleting @file ... &amp;&amp; del /f @path&quot;</div><div class="line"></div><div class="line">cd D:\temp\dmp</div><div class="line"></div><div class="line">rem backup schemas</div><div class="line"></div><div class="line">set backupfile=sshe_%date:~0,4%-%date:~5,2%-%date:~8,2%-%time:~0,2%-%time:~3,2%-%time:~6,2%.dmp</div><div class="line"></div><div class="line">set logfile=sshe_%date:~0,4%-%date:~5,2%-%date:~8,2%-%time:~0,2%-%time:~3,2%-%time:~6,2%.log</div><div class="line"></div><div class="line">expdp sshe/sshe directory=DIR_DP  dumpfile=%backupfile%  logfile=%logfile% schemas=sshe parallel=4</div></pre></td></tr></table></figure><h3 id="服务器上传文件备份"><a href="#服务器上传文件备份" class="headerlink" title="服务器上传文件备份"></a>服务器上传文件备份</h3><p>脚本：fileBackup.bat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">xcopy &quot;D:\alex01&quot; &quot;E:\alex02&quot; /e/I/d/h/r/y</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java BIO实例</title>
      <link href="/2018/06/13/Java-BIO%E5%AE%9E%E4%BE%8B/"/>
      <url>/2018/06/13/Java-BIO%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>本文实例以文件操作、字节流、字符流、序列化流模块进行归纳，输入输出流同理部分缺省。</p><a id="more"></a><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="java-io-File"><a href="#java-io-File" class="headerlink" title="java.io.File"></a>java.io.File</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"E:\\javaio"</span>);</div><div class="line"><span class="comment">//System.out.println(file.exists());</span></div><div class="line"><span class="keyword">if</span>(!file.exists())｛</div><div class="line">file.mkdir(); <span class="comment">//file.mkdirs()</span></div><div class="line">｝<span class="keyword">else</span>｛</div><div class="line">file.delete();</div><div class="line">｝</div><div class="line"><span class="comment">//是否是一个目录  如果是目录返回true,如果不是目录or目录不存在返回的是false</span></div><div class="line">System.out.println(file.isDirectory());</div><div class="line"><span class="comment">//是否是一个文件</span></div><div class="line">System.out.println(file.isFile());</div><div class="line"></div><div class="line"><span class="comment">//File file2 = new File("e:\\javaio\\日记1.txt");</span></div><div class="line">File file2 = <span class="keyword">new</span> File(<span class="string">"e:\\javaio"</span>,<span class="string">"日记1.txt"</span>);</div><div class="line"><span class="keyword">if</span>(!file2.exists())｛</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">file2.createNewFile();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">｝<span class="keyword">else</span>｛</div><div class="line">file2.delete();</div><div class="line">｝</div><div class="line">         <span class="comment">//常用的File对象的API</span></div><div class="line">System.out.println(file);<span class="comment">//file.toString()的内容</span></div><div class="line">System.out.println(file.getAbsolutePath());</div><div class="line">System.out.println(file.getName());</div><div class="line">System.out.println(file2.getName());</div><div class="line">System.out.println(file.getParent());</div><div class="line">System.out.println(file2.getParent());</div><div class="line">System.out.println(file.getParentFile().getAbsolutePath());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo2</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"e:\\example"</span>);</div><div class="line"></div><div class="line"><span class="comment">//skill_01</span></div><div class="line">String[] filenames = file.list(<span class="keyword">new</span> FilenameFilter() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line">System.out.println(dir+<span class="string">"\\"</span>+name);</div><div class="line"><span class="keyword">return</span> name.endsWith(<span class="string">"java"</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">for</span> (String string : filenames) &#123;</div><div class="line">System.out.println(string);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//skill_02</span></div><div class="line">File[] files = file.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line">System.out.println(dir+<span class="string">"\\"</span>+name);</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//skill_03</span></div><div class="line">File[] files = file.listFiles(<span class="keyword">new</span> FileFilter() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line">System.out.println(pathname);</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo3</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">File dir=<span class="keyword">new</span> File(<span class="string">"src/lee"</span>);</div><div class="line">FileAccept fileAccept=<span class="keyword">new</span> FileAccept();</div><div class="line">fileAccept.setExtendName(<span class="string">"java"</span>);</div><div class="line">String[] fileName=dir.list(fileAccept);</div><div class="line"><span class="keyword">for</span>(String name:fileName)&#123;</div><div class="line">System.out.println(name);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileAccept</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span></span>&#123;</div><div class="line"><span class="keyword">private</span> String extendName;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExtendName</span><span class="params">(String s)</span></span>&#123;</div><div class="line">extendName=<span class="string">"."</span>+s;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line"><span class="keyword">return</span> name.endsWith(extendName);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo4</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">File f=<span class="keyword">new</span> File(<span class="string">"E:\\workspace\\eclipse jee\\HelloWorld_01"</span>);</div><div class="line">System.out.println(f.getName());</div><div class="line">tree(f,<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tree</span><span class="params">(File f,<span class="keyword">int</span> leve)</span></span>&#123;</div><div class="line">String str=<span class="string">""</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;leve;j++)&#123;</div><div class="line">str+=<span class="string">"    "</span>;</div><div class="line">&#125;</div><div class="line">File[] children=f.listFiles();<span class="comment">//list()方法返回字符串数组，目录下所有文件名</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;children.length;i++)&#123;</div><div class="line">System.out.println(str+children[i].getName());</div><div class="line"><span class="keyword">if</span>(children[i].isDirectory())&#123;</div><div class="line">tree(children[i],leve+<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="java-io-FileOutputStream"><a href="#java-io-FileOutputStream" class="headerlink" title="java.io.FileOutputStream"></a>java.io.FileOutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">//如果该文件不存在，则直接创建，如果存在，删除后创建</span></div><div class="line">        FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"demo/out.dat"</span>);</div><div class="line">        out.write(<span class="string">'A'</span>);<span class="comment">//写出了'A'的低八位</span></div><div class="line">        out.write(<span class="string">'B'</span>);<span class="comment">//写出了'B'的低八位</span></div><div class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//write只能写八位,那么写一个int需要些4次每次8位</span></div><div class="line">        out.write(a &gt;&gt;&gt; <span class="number">24</span>);</div><div class="line">        out.write(a &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">        out.write(a &gt;&gt;&gt; <span class="number">8</span>);</div><div class="line">        out.write(a);</div><div class="line">        <span class="keyword">byte</span>[] gbk = <span class="string">"中国"</span>.getBytes(<span class="string">"gbk"</span>);</div><div class="line">        out.write(gbk);</div><div class="line">        out.close();</div><div class="line">        IOUtil.printHex(<span class="string">"demo/out.dat"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>);</div><div class="line">    fos.write(<span class="string">"你好啊！"</span>.getBytes());</div><div class="line">    fos.flush();<span class="comment">//清空缓存，立即输出缓存中的内容</span></div><div class="line">    fos.close();<span class="comment">//关闭的时候也会清空缓存</span></div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="java-io-FileInputStream"><a href="#java-io-FileInputStream" class="headerlink" title="java.io.FileInputStream"></a>java.io.FileInputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"demo/out.dat"</span>);</div><div class="line">        System.out.println(input.read());</div><div class="line">        System.out.println(input.read());</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        i = input.read() | (i &lt;&lt; <span class="number">8</span>);</div><div class="line">        i = input.read() | (i &lt;&lt; <span class="number">8</span>);</div><div class="line">        i = input.read() | (i &lt;&lt; <span class="number">8</span>);</div><div class="line">        i = input.read() | (i &lt;&lt; <span class="number">8</span>);</div><div class="line">        System.out.println(i);</div><div class="line">        <span class="keyword">byte</span>[] gbk = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">        input.read(gbk);</div><div class="line">        System.out.println(<span class="keyword">new</span> String(gbk));</div><div class="line">        input.close();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//默认的相对路径：就是我们的项目路径</span></div><div class="line">FileInputStream fis=<span class="keyword">new</span> FileInputStream(<span class="string">"src/com/gem/sun/io/io.txt"</span>);</div><div class="line"><span class="comment">//read可以读取一个字符</span></div><div class="line"><span class="comment">//当文件比较大的时候，这种方式就读取不了了</span></div><div class="line"><span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[fis.available()];</div><div class="line">fis.read(bytes);</div><div class="line">System.out.println(<span class="keyword">new</span> String(bytes));</div><div class="line">fis.close();</div></pre></td></tr></table></figure><h4 id="java-io-DataOutputStream"><a href="#java-io-DataOutputStream" class="headerlink" title="java.io.DataOutputStream"></a>java.io.DataOutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DosDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">String file = <span class="string">"demo/dos.dat"</span>;</div><div class="line">DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(</div><div class="line">         <span class="keyword">new</span> FileOutputStream(file));</div><div class="line">dos.writeInt(<span class="number">10</span>);</div><div class="line">dos.writeInt(-<span class="number">10</span>);</div><div class="line">dos.writeLong(<span class="number">10l</span>);</div><div class="line">dos.writeDouble(<span class="number">10.5</span>);</div><div class="line"><span class="comment">//采用utf-8编码写出</span></div><div class="line">dos.writeUTF(<span class="string">"中国"</span>);</div><div class="line"><span class="comment">//采用utf-16be编码写出</span></div><div class="line">dos.writeChars(<span class="string">"中国"</span>);</div><div class="line">dos.close();</div><div class="line">IOUtil.printHex(file);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="java-io-DataInputStream"><a href="#java-io-DataInputStream" class="headerlink" title="java.io.DataInputStream"></a>java.io.DataInputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        String file = <span class="string">"demo/dos.dat"</span>;</div><div class="line">        IOUtil.printHex(file);</div><div class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(</div><div class="line">        <span class="keyword">new</span> FileInputStream(file));</div><div class="line">        <span class="keyword">int</span> i = dis.readInt();</div><div class="line">        System.out.println(i);</div><div class="line">        </div><div class="line">        i = dis.readInt();</div><div class="line">        System.out.println(i);</div><div class="line">        </div><div class="line">        <span class="keyword">long</span> l = dis.readLong();</div><div class="line">        System.out.println(l);</div><div class="line">        </div><div class="line">        <span class="keyword">double</span> d = dis.readDouble();</div><div class="line">        System.out.println(d);</div><div class="line">        </div><div class="line">        String s = dis.readUTF();</div><div class="line">        System.out.println(s);</div><div class="line">        dis.close();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="java-io-ByteArrayOutputStream"><a href="#java-io-ByteArrayOutputStream" class="headerlink" title="java.io.ByteArrayOutputStream"></a>java.io.ByteArrayOutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">File file=<span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</div><div class="line"><span class="comment">//1.创建输出流</span></div><div class="line">FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(file);</div><div class="line"><span class="comment">//创建数组</span></div><div class="line"><span class="keyword">byte</span>[] b=<span class="keyword">null</span>;</div><div class="line"><span class="comment">//1.1如果是字符串</span></div><div class="line">b=<span class="string">"abc"</span>.getBytes();</div><div class="line"><span class="comment">//1.2他可能是一连串的数据</span></div><div class="line">ByteArrayOutputStream bos=<span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">//字节数组输出流</span></div><div class="line">bos.write(b);<span class="comment">//write就是将数据积累到bos</span></div><div class="line"></div><div class="line"><span class="comment">//2.向外输出内容</span></div><div class="line">fos.write(bos.toByteArray());</div><div class="line"><span class="comment">//3.关闭输出流</span></div><div class="line">fos.close();</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ByteArrayOutputStream bos=<span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line"><span class="comment">//分段读取</span></div><div class="line">FileInputStream fis=<span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</div><div class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</div><div class="line"><span class="keyword">int</span> lenth=<span class="number">0</span>;</div><div class="line"><span class="keyword">while</span>((lenth=fis.read(b))!=-<span class="number">1</span>)&#123;</div><div class="line">    bos.write(b, <span class="number">0</span>, lenth);</div><div class="line">    <span class="comment">//System.out.println(new String(b,0,b.length));</span></div><div class="line">&#125;</div><div class="line">b=bos.toByteArray();</div><div class="line">System.out.println(<span class="keyword">new</span> String(b,<span class="string">"utf-8"</span>));</div><div class="line">fis.close();</div></pre></td></tr></table></figure><h4 id="java-io-PrintStream"><a href="#java-io-PrintStream" class="headerlink" title="java.io.PrintStream"></a>java.io.PrintStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="string">"e:/test.txt"</span>);</div><div class="line">PrintStream ps=<span class="keyword">new</span> PrintStream(fos);</div><div class="line">System.setOut(ps);</div><div class="line">System.out.println(<span class="number">6666</span>);</div><div class="line">System.out.println(<span class="number">777</span>);</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">String filename=args[<span class="number">0</span>];</div><div class="line"><span class="keyword">if</span>(filename!=<span class="keyword">null</span>)&#123;</div><div class="line">list(filename,System.out);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(String f,PrintStream fs)</span></span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(f));</div><div class="line">String s=<span class="keyword">null</span>;</div><div class="line"><span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</div><div class="line">fs.println(s);</div><div class="line">&#125;</div><div class="line">br.close();</div><div class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="java-io-FileWriter"><a href="#java-io-FileWriter" class="headerlink" title="java.io.FileWriter"></a>java.io.FileWriter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrAndFwDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"e:\\javaio\\fileWrite.txt"</span>);</div><div class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"e:\\javaio\\fileWrite2.txt"</span>);</div><div class="line"><span class="comment">//FileWriter fw = new FileWriter("e:\\javaio\\fileWrite2.txt",true);</span></div><div class="line"><span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2056</span>];</div><div class="line"><span class="keyword">int</span> c ;</div><div class="line"><span class="keyword">while</span>((c = fr.read(buffer,<span class="number">0</span>,buffer.length))!=-<span class="number">1</span>)&#123;</div><div class="line">fw.write(buffer,<span class="number">0</span>,c);</div><div class="line">fw.flush();</div><div class="line">&#125;</div><div class="line">fr.close();</div><div class="line">fw.close();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="java-io-FileReader"><a href="#java-io-FileReader" class="headerlink" title="java.io.FileReader"></a>java.io.FileReader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</div><div class="line">    <span class="keyword">char</span>[] chr=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> lenth=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>((lenth=fr.read(chr))!=-<span class="number">1</span>)&#123;</div><div class="line">    System.out.print(<span class="keyword">new</span> String(chr));</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="java-io-BufferedWriter"><a href="#java-io-BufferedWriter" class="headerlink" title="java.io.BufferedWriter"></a>java.io.BufferedWriter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrAndBwOrPwDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line"><span class="comment">//对文件进行读写操作</span></div><div class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(</div><div class="line"><span class="keyword">new</span> InputStreamReader(</div><div class="line"><span class="keyword">new</span> FileInputStream(<span class="string">"e:\\javaio\\imooc.txt"</span>)));</div><div class="line"><span class="comment">/*BufferedWriter bw = new BufferedWriter(</span></div><div class="line">new OutputStreamWriter(</div><div class="line">new FileOutputStream("e:\\javaio\\imooc3.txt")));*/</div><div class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">"e:\\javaio\\imooc4.txt"</span>);</div><div class="line"><span class="comment">//PrintWriter pw1 = new PrintWriter(outputStream,boolean autoFlush);</span></div><div class="line">String line ;</div><div class="line"><span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>)&#123;</div><div class="line">System.out.println(line);<span class="comment">//一次读一行，并不能识别换行</span></div><div class="line"><span class="comment">/*bw.write(line);</span></div><div class="line">//单独写出换行操作</div><div class="line">bw.newLine();//换行操作</div><div class="line">bw.flush();*/</div><div class="line">pw.println(line);</div><div class="line">pw.flush();</div><div class="line">&#125;</div><div class="line">br.close();</div><div class="line"><span class="comment">//bw.close();</span></div><div class="line">pw.close();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="java-io-OutputStreamWriter"><a href="#java-io-OutputStreamWriter" class="headerlink" title="java.io.OutputStreamWriter"></a>java.io.OutputStreamWriter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsrAndOswDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"e:\\javaio\\imoocutf8.txt"</span>);</div><div class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in,<span class="string">"utf-8"</span>);<span class="comment">//默认项目的编码,操作的时候，要写文件本身的编码格式</span></div><div class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"e:\\javaio\\imoocutf81.txt"</span>);</div><div class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(out,<span class="string">"utf-8"</span>);</div><div class="line"><span class="comment">/*int c ;</span></div><div class="line">while((c = isr.read())!=-1)&#123;</div><div class="line">System.out.print((char)c);</div><div class="line">&#125;*/</div><div class="line"><span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>*<span class="number">1024</span>];</div><div class="line"><span class="keyword">int</span> c;</div><div class="line"><span class="comment">/*批量读取，放入buffer这个字符数组，从第0个位置开始放置，最多放buffer.length个</span></div><div class="line">  返回的是读到的字符的个数</div><div class="line">*/</div><div class="line"><span class="keyword">while</span>(( c = isr.read(buffer,<span class="number">0</span>,buffer.length))!=-<span class="number">1</span>)&#123;</div><div class="line">String s = <span class="keyword">new</span> String(buffer,<span class="number">0</span>,c);</div><div class="line">System.out.print(s);</div><div class="line">osw.write(buffer,<span class="number">0</span>,c);</div><div class="line">osw.flush();</div><div class="line">&#125;</div><div class="line">isr.close();</div><div class="line">osw.close();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="java-io-PrintWriter"><a href="#java-io-PrintWriter" class="headerlink" title="java.io.PrintWriter"></a>java.io.PrintWriter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">String s=<span class="keyword">null</span>;</div><div class="line">BufferedReader br =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div><div class="line">FileWriter fw=<span class="keyword">new</span> FileWriter(<span class="string">"e:/logfile.log"</span>,<span class="keyword">true</span>);</div><div class="line">PrintWriter log=<span class="keyword">new</span> PrintWriter(fw);</div><div class="line"><span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</div><div class="line"><span class="keyword">if</span>(s.equalsIgnoreCase(<span class="string">"exit"</span>))&#123;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">System.out.println(s.toUpperCase());</div><div class="line">log.println(<span class="string">"------------"</span>);</div><div class="line">log.println(s.toUpperCase());</div><div class="line">log.flush();</div><div class="line">&#125;</div><div class="line">log.println(<span class="string">"==="</span>+<span class="keyword">new</span> Date()+<span class="string">"==="</span>);</div><div class="line">log.flush();</div><div class="line">log.close();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><h4 id="java-io-RandomAccessFile"><a href="#java-io-RandomAccessFile" class="headerlink" title="java.io.RandomAccessFile"></a>java.io.RandomAccessFile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RafDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">File demo = <span class="keyword">new</span> File(<span class="string">"demo"</span>);</div><div class="line"><span class="keyword">if</span>(!demo.exists())｛</div><div class="line">demo.mkdir();</div><div class="line">｝</div><div class="line">File file = <span class="keyword">new</span> File(demo,<span class="string">"raf.dat"</span>);</div><div class="line"><span class="keyword">if</span>(!file.exists())｛</div><div class="line">file.createNewFile();</div><div class="line">｝</div><div class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</div><div class="line"><span class="comment">//指针的位置</span></div><div class="line">System.out.println(raf.getFilePointer());</div><div class="line"></div><div class="line">raf.write(<span class="string">'A'</span>);<span class="comment">//只写了一个字节</span></div><div class="line">System.out.println(raf.getFilePointer());</div><div class="line">raf.write(<span class="string">'B'</span>);</div><div class="line"></div><div class="line"><span class="keyword">int</span> i = <span class="number">0x7fffffff</span>;</div><div class="line"><span class="comment">//用write方法每次只能写一个字节，如果要把i写进去就得写4次</span></div><div class="line">raf.write(i &gt;&gt;&gt; <span class="number">24</span>);<span class="comment">//高8位</span></div><div class="line">raf.write(i &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">raf.write(i &gt;&gt;&gt; <span class="number">8</span>);</div><div class="line">raf.write(i);</div><div class="line">System.out.println(raf.getFilePointer());</div><div class="line"></div><div class="line"><span class="comment">//可以直接写一个int</span></div><div class="line">raf.writeInt(i);</div><div class="line"></div><div class="line">String s = <span class="string">"中"</span>;</div><div class="line"><span class="keyword">byte</span>[] gbk = s.getBytes(<span class="string">"gbk"</span>);</div><div class="line">raf.write(gbk);</div><div class="line">System.out.println(raf.length());</div><div class="line"></div><div class="line"><span class="comment">//读文件，必须把指针移到头部</span></div><div class="line">raf.seek(<span class="number">0</span>);</div><div class="line"><span class="comment">//一次性读取,把文件中的内容都读到字节数组中</span></div><div class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)raf.length()];</div><div class="line">raf.read(buf);</div><div class="line"></div><div class="line">System.out.println(Arrays.toString(buf));</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> b : buf) &#123;</div><div class="line">System.out.println(Integer.toHexString(b &amp; <span class="number">0xff</span>)+<span class="string">" "</span>);</div><div class="line">&#125;</div><div class="line">    raf.close();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RafReadDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"demo/raf.dat"</span>, <span class="string">"r"</span>);</div><div class="line">raf.seek(<span class="number">2</span>);</div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> b = raf.read();<span class="comment">//读取到一个字节</span></div><div class="line">System.out.println(raf.getFilePointer());</div><div class="line">i = i | (b &lt;&lt; <span class="number">24</span> );</div><div class="line">b = raf.read();</div><div class="line">i = i | ( b &lt;&lt; <span class="number">16</span>);</div><div class="line">b = raf.read();</div><div class="line">i = i | (b &lt;&lt; <span class="number">8</span> );</div><div class="line">b = raf.read();</div><div class="line">i = i | b;</div><div class="line">System.out.println(Integer.toHexString(i));</div><div class="line">raf.seek(<span class="number">2</span>);</div><div class="line">i = raf.readInt();</div><div class="line">System.out.println(Integer.toHexString(i));</div><div class="line">raf.close();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFileSeriaDemo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">File demo = <span class="keyword">new</span> File(<span class="string">"demo1"</span>);</div><div class="line"><span class="keyword">if</span>(!demo.exists())｛</div><div class="line">demo.mkdir();</div><div class="line">｝</div><div class="line">File file = <span class="keyword">new</span> File(demo,<span class="string">"raf.dat"</span>);</div><div class="line"><span class="keyword">if</span>(!file.exists())｛</div><div class="line">file.createNewFile();</div><div class="line">｝</div><div class="line"><span class="comment">//打开文件，进行随机读写</span></div><div class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</div><div class="line"><span class="comment">/*序列化*/</span></div><div class="line"><span class="keyword">int</span> i = <span class="number">0x7ffffff</span>;</div><div class="line">raf.write(i &gt;&gt;&gt; <span class="number">24</span>);</div><div class="line">raf.write(i &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">raf.write(i &gt;&gt;&gt; <span class="number">8</span>);</div><div class="line">raf.write(i &gt;&gt;&gt; <span class="number">8</span>);</div><div class="line">raf.write(i);</div><div class="line">System.out.println(raf.getFilePointer());</div><div class="line"></div><div class="line"><span class="comment">/*反序列化*/</span></div><div class="line">raf.seek(<span class="number">0</span>);</div><div class="line"><span class="keyword">int</span> b = raf.read();</div><div class="line">i = i | (b &lt;&lt; <span class="number">24</span>);</div><div class="line">b = raf.read();</div><div class="line">i = i | (b &lt;&lt; <span class="number">16</span>);</div><div class="line">b = raf.read();</div><div class="line">i = i | (b &lt;&lt; <span class="number">8</span>);</div><div class="line">b = raf.read();</div><div class="line">i = i | b;</div><div class="line">System.out.println(Integer.toHexString(i));</div><div class="line">raf.close();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="java-io-ObjectOutputStream"><a href="#java-io-ObjectOutputStream" class="headerlink" title="java.io.ObjectOutputStream"></a>java.io.ObjectOutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line"><span class="keyword">private</span> String stuno;</div><div class="line"><span class="keyword">private</span> String stuname;</div><div class="line"><span class="comment">//该元素不会进行jvm默认的序列化,也可以自己完成这个元素的序列化</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> stuage;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String stuno, String stuname, <span class="keyword">int</span> stuage)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>();</div><div class="line"><span class="keyword">this</span>.stuno = stuno;</div><div class="line"><span class="keyword">this</span>.stuname = stuname;</div><div class="line"><span class="keyword">this</span>.stuage = stuage;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getStuno</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> stuno;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuno</span><span class="params">(String stuno)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.stuno = stuno;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getStuname</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> stuname;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuname</span><span class="params">(String stuname)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.stuname = stuname;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStuage</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> stuage;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuage</span><span class="params">(<span class="keyword">int</span> stuage)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.stuage = stuage;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"Student [stuno="</span> + stuno + <span class="string">", stuname="</span> + stuname </div><div class="line">+ <span class="string">", stuage="</span> + stuage + <span class="string">"]"</span>;</div><div class="line">&#125;</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">        <span class="keyword">throws</span> java.io.IOException&#123;</div><div class="line"> s.defaultWriteObject();<span class="comment">//把jvm能默认序列化的元素进行序列化操作</span></div><div class="line"> s.writeInt(stuage);<span class="comment">//自己完成stuage的序列化</span></div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></div><div class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException&#123;</div><div class="line">  s.defaultReadObject();<span class="comment">//把jvm能默认反序列化的元素进行反序列化操作</span></div><div class="line">  <span class="keyword">this</span>.stuage = s.readInt();<span class="comment">//自己完成stuage的反序列化操作</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSeriaDemo1</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">String file = <span class="string">"demo/obj.dat"</span>;</div><div class="line"><span class="comment">//1.对象的序列化</span></div><div class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(</div><div class="line"><span class="keyword">new</span> FileOutputStream(file));</div><div class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">"10001"</span>, <span class="string">"张三"</span>, <span class="number">20</span>);</div><div class="line">oos.writeObject(stu);</div><div class="line">oos.flush();</div><div class="line">oos.close();</div><div class="line"></div><div class="line"><span class="comment">//2.对象的反序列化</span></div><div class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(</div><div class="line"><span class="keyword">new</span> FileInputStream(file));</div><div class="line">Student stu = (Student)ois.readObject();</div><div class="line">System.out.println(stu);</div><div class="line">ois.close();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSeriaDemo2</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line"><span class="comment">//序列化过程递归调用父类的构造函数</span></div><div class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(</div><div class="line"><span class="keyword">new</span> FileOutputStream(<span class="string">"demo/obj1.dat"</span>));</div><div class="line">Foo2 foo2 = <span class="keyword">new</span> Foo2();</div><div class="line">oos.writeObject(foo2);</div><div class="line">oos.flush();</div><div class="line">oos.close();</div><div class="line"></div><div class="line"><span class="comment">//反序列化不递归调用父类的构造函数</span></div><div class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(</div><div class="line"><span class="keyword">new</span> FileInputStream(<span class="string">"demo/obj1.dat"</span>));</div><div class="line">Foo2 foo2 = (Foo2)ois.readObject();</div><div class="line">System.out.println(foo2);</div><div class="line">ois.close();</div><div class="line"></div><div class="line"><span class="comment">//序列化过程递归调用父类的构造函数</span></div><div class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(</div><div class="line"><span class="keyword">new</span> FileOutputStream(<span class="string">"demo/obj1.dat"</span>));</div><div class="line">Bar2 bar2 = <span class="keyword">new</span> Bar2();</div><div class="line">oos.writeObject(bar2);</div><div class="line">oos.flush();</div><div class="line">oos.close();</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 对子类对象进行反序列化操作时，</div><div class="line"> * 如果其父类没有实现序列化接口</div><div class="line"> * 那么其父类的构造函数会被调用</div><div class="line"> */</div><div class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(</div><div class="line"><span class="keyword">new</span> FileInputStream(<span class="string">"demo/obj1.dat"</span>));</div><div class="line">Bar2 bar2 = (Bar2)ois.readObject();</div><div class="line">System.out.println(bar2);</div><div class="line">ois.close();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> *   一个类实现了序列化接口，那么其子类都可以进行序列化</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"foo..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo1</span> <span class="keyword">extends</span> <span class="title">Foo</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Foo1</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"foo1..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> <span class="keyword">extends</span> <span class="title">Foo1</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Foo2</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"foo2..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bar</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"bar"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar1</span> <span class="keyword">extends</span> <span class="title">Bar</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bar1</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"bar1.."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar2</span> <span class="keyword">extends</span> <span class="title">Bar1</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bar2</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"bar2..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java BIO归纳</title>
      <link href="/2018/06/12/Java-BIO%E5%BD%92%E7%BA%B3/"/>
      <url>/2018/06/12/Java-BIO%E5%BD%92%E7%BA%B3/</url>
      
        <content type="html"><![CDATA[<p>java.io.File类用于表示文件（目录）</p><p>File类只用于表示文件（目录）的信息（名称、大小等），不能用于文件内容的访问</p><p>IO流可以划分为输入流、输出流两类，也可以划分为字节流、字符流、序列化流三类</p><a id="more"></a><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>1）InputStream、OutputStream</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InputStream抽象了应用程序读取数据的方式</div><div class="line">OutputStream抽象了应用程序写出数据的方式</div></pre></td></tr></table></figure><p>2）EOF = End   读到-1就读到结尾</p><p>3）输入流基本方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>  b = in.read();读取一个字节无符号填充到<span class="keyword">int</span>低八位.-<span class="number">1</span>是 EOF</div><div class="line">in.read(<span class="keyword">byte</span>[] buf) </div><div class="line">in.read(<span class="keyword">byte</span>[] buf,<span class="keyword">int</span> start,<span class="keyword">int</span> size)</div></pre></td></tr></table></figure><p>4）输出流基本方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">out.write(<span class="keyword">int</span> b)  写出一个<span class="keyword">byte</span>到流，b的低<span class="number">8</span>位</div><div class="line">out.write(<span class="keyword">byte</span>[] buf)将buf字节数组都写入到流</div><div class="line">out.write(<span class="keyword">byte</span>[] buf,<span class="keyword">int</span> start,<span class="keyword">int</span> size)</div></pre></td></tr></table></figure><p>5）FileInputStream—&gt;具体实现了在文件上读取数据</p><p>6）FileOutputStream 实现了向文件中写出byte数据的方法</p><p>7）DataOutputStream、DataInputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">对<span class="string">"流"</span>功能的扩展，可以更加方面的读取<span class="keyword">int</span>,<span class="keyword">long</span>，字符等类型数据</div><div class="line">writeInt()/writeDouble()/writeUTF()</div></pre></td></tr></table></figure><p>8）BufferedInputStream、BufferedOutputStream</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">这两个流类位IO提供了带缓冲区的操作，一般打开文件进行写入</div><div class="line">或读取操作时，都会加上缓冲，这种流模式提高了IO的性能</div><div class="line">从应用程序中把输入放入文件，相当于将一缸水倒入到另一个缸中:</div><div class="line">FileOutputStream---&gt;write()方法相当于一滴一滴地把水“转移”过去</div><div class="line">DataOutputStream--&gt;writeXxx()方法会方便一些，相当于一瓢一瓢把水“转移”过去</div><div class="line">BufferedOutputStream---&gt;write方法更方便，相当于一飘一瓢先放入桶中，</div><div class="line">再从桶中倒入到另一个缸中，性能提高了</div></pre></td></tr></table></figure><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>1） 编码问题</p><p>2）认识文本和文本文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java的文本(char)是16位无符号整数，是字符的unicode编码（双字节编码)</div><div class="line">文件是byte byte byte ...的数据序列</div><div class="line">文本文件是文本(char)序列按照某种编码方案(utf-8,utf-16be,gbk)序列化为byte的存储结果</div></pre></td></tr></table></figure><p>3）字符流(Reader Writer)—-&gt;操作的是文本文本文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">字符的处理，一次处理一个字符</div><div class="line">字符的底层任然是基本的字节序列</div><div class="line">字符流的基本实现</div><div class="line">   InputStreamReader   完成byte流解析为char流,按照编码解析</div><div class="line">   OutputStreamWriter  提供char流到byte流，按照编码处理  </div><div class="line">   FileReader/FileWriter</div><div class="line">   </div><div class="line">字符流的过滤器</div><div class="line">   BufferedReader   ----&gt;readLine 一次读一行</div><div class="line">   BufferedWriter/PrintWriter     ---&gt;写一行</div></pre></td></tr></table></figure><h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><h4 id="基本类型序列化"><a href="#基本类型序列化" class="headerlink" title="基本类型序列化"></a>基本类型序列化</h4><p>1）将类型int 转换成4byte或将其他数据类型转换成byte的过程叫序列化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">数据----&gt;n byte</div></pre></td></tr></table></figure><p>2）反序列化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">将n个byte 转换成一个数据的过程</div><div class="line">nbyte ---&gt; 数据</div></pre></td></tr></table></figure><p>3）RandomAccessFile</p><p>提供基本类型的读写方法，可以将基本类型数据序列化到文件或者将文件内容反序列化为数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">提供的对文件内容的访问，既可以读文件，也可以写文件。</div><div class="line"></div><div class="line">支持随机访问文件，可以访问文件的任意位置</div><div class="line"></div><div class="line">1）java文件模型</div><div class="line">在硬盘上的文件是byte byte byte存储的,是数据的集合</div><div class="line"></div><div class="line">2）打开文件</div><div class="line">有两种模式&quot;rw&quot;(读写)  &quot;r&quot;（只读)</div><div class="line">RandomAccessFile raf = new RandomeAccessFile(file,&quot;rw&quot;)</div><div class="line">文件指针，打开文件时指针在开头 pointer = 0;</div><div class="line"></div><div class="line">3）写方法</div><div class="line">raf.write(int)---&gt;只写一个字节（后8位),同时指针指向下一个位置，准备再次写入</div><div class="line"></div><div class="line">4）读方法</div><div class="line">int b = raf.read()---&gt;读一个字节</div><div class="line"></div><div class="line">5）文件读写完成以后一定要关闭（Oracle官方说明）</div></pre></td></tr></table></figure><h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><p>1）对象序列化，就是将Object转换成byte序列，反之叫对象的反序列化 </p><p>2）序列化流是过滤流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">序列化流(ObjectOutputStream)，----writeObject</div><div class="line">反序列化流(ObjectInputStream)---readObject</div></pre></td></tr></table></figure><p>3）序列化接口(Serializable)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">对象必须实现序列化接口 ，才能进行序列化，否则将出现异常</div><div class="line">这个接口，没有任何方法，只是一个标准</div></pre></td></tr></table></figure><p>4）transient关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line"><span class="keyword">throws</span> java.io.IOException</div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></div><div class="line"><span class="keyword">throws</span> java.io.IOException, ClassNotFoundException</div><div class="line">        </div><div class="line">分析ArrayList源码中序列化和反序列化的问题</div></pre></td></tr></table></figure><p>5）序列化中子类和父类构造函数的调用问题</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自定义异常处理</title>
      <link href="/2018/06/12/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2018/06/12/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="错误、异常结构"><a href="#错误、异常结构" class="headerlink" title="错误、异常结构"></a>错误、异常结构</h3><pre><code>Throwable    error//无法通过程序弥补的    Exception//可以通过调试来处理的        runtime//运行时才会发生的        check//错不错误都要进行异常捕获的</code></pre><h3 id="异常处理要点"><a href="#异常处理要点" class="headerlink" title="异常处理要点"></a>异常处理要点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> throws 声明异常，让别人去捕获，谁调用这个放谁就要去捕获或者继续扔给下一个方法调用者</div><div class="line"> throw 手动抛出异常</div><div class="line"></div><div class="line">//最常用的显示异常的方法</div><div class="line">e.printStackTrace();</div><div class="line">//显示的内容比较针对的</div><div class="line">System.out.println(e.getMessage());</div><div class="line">//分类获取，多重try catch </div><div class="line">//多重try catch在使用时要注意异常的范围问题</div><div class="line">//范围小的放前面，级别相同就无所谓了</div><div class="line"></div><div class="line">执行了return语句，finally子语句仍然会被执行</div><div class="line">执行了System.exit(0)，finally子语句和其后所有语句将不执行</div></pre></td></tr></table></figure><a id="more"></a><h3 id="自定义异常实例"><a href="#自定义异常实例" class="headerlink" title="自定义异常实例"></a>自定义异常实例</h3><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</div><div class="line">String message;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">IntegerException</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</div><div class="line">message=<span class="string">"年龄"</span>+m+<span class="string">"不合理"</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> message;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="实体类声明、抛出异常"><a href="#实体类声明、抛出异常" class="headerlink" title="实体类声明、抛出异常"></a>实体类声明、抛出异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> age=<span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> <span class="keyword">throws</span> IntegerException</span>&#123;</div><div class="line"><span class="keyword">if</span>(age&gt;=<span class="number">160</span>||age&lt;<span class="number">0</span>)&#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IntegerException(age);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"年龄"</span>+age+<span class="string">"合理"</span>);</div><div class="line"><span class="keyword">return</span> age;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">People wang=<span class="keyword">new</span> People();</div><div class="line">People zhang=<span class="keyword">new</span> People();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">wang.setAge(<span class="number">180</span>);</div><div class="line">System.out.println(wang.getAge());</div><div class="line">&#125; <span class="keyword">catch</span> (IntegerException e) &#123;</div><div class="line">System.out.println(e.toString());</div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">zhang.setAge(<span class="number">37</span>);</div><div class="line">System.out.println(zhang.getAge());</div><div class="line">&#125; <span class="keyword">catch</span> (IntegerException e) &#123;</div><div class="line">System.out.println(e.toString());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH免密登录</title>
      <link href="/2018/06/12/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
      <url>/2018/06/12/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="配置IP、主机名映射"><a href="#配置IP、主机名映射" class="headerlink" title="配置IP、主机名映射"></a>配置IP、主机名映射</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/hosts</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">192.168.33.101node-01</div><div class="line">192.168.33.102node-02</div><div class="line">192.168.33.103node-03</div></pre></td></tr></table></figure><h3 id="配置SSH免密登录"><a href="#配置SSH免密登录" class="headerlink" title="配置SSH免密登录"></a>配置SSH免密登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 生成ssh免登录密钥</div><div class="line">ssh-keygen -t rsa（四个回车）</div><div class="line"># 执行完这个命令后，会生成id_rsa（私钥）、id_rsa.pub（公钥）</div><div class="line"># 将公钥拷贝到要免密登录的目标机器上</div><div class="line">ssh-copy-id node-02</div></pre></td></tr></table></figure><a id="more"></a><h3 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">关闭命令：service iptables stop</div><div class="line">永久关闭防火墙：chkconfig iptables off</div><div class="line"># 两个命令同时运行，运行完成后查看防火墙关闭状态</div><div class="line">service iptables status</div><div class="line"></div><div class="line">关闭防火墙-----service iptables stop </div><div class="line">启动防火墙-----service iptables start </div><div class="line">重启防火墙-----service iptables restart </div><div class="line">查看防火墙状态--service iptables status </div><div class="line">永久关闭防火墙--chkconfig iptables off </div><div class="line">永久关闭后启用--chkconfig iptables on</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 默认方法和多继承</title>
      <link href="/2018/05/27/Java8-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/05/27/Java8-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>以前经常谈论的Java对比C++的一个优势是Java中没有多继承的问题。因为Java中子类只能继承(extends)单个父类， 尽管可以实现(implements)多个接口，但是接口中只有抽象方法，方法体是空的，没有具体的方法实现，不会有方法冲突的问题。</p><p>但Java 8发布后，接口中也可以定义方法了(default method)。之所以打破以前的设计在接口中增加具体的方法， 是为了既有的成千上万的Java类库的类增加新的功能，而不必对这些类重新进行设计。比如，只需在Collection接口中增加default Stream<e> stream()，相应的Set和List接口以及它们的子类就都包含此的方法，不必为每个子类都重新copy这个方法。</e></p><p>这是一个折衷的设计，带来的问题就是为Java引入了多继承的问题。我们知道，接口可以继承接口，类可以继承类和实现接口。 一旦继承的类和实现的接口中有相同签名的方法， 会出现什么样的状况呢？ 本文将探讨各种情况的多继承，以便能清楚的理解Java多继承的规则。</p><a id="more"></a><h3 id="接口继承多个父接口"><a href="#接口继承多个父接口" class="headerlink" title="接口继承多个父接口"></a>接口继承多个父接口</h3><p>假定有三个接口Interface A, Interface B, Interface C, 继承关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+---------------+         +------------+</div><div class="line">|  Interface A  |         |Interface B |</div><div class="line">+-----------^---+         +---^--------+</div><div class="line">            |                 |         </div><div class="line">            |                 |         </div><div class="line">            |                 |         </div><div class="line">            +-+------------+--+         </div><div class="line">              | Interface C|            </div><div class="line">              +------------+</div></pre></td></tr></table></figure><p>接口A、B拥有相同签名的默认方法default String say(String name)，如果接口C没有override这个方法，则编译出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">say</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">say</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hi "</span> + name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</div><div class="line">     </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>错误信息： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">C:\Lambda\src&gt;javac -J-Duser.country=US com\colobu\lambda\chap</div><div class="line">ter3\MultipleInheritance1.java</div><div class="line">com\colobu\lambda\chapter3\MultipleInheritance1.java:<span class="number">17</span>: error: <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="title">inherits</span> <span class="title">unrelated</span> <span class="title">defaults</span> <span class="title">for</span> <span class="title">say</span>(<span class="title">String</span>) <span class="title">from</span> <span class="title">types</span> <span class="title">A</span> <span class="title">and</span> <span class="title">B</span></span></div><div class="line">        <span class="title">static</span> <span class="title">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span>&#123;</div><div class="line">               ^</div><div class="line"><span class="number">1</span> error</div></pre></td></tr></table></figure><p>我们可以在子接口C中覆盖override这个方法, 这样编译就不会出错了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">say</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"greet "</span> + name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意方法签名不包括方法的返回值，也就是仅仅返回值不同的两个方法的签名也是相同的。下面的代码编译不会出错，因为A和B的默认方法不同，C隐式继承了两个默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">int</span> name)</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</div><div class="line">     </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是有的情况下即使是不同签名的方法也是很难分辨的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"A"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">short</span> a)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"B"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</div><div class="line">     </div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</div><div class="line">     </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    D d = <span class="keyword">new</span> D();</div><div class="line">    <span class="keyword">byte</span> a = <span class="number">1</span>;</div><div class="line">    d.say(a); <span class="comment">//B</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Java会选择最适合的方法。</p><h3 id="接口多层继承"><a href="#接口多层继承" class="headerlink" title="接口多层继承"></a>接口多层继承</h3><p>下面看一下多层继承的问题。继承关系如下图，A2继承A1，C继承A2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+---------------+ </div><div class="line">|  Interface A1 | </div><div class="line">+--------+------+ </div><div class="line">         |        </div><div class="line">         |        </div><div class="line">         |        </div><div class="line">+--------+------+ </div><div class="line">|  Interface A2 | </div><div class="line">+-------+-------+ </div><div class="line">        |         </div><div class="line">        |         </div><div class="line">        |         </div><div class="line">+-------+--------+</div><div class="line">|   Interface C  |</div><div class="line">+----------------+</div></pre></td></tr></table></figure><p>基于我们以前对类继承的认识，很容易知道C会继承A2的默认方法，包括直接定义的默认方法，覆盖的默认方法，以及隐式继承于A1接口的默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"A"</span>);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"A.run"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"B"</span>);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"B.play"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</div><div class="line">     </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="多层多继承"><a href="#多层多继承" class="headerlink" title="多层多继承"></a>多层多继承</h3><p>上面一个例子还是单继承的例子， 如果如下图的多继承呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+---------------+                          </div><div class="line">|  Interface A1 |                          </div><div class="line">+--------+------+                          </div><div class="line">         |                                 </div><div class="line">         |                                 </div><div class="line">         |                                 </div><div class="line">+--------+------+         +---------------+</div><div class="line">|  Interface A2 |         |  Interface B  |</div><div class="line">+-------+-------+         +---------+-----+</div><div class="line">        |       +---------+---------^      </div><div class="line">        |       |                          </div><div class="line">        |       |                          </div><div class="line">+-------+-------++                         </div><div class="line">|   Interface C  |                         </div><div class="line">+----------------+</div></pre></td></tr></table></figure><p>如果A2和B拥有相同签名的方法，这和第一个例子一样。如果不想编译出错，可以覆盖父接口的默认方法，还可以调用指定父接口的默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A1</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"A1"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">A1</span> </span>&#123;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"B"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A2</span>,<span class="title">B</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">B.<span class="keyword">super</span>.say(a);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="更复杂的多层多继承"><a href="#更复杂的多层多继承" class="headerlink" title="更复杂的多层多继承"></a>更复杂的多层多继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+--------------+              </div><div class="line"> | Interface A1 |              </div><div class="line"> +------+------++              </div><div class="line">        |      ^+-------+      </div><div class="line">        |               |      </div><div class="line">+-------+-------+       |      </div><div class="line">|  Interface A2 |       |      </div><div class="line">+------------+--+       |      </div><div class="line">             ^--++      |      </div><div class="line">                 |      |      </div><div class="line">              +--+------+-----+</div><div class="line">              |  Interface C  |</div><div class="line">              +---------------+</div></pre></td></tr></table></figure><p>接口A2继承A1，接口C继承A2和A1。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A1</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"A1"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">A1</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"A2"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A2</span>,<span class="title">A1</span></span>&#123;</div><div class="line">     </div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</div><div class="line">     </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    D d = <span class="keyword">new</span> D();</div><div class="line">    d.say();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上代码不会编译出错，运行输出A2。</p><p>可以看到接口C会隐式继承子接口的方法，也就是子接口A2的默认方法。</p><h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><p>如果继承关系类型全部是类，那么由于类依然是单继承的，不会有多继承的问题。</p><h3 id="类和接口混杂"><a href="#类和接口混杂" class="headerlink" title="类和接口混杂"></a>类和接口混杂</h3><p>我们把第一个例子中的其中一个接口换成类，会出现什么现象呢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+-------------+       +-----------+</div><div class="line">| Interface A |       |  Class B  |</div><div class="line">+-----------+-+       +-----+-----+</div><div class="line">            ^-+    +--+-----^      </div><div class="line">              |    |               </div><div class="line">          +---+----+-+             </div><div class="line">          |  Class C |             </div><div class="line">          +----------+</div></pre></td></tr></table></figure><p>以下代码不会编译出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"A"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"B"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</div><div class="line">     </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    C c = <span class="keyword">new</span> C();</div><div class="line">    c.say(); <span class="comment">//B</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果输出B。</p><p>可以看出，子类优先继承父类的方法，如果父类没有相同签名的方法，才继承接口的默认方法。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>更复杂的继承关系可以简化成以上的继承关系。</p><p>根据以上的例子， 可以得出以下的结论：</p><ul><li>类优先于接口，如果一个子类继承的父类和接口有相同的方法实现，那么子类继承父类的方法。</li><li>子类型中的方法优先于父类型中的方法。</li><li>如果以上条件都不满足， 则必须显示覆盖/实现其方法，或者声明成abstract。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoC and DI</title>
      <link href="/2018/05/27/IoC-and-DI/"/>
      <url>/2018/05/27/IoC-and-DI/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>DI是IoC的一种特定形态，是Java开发主流中一个重要的编程范式（思维方式），是指寻找依赖项的过程不在当前执行代码的直接控制之下。简单的说，使用DI技术可以让对象从别处获得依赖项，而不是由它自己来构造。Java中为DI提供的容器有Guice、Spring、PicoContainer等。DI的好处有：松耦合、易测试、强内聚、可重用、更轻盈的代码。Java DI的官方标准是JSR-330。 </p><p>使用IoC范式编程时，程序逻辑的流程通常是由一个功能中心来控制的。而使用IoC，这个“中心控制”的设计原则会被反转过来。调用者的代码处理程序的执行顺序，而程序逻辑则被封装在接受调用的子流程中。通过一个例子来理解IoC：</p><blockquote><p>在GUI应用中，GUI框架负责控制调用事件处理器，而不是应用逻辑。当用户点击了一个动作，比如“向前”，GUI框架会自动调用 对应的事件处理器，而应用逻辑可以把重点放在处理动作上。程序的控制被反转了，将控制权由应用逻辑转移到了GUI框架。</p></blockquote><p>IoC也被称为好莱坞原则：会有另一段代码拥有最初的控制线程，并且由它来调用你的代码，而不是由你的代码调用它。（<code>不要给我们打电话，我们会打给你。——好莱坞原则</code>）</p><p>IoC有多种不同的实现，包括工厂模式、服务器定位模式，当然还有依赖注入。<strong>需要注意的是，DI并不等于IoC，DI只是IoC的一种实现方式，IoC是一种机制。</strong></p><a id="more"></a><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们首先编写传统的代码，然后使用工厂模式解耦，进而再使用DI来改进代码，通过这个过程，你将了解到DI的精妙之处。这些改进都基于同一个关键技术，即面向接口编程。</p><p>假设你想找到所有对Java可开发人员比较友善的好莱坞经纪人。首先，我们有了一个AgentFinder接口，及其两个实现类SpreadSheetAgentFinder和WebServiceAgentFinder。AgentFinder接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AgentFinder</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Agent&gt; <span class="title">findAllAgents</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h4><p>为了找到经纪人，项目中有个默认的HollywoodService类，它会从SpreadSheetAgentFinder里得到一个经纪人列表，并且过滤出友善的经纪人，最终返回该列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HollywoodService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Agent&gt; <span class="title">getFriendlyAgents</span><span class="params">()</span> </span>&#123;</div><div class="line">        AgentFinder finder = <span class="keyword">new</span> SpreadsheetAgentFinder();</div><div class="line">        List&lt;Agent&gt; agents = finder.findAllAgents();</div><div class="line">        List&lt;Agent&gt; friendlyAgents = filterAgents(agents,<span class="string">"Java Developers"</span>);</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> friendlyAgents;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//filterAgents</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是最传统的编码方式，显然，HollywoodService被SpreadsheetAgentFinder这个AgentFinder的具体实现死死的绑定住了。</p><p>为了改进这个问题，通常我们会想到一个常用的设计模式——工厂模式。工厂模式可以一定程度上解耦程序，它也是IoC的一种实现方式。</p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>利用工厂模式（其实这里用到的是一个简单工厂）重新编写上面的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Agent&gt; <span class="title">getFriendlyAgents</span><span class="params">(String agentFinderType)</span> </span>&#123;</div><div class="line">    AgentFinderFactory factory = AgentFinderFactory.getInstance();</div><div class="line">    AgentFinder finder = factory.getAgentFinder(agentFinderType);</div><div class="line">    List&lt;Agent&gt; agents = finder.findAllAgents();</div><div class="line">    <span class="keyword">return</span> filterAgents(agents, <span class="string">"Java Developers"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如你所见，这里不再有具体的实现来黏住你，而是通过注入agentFinderType的方式让你选择想要的AgentFinder。但这里仍然还有问题：</p><ol><li>代码注入的仅仅是一个引用凭据（agentFinderType），而不是真正实现AgentFinder的对象。</li><li>方法getFriendlyAgents中还有获取其依赖的代码，达不到只关注自身智能的理想状态，我们需要通过DI来达成这两个目标。</li></ol><h4 id="手工实现DI"><a href="#手工实现DI" class="headerlink" title="手工实现DI"></a>手工实现DI</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Agent&gt; <span class="title">getFriendlyAgents</span><span class="params">(AgentFinder finder)</span></span>&#123;</div><div class="line">    List&lt;Agent&gt; agents = finder.findAllAgents();</div><div class="line">    <span class="keyword">return</span> filterAgents(agents,<span class="string">"Java Developers"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的代码是一个纯手工打造的DI方案，AgentFinder被直接注入到getFriendlyAgents方法中。现在这个getFriendlyAgents方法干净利落，只专注于纯业务逻辑。</p><p>但是，这种手工方式的DI显然存在问题，如何配置AgentFinder具体实现的问题并没有解决，原本AgentFinderFactory要做的工作还是要找一个地方去做。解决这个问题的方式是借助DI框架，而DI框架就是把你的代码打包起来的运行时环境，在你需要的时候注入依赖项。</p>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 调优</title>
      <link href="/2018/05/12/JVM-%E8%B0%83%E4%BC%98/"/>
      <url>/2018/05/12/JVM-%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h3 id="JDK配置"><a href="#JDK配置" class="headerlink" title="JDK配置"></a>JDK配置</h3><p><img src="/images/Java/2018051201.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Xms512m -Xmx1024m -XX:PermSize=256M -XX:MaxPermSize=512M -Dmaven.multiModuleProjectDirectory=$M2_HOME</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-Xms512m JVM初始分配的堆内存</div><div class="line">-Xmx1024m JVM最大允许分配的堆内存，按需分配</div><div class="line">-XX:PermSize=256M JVM初始分配的非堆内存</div><div class="line">-XX:MaxPermSize=512M JVM最大允许分配的非堆内存，按需分配</div></pre></td></tr></table></figure><a id="more"></a><table><thead><tr><th>参数名</th><th>含义</th><th>默认值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td style="text-align:left">默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制。</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td style="text-align:left">默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or lator)</td><td></td><td style="text-align:left"><strong>注意</strong>：此处的大小是（eden+ 2 survivor space)，与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。增大年轻代后，将会减小年老代大小，此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td style="text-align:left">-</td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td style="text-align:left">-</td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td style="text-align:left">-</td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td style="text-align:left">-</td></tr></tbody></table><h3 id="Tomcat配置"><a href="#Tomcat配置" class="headerlink" title="Tomcat配置"></a>Tomcat配置</h3><p>编辑TOMCAT_HOME/bin/catalina.bat，在第二行中插入如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set JAVA_OPTS=-server -Xms1024m -Xmx1024m -XX:PermSize=64M -XX:MaxNewSize=512m -XX:MaxPermSize=128m</div></pre></td></tr></table></figure><p>一般设置-Xms、-Xmx 相等以避免在每次GC 后调整堆的大小。</p><p><img src="/images/Java/2018051202.png" alt=""></p><h3 id="Eclipse配置"><a href="#Eclipse配置" class="headerlink" title="Eclipse配置"></a>Eclipse配置</h3><p>编辑eclipse安装目录下eclipse.ini配置文件，最后添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-Dosgi.requiredJavaVersion=1.7</div><div class="line">-Xms1024m</div><div class="line">-Xmx2048m</div><div class="line">-Xmn384m</div><div class="line">-XX:PermSize=128m</div><div class="line">-XX:MaxPermSize=512M</div><div class="line">-XX:+UseParallelGC</div><div class="line">-XX:+DisableExplicitGC</div><div class="line"># 编辑器语言配置项</div><div class="line">-nl zh</div></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>-XX:+UseParallelGC</td><td>Full GC采用parallel MSC</td><td>默认不启用，-server时启用</td><td>新生代使用并行清除，年老代使用单线程Mark-Sweep-Compact清除的垃圾收集器。</td></tr><tr><td>-XX:+DisableExplicitGC</td><td>禁止代码中显示调用GC</td><td>默认不启用</td><td>如果加上了这个JVM启动参数，那么代码中调用System.gc()没有任何效果，相当于是没有这行代码一样。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 补丁使用</title>
      <link href="/2018/04/19/Git-%E8%A1%A5%E4%B8%81%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/04/19/Git-%E8%A1%A5%E4%B8%81%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="补丁说明"><a href="#补丁说明" class="headerlink" title="补丁说明"></a>补丁说明</h3><h4 id="使用补丁场景："><a href="#使用补丁场景：" class="headerlink" title="使用补丁场景："></a>使用补丁场景：</h4><p>可以只更新自己关心的功能；（对功能的选择性更新，但因为应用补丁的环境不同，可能会发生冲突）</p><h4 id="补丁后缀说明："><a href="#补丁后缀说明：" class="headerlink" title="补丁后缀说明："></a>补丁后缀说明：</h4><p> .patch结尾文件</p><h3 id="补丁生成"><a href="#补丁生成" class="headerlink" title="补丁生成"></a>补丁生成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git format-patch -1 [commit ID]</div></pre></td></tr></table></figure><p>在Git中，每个commit ID的信息（如cc127537978af35e2f502da7e8d22e340ed810e5）就是一个SHA-1 Hash值，它是对那个commit是Git仓库中内容和头信息（Header）的一个校验和（checksum）。它可以保证，在很多年后，你重新checkout某个commit时，一定是它多年前的当时的状态。Git中，根据commit的SHA-1值（40个十六进制数字）进行了简单的划分目录，以前2位数字作为目录名，其下面是剩余38位数字组成的一个文件名。</p><a id="more"></a><h3 id="补丁应用"><a href="#补丁应用" class="headerlink" title="补丁应用"></a>补丁应用</h3><p>1）使用文本编辑器打开补丁；</p><p>2）使用ctrl + a 全选补丁内容；</p><p>3）ctrl + c 复制选择的内容；</p><p>4）打开eclipse，右侧项目随便选一个</p><p><img src="/images/Git/2018041901.png" alt=""></p><p><strong>注：选择Clipboard，选择其他的会出现乱码；</strong></p><p><img src="/images/Git/2018041902.png" alt=""></p><p>5）点击【按钮】；</p><p><strong>注：如果没有复制补丁内容在选择Clipboard时下方的【Next】按钮则是灰色的。</strong></p><p><img src="/images/Git/2018041903.png" alt=""></p><p><img src="/images/Git/2018041904.png" alt=""></p><p>选择1；</p><p><img src="/images/Git/2018041905.png" alt=""></p><p>记得勾选上 (勾选后，如果发生冲突、无法匹配的情况，将生成*.rej文件)；</p><p>6）点击【Finish】按钮，完成补丁应用（应用补丁的过程不会提交代码，只是修改本地文件）；</p><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>1）出现X号</p><p><img src="/images/Git/2018041906.png" alt=""></p><p>点击finish；</p><p>2）搜索所有rej文件，全部选中，打开（Ctrl+Shift+R打开这个搜索界面）</p><p><img src="/images/Git/2018041907.png" alt=""></p><p>3）rej文件，手动应用</p><p><img src="/images/Git/2018041908.png" alt=""></p><p>.rej前的就是需要打补丁的文件，搜索进入这个文件；<br>.rej下面代码前是“+”则是代表在对应的位置添加代码，“-”则是删除代码；<br>理解rej文件含义后，进行手动应用；<br>应用完后，删除rej文件；</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux用户管理常用命令</title>
      <link href="/2018/04/06/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/04/06/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="用户管理（user）"><a href="#用户管理（user）" class="headerlink" title="用户管理（user）"></a>用户管理（user）</h3><p><code>useradd</code> 注：添加用户<br><code>adduser</code> 注：添加用户<br><code>passwd</code> 注：为用户设置密码<br><code>usermod</code> 注：修改用户命令，可以通过usermod 来修改登录名、用户的家目录等等；<br><code>pwcov</code> 注：同步用户从/etc/passwd 到/etc/shadow<br><code>pwck</code> 注：pwck是校验用户配置文件/etc/passwd 和/etc/shadow 文件内容是否合法或完整；<br><code>pwunconv</code> 注：是pwcov 的立逆向操作，是从/etc/shadow和 /etc/passwd 创建/etc/passwd ，然后会删除/etc/shadow 文件；<br><code>finger</code> 注：查看用户信息工具<br><code>id</code> 注：查看用户的UID、GID及所归属的用户组<br><code>chfn</code> 注：更改用户信息工具<br><code>su</code> 注：用户切换工具<br><code>sudo</code> 注：sudo 是通过另一个用户来执行命令（execute a command as another user），su 是用来切换用户，然后通过切换到的用户来完成相应的任务，但sudo 能后面直接执行命令，比如sudo 不需要root 密码就可以执行root 赋与的执行只有root才能执行相应的命令；但得通过visudo 来编辑/etc/sudoers来实现；<br><code>visudo</code> 注：visodo 是编辑 /etc/sudoers 的命令；也可以不用这个命令，直接用vi 来编辑 /etc/sudoers 的效果是一样的；<br><code>sudoedit</code> 注：和sudo 功能差不多； </p><a id="more"></a><h3 id="用户组管理（group）"><a href="#用户组管理（group）" class="headerlink" title="用户组管理（group）"></a>用户组管理（group）</h3><p><code>groupadd</code> 注：添加用户组；<br><code>groupdel</code> 注：删除用户组；<br><code>groupmod</code> 注：修改用户组信息<br><code>groups</code> 注：显示用户所属的用户组<br><code>grpck</code><br><code>grpconv</code> 注：通过/etc/group和/etc/gshadow 的文件内容来同步或创建/etc/gshadow ，如果/etc/gshadow 不存在则创建；<br><code>grpunconv</code> 注：通过/etc/group 和/etc/gshadow 文件内容来同步或创建/etc/group ，然后删除gshadow文件； </p><h3 id="建立一个新用户"><a href="#建立一个新用户" class="headerlink" title="建立一个新用户"></a>建立一个新用户</h3><p>建立一个新的用户包括两个步骤，第一步是使用useradd命令完成一个新用户的初始化设置工作；第二步是用passwd为这个新用户设置密码。例如，我们要给系统添加一个用户叫floatboat，密码为fan2001z，那相关的操作是： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">useradd floatboat &lt;回车&gt; </div><div class="line">这时候系统没有任何显示。接着： </div><div class="line">passwd floatboat &lt;回车&gt; </div><div class="line">系统显示： </div><div class="line">Changing password for user floatboat </div><div class="line">New UNIX password: </div><div class="line">你输入： </div><div class="line">fan2001z&lt;回车&gt; </div><div class="line">注意，由于linux并不采用类似windows的密码回显（显示为*号）——为避免你输入密码时被人</div><div class="line">注意到有多少位——所以，输入的这些字符你是看不见的。 </div><div class="line">系统显示： </div><div class="line">Retype new UNIX password: </div><div class="line">你再重新输入一次密码，然后回车确认，这时系统会显示： </div><div class="line">passwd:all authentication tokens updated successfully </div><div class="line">表示你修改密码成功了。 </div><div class="line">到这里，新用户的创建工作就算完成了。</div></pre></td></tr></table></figure><p>下面，我们再补充一些有关增加新用户的常识： </p><ol><li><p>useradd所做的初始化操作已经包括在/home目录下为floatboat帐号建立一个名为floatboat的主目录。如果你不想使用这个缺省的目录，而希望把他的主目录放在/home/goal里（还放在/home下，只是一种良好的习惯，没有其他什么特别的要求），可以使用useradd的参数-d，命令如下： useradd -d /home/goal floatboat </p></li><li><p>useradd的初始化操作还包括为用户单独建立一个与用户名同名的组（floatboat组）。这叫用户私有组的机制，与默认组机制相对应。对用户分组一是方便管理，二是可以明确权限。复杂的我们将在以后的深入内容中探讨。我们如果想让此用户加入一个已有的组的话，可以使用-g参数。例如我们想让floatboat加入webusers组，那么可以使用以下命令： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd -g webusers floatboat</div></pre></td></tr></table></figure><p>同样的，我们还可以使用-G参数使他同时加入多个组，例如webusers和ftpusers： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd -G ftpusers,webusers floatboat</div></pre></td></tr></table></figure></li><li><p>passwd命令为一个用户设置密码，但它实质上是一个修改密码的程序。只有超级用户和用户自己可以修改密码，其它的普通用户没有给他修改密码的权利。用户密码的组成要尽量的复杂，最好包括字母、数字和特殊符号，而且最好设成6位以上。太短passwd程序不允许，只是单纯的字母或单纯的数字， passwd也会有意见。你都会看见passwd出现的提示的，不要害怕，仔细看看到底它是怎么说的：） </p></li><li><p>你在增加一个新用户的时候，也可以设置用户登录的shell。缺省的，系统提供了/bin/bash。你如果非要指定的话，可以使用-s 参数就可以了。例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd -d /www -s /usr/bin/passwd floatboat</div></pre></td></tr></table></figure><p>注意，这些参数是可以一块使用的，如上例所示，它表示增加新用户，并把其主目录路径设置在/www，登录的shell为/usr/bin/passwd。关于shell的更详细的说明，请参考下面的修改用户的个人设置相关内容。 </p></li><li><p>删除一个用户可以使用userdel命令，直接带用户名做参数就可以了。 </p></li></ol><h3 id="修改用户的设置"><a href="#修改用户的设置" class="headerlink" title="修改用户的设置"></a>修改用户的设置</h3><p>对现有用户的修改，比较常用的主要是修改密码（使用passwd就好了），修改用户的登录shell，修改用户所属的默认组，设置帐号有效期，修改用户的说明信息等等，偶尔也会用到修改用户主目录。 </p><h4 id="修改用户的登录shell"><a href="#修改用户的登录shell" class="headerlink" title="修改用户的登录shell"></a>修改用户的登录shell</h4><p>使用chsh命令可以修改自己的shell，只有超级用户才能用chsh username为其它用户修改shell设置。注意，指定的shell必须是列入/etc/shells文件中的shell，否则该用户将不能登陆。<br>一般，比较常见的shells文件包括下面这些shell： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/bin/bash2 </div><div class="line">/bin/bash </div><div class="line">/bin/sh </div><div class="line">/bin/ash </div><div class="line">/bin/bsh </div><div class="line">/bin/tcsh </div><div class="line">/bin/csh</div></pre></td></tr></table></figure><p>而网管们还喜欢在里面加上/usr/bin/passwd，这是为了不让用户通过控制台或telnet登录系统，却可以使用修改帐户密码（比如在FTP里用）。以及/bin/false，也就是不让这个用户登录的意思喽^&amp;^，连FTP也不能用。<br>你也可以使用usermod命令修改shell信息，如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod -s /bin/bash floatboat</div></pre></td></tr></table></figure><p>其中/bin/bash和floatboat应取相应的shell路径文件名及用户名。<br>还有一种情况，就是你为用户设置了一个空的shell（就是””），也就是说，这个用户没有shell。呵呵，绝对没有在我还未曾见过，因为这种用户登录后，系统还是会给它一个shell用的。不信你试试： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod -s &quot;&quot; floatboat</div></pre></td></tr></table></figure><p>这种用户根据系统的不同，会有一个sh或bash进行操作，我也没有看出功能上和其它普通用户登录有什么不同。 </p><h4 id="修改用户所属的默认组"><a href="#修改用户所属的默认组" class="headerlink" title="修改用户所属的默认组"></a>修改用户所属的默认组</h4><p>这个功能也可以通过usermod命令来实现，使用-g参数，例如把floatboat的默认组改为nobody，可以使用如下命令： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">username -g nobody floatboat</div></pre></td></tr></table></figure><p>nobody在类UNIX系统中一般都意味着没有任何权限。 </p><h4 id="设置帐号有效期"><a href="#设置帐号有效期" class="headerlink" title="设置帐号有效期"></a>设置帐号有效期</h4><p>如果使用了影子口令，则可以使用如下命令来修改一个帐号的有效期： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod -e MM/DD/YY username</div></pre></td></tr></table></figure><p>例如把用户floatboat的有效期定为2001年12月31日： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod -e 12/31/01 floatboat</div></pre></td></tr></table></figure><p>如果把该用户的有效期设为已经过去的时间，就可以暂时禁止该用户登录系统。 </p><h4 id="修改用户的说明信息"><a href="#修改用户的说明信息" class="headerlink" title="修改用户的说明信息"></a>修改用户的说明信息</h4><p>修改用户的说明信息，最简单的方法莫过于直接修改/etc/passwd文件，找到对应的用户记录行，例如下列行： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">floatboat:x:503:503::/home/floatboat:/bin/bash</div></pre></td></tr></table></figure><p>你可以直接在第四个冒号和第五个冒号之间插入该用户的说明就可以了。其实，很多用户设置都可以在这修改，比如该行最后一部分/bin/bash就是用户登录shell的设置。关于这个/etc/passwd文件，我们后面将进一步的深入探讨。 </p><h4 id="修改用户主目录"><a href="#修改用户主目录" class="headerlink" title="修改用户主目录"></a>修改用户主目录</h4><p>修改用户的主目录主要使用usermod命令的-d参数，例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod -d /www floatboat</div></pre></td></tr></table></figure><p>这一行将floatboat的主目录改到/www。如果想将现有主目录的主要内容转移到新的目录，应该使用-m开关，如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod -d -m /www floatboat</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解Java基本原理</title>
      <link href="/2018/04/06/%E5%9B%BE%E8%A7%A3Java%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2018/04/06/%E5%9B%BE%E8%A7%A3Java%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串不变性"><a href="#字符串不变性" class="headerlink" title="字符串不变性"></a>字符串不变性</h3><p>下面这张图展示了这段代码做了什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String s = &quot;abcd&quot;;</div><div class="line">s = s.concat(&quot;ef&quot;);</div></pre></td></tr></table></figure><p><img src="/images/Java/2018040601.png" alt=""></p><h3 id="equals-方法、hashCode-方法的区别"><a href="#equals-方法、hashCode-方法的区别" class="headerlink" title="equals()方法、hashCode()方法的区别"></a>equals()方法、hashCode()方法的区别</h3><p>HashCode被设计用来提高性能。equals()方法与hashCode()方法的区别在于：</p><ol><li><p>如果两个对象相等(equal)，那么他们一定有相同的哈希值。</p></li><li><p>如果两个对象的哈希值相同，但他们未必相等(equal)。</p><a id="more"></a></li></ol><p><img src="/images/Java/2018040602.png" alt=""></p><h3 id="Java异常类的层次结构"><a href="#Java异常类的层次结构" class="headerlink" title="Java异常类的层次结构"></a>Java异常类的层次结构</h3><p>图中红色部分为受检查异常。它们必须被捕获，或者在函数中声明为抛出该异常。</p><p><img src="/images/Java/2018040603.png" alt=""></p><h3 id="集合类的层次结构"><a href="#集合类的层次结构" class="headerlink" title="集合类的层次结构"></a>集合类的层次结构</h3><p>注意Collections和Collection的区别。（Collections包含有各种有关集合操作的静态多态方法）</p><p><img src="/images/Java/2018040604.png" alt=""></p><h3 id="Java同步"><a href="#Java同步" class="headerlink" title="Java同步"></a>Java同步</h3><p>Java同步机制可通过类比建筑物来阐明。</p><p><img src="/images/Java/2018040605.png" alt=""></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>别名意味着有多个变量指向同一可被更新的内存块，这些别名分别是不同的对象类型。</p><p><img src="/images/Java/2018040606.png" alt=""></p><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>图解表明了方法和对象在运行时内存中的位置。</p><p><img src="/images/Java/2018040607.png" alt=""></p><h3 id="Java虚拟机运行时数据区域"><a href="#Java虚拟机运行时数据区域" class="headerlink" title="Java虚拟机运行时数据区域"></a>Java虚拟机运行时数据区域</h3><p>图解展示了整个虚拟机运行时数据区域的情况。</p><p><img src="/images/Java/2018040608.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Class对象及反射</title>
      <link href="/2018/04/05/Java-Class%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%8D%E5%B0%84/"/>
      <url>/2018/04/05/Java-Class%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>为了大家方便理解Java反射机制，建议先阅读<a href="../Java核心概念">《Java核心概念》</a></p><h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><p>当ClassLoader加载一个class文件到JVM的时候，会自动创建一个该类的Class对象，并且这个对象是唯一的，后续要创建这个类的任何实例，都会根据这个Class对象来创建。因此每当加载一个class文件的时候，都会创建一个与之对应的Class对象。</p><ul><li>解析一个类的各个部分，形成一个对象。</li></ul><p><img src="/images/Java/2018040510.png" alt=""></p><ul><li><p>外存中的类，加载到内存中，会形成该对象的Class类，例如：String类，加载到内存中，就是StringClass对象。</p></li><li><p>也就是说类是java.lang.Class类的实例对象，而Class是所有类的类。</p><a id="more"></a></li></ul><p>对于普通的对象，一般都的创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String s = <span class="keyword">new</span> String();</div></pre></td></tr></table></figure><ul><li>既然类都是Class的对象，那么能否像普通对象一样创建呢，当看源码时，是这样写的：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">(ClassLoader loader)</span></span>&#123;</div><div class="line">classLoader = loader;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>源码里构造器是私有的，只有JVM可以创建Class的对象，虽然我们不能new一个Class对象，但是可以从已有的类得到一个Class对象，共有三种方式，如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 类名.class 通过获取类的静态成员变量class得到(任何类都有一个隐含的静态成员变量class)</span></div><div class="line">Class&lt;?&gt; clazz = String.class;</div><div class="line"><span class="comment">// 对象.getClass</span></div><div class="line">Class&lt;?&gt; clazz2 = <span class="keyword">new</span> String().getClass();</div><div class="line"><span class="comment">// Class.forName("全量限定名")</span></div><div class="line">Class&lt;?&gt; clazz3 = Class.forName(<span class="string">"java.lang.String"</span>);</div></pre></td></tr></table></figure><ul><li>（注意： 这三种方式都是利用反射获取的都是同一个Class对象，这也叫做String的类类型，也就是描述何为类，一个类都有哪些东西，所以可以通过类类型知道一个类的属性和方法，并可以调用一个类的属性和方法，这就是反射的基础。）</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射是指<code>在程序的运行期间动态的去操作某个Class对象里面的成员</code>（包括类信息、属性信息、方法信息等元素）。它可以让Java这种静态语言具备一定的动态性。目前大部分的开源框架实现都是基于反射的机制实现。</p><p>JVM → 类加载 → class文件 → 创建 → Class对象 → 构建类的实例 → instance(实例)；<br>重点在运行时动态的操作Class对象。</p><h3 id="反射机制的利与弊"><a href="#反射机制的利与弊" class="headerlink" title="反射机制的利与弊"></a>反射机制的利与弊</h3><p>为何要用反射机制？直接new对象不ok了吗，这就涉及到了动态与静态的概念</p><ul><li>静态编译：在编译时确定类型，绑定对象，即通过。</li><li>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有利于降低类之间的藕合。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>可以实现动态创建对象和编译。比如，一个软件，不可能第一个版本就把它设计的很完美，当这个程序编译成功，发布后，当发现某些功能需要更新时，我们不可能要用户把旧版的卸载，再重新安装新的版本。</li><li>采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</li></ul><p>一句话总结：<code>运行期类型的判断，动态类加载，动态代理就使用了反射</code></p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>对性能有影响。反射相当于一系列解释操作，通知JVM要做的事情。性能比直接的java代码执行相同的操作要慢很多。</li><li>由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li></ul><h3 id="反射机制的相关操作"><a href="#反射机制的相关操作" class="headerlink" title="反射机制的相关操作"></a>反射机制的相关操作</h3><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在反射操作之前的第一步，就是要先获取Class对象</span></div><div class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"org.demo.bean.People"</span>);</div><div class="line"><span class="comment">// 根据Class对象创建一个实例</span></div><div class="line">clazz.newInstance();</div></pre></td></tr></table></figure><h4 id="动态操作属性"><a href="#动态操作属性" class="headerlink" title="动态操作属性"></a>动态操作属性</h4><ul><li>通过Class对象可以动态的获取和操作类中的属性，属性在JDK中有一个类来进行封装，就是Field,Field提供了一些常用的API方法让我们去访问和操作类中的属性</li></ul><p><code>getField()</code>// 获取所有公开的属性字段（包括继承父类的公有属性）<br><code>getDeclaredField()</code>// 获取本类所有（包括公有和私有，但是不包括父类的）的属性字段（注意：如果要访问和操作私有属性，必须调用setAccessible方法，打开访问开关）<br><code>getFields()</code>// 获取所有公有的属性（包括继承自父类的公有属性）<br><code>getDeclaredFields()</code> // 获取本类所有的属性（包括共有和私有的，但是不包括父类的）<br><code>set()</code>// 给属性赋值，需要传入两个参数，第一个参数是当前类的一个实例，第二个参数是具体要赋予的值<br><code>get()</code>// 获取属性的值，需要传入一个当前类的实例作为参数<br><code>getName()</code>// 获取属性的名称<br><code>getType()</code>// 获取属性的类型<br><code>isAnnotationPresent()</code>// 判断该属性上是否定义了指定的注解，需要传入一个注解的Class对象作为参数<br><code>getAnnotation()</code>// 获取当前属性上的注解对象，需要传入一个注解的Class对象作为参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>throwsException</span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 在反射操作之前的第一步，就是要先获取Class对象</span></div><div class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">"org.demo.bean.People"</span>);</div><div class="line">    <span class="comment">// 根据Class对象创建一个实例</span></div><div class="line">    Object instance = clazz.newInstance();</div><div class="line">    <span class="comment">// 获取指定的属性</span></div><div class="line">    Field f1 = clazz.getField(<span class="string">"userName"</span>);</div><div class="line">    <span class="comment">// 获取属性的值,get方法需要传入一个当前类的实例</span></div><div class="line">    Object value = f1.get(instance);</div><div class="line">    System.out.println(value);</div><div class="line"></div><div class="line">    <span class="comment">// 通过反射给属性赋值</span></div><div class="line">    <span class="comment">// 第一个参数是当前类的实例，第二个参数是要赋予的值</span></div><div class="line">    f1.set(instance, <span class="string">"godql"</span>);</div><div class="line">    value = f1.get(instance);</div><div class="line">    System.out.println(value);</div><div class="line"></div><div class="line">    <span class="comment">// 获取一个私有的属性</span></div><div class="line">    <span class="comment">// 如果需要访问和操作私有的成员，必须打开访问开关</span></div><div class="line">    <span class="comment">// 打开访问开关其实就是破坏封装</span></div><div class="line">    Field f2 = clazz.getDeclaredField(<span class="string">"age"</span>);</div><div class="line">    <span class="comment">// 强制打开访问权限</span></div><div class="line">    f2.setAccessible(<span class="keyword">true</span>);</div><div class="line">    Object value2 = f2.get(instance);</div><div class="line">    System.out.println(value2);</div><div class="line">    f2.set(instance, <span class="number">30</span>);</div><div class="line">    value2 = f2.get(instance);</div><div class="line">    System.out.println(value2);</div><div class="line"></div><div class="line">    <span class="comment">// 获取属性的名称</span></div><div class="line">    System.out.println(f1.getName());</div><div class="line">    System.out.println(f2.getName());</div><div class="line"></div><div class="line">    <span class="comment">// 获取属性的类型</span></div><div class="line">    System.out.println(f1.getType());</div><div class="line">    System.out.println(f2.getType());</div><div class="line"></div><div class="line">    <span class="comment">// 获取所有公有的属性(包括继承自父类的公有属性)</span></div><div class="line">    Field[] fs1 = clazz.getFields();</div><div class="line">    <span class="comment">// 获取本类所有的属性（包括共有和私有的，但是不包括父类的）</span></div><div class="line">    Field[] fs2 = clazz.getDeclaredFields();</div><div class="line"></div><div class="line">    <span class="comment">// 判断当前属性上是否定义了注解</span></div><div class="line">    System.out.println(f1.isAnnotationPresent(MyAnno.class));</div><div class="line">    System.out.println(f2.isAnnotationPresent(MyAnno.class));</div><div class="line"></div><div class="line">    <span class="comment">// 获取属性上定义的注解</span></div><div class="line">    MyAnno anno = f1.getAnnotation(MyAnno.class);</div><div class="line">    <span class="comment">// 获取注解上的属性值</span></div><div class="line">    System.out.println(anno.name());</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="动态操作方法"><a href="#动态操作方法" class="headerlink" title="动态操作方法"></a>动态操作方法</h4><ul><li>对于Class中的方法，API也提供了相应的类来进行封装，就是Method</li></ul><p><code>getMethod()</code>// 获取指定的公共的方法（包括继承自父类公共的），需要传递两个参数，第一个参数是方法名称，第二个参数是一个可变参数，传递的是方法参数的类型<br><code>getMethods()</code>// 获取所有的公共的方法（包括继承父类的公共方法）。<br><code>getDeclaredMethod()</code>// 获取本类中指定的方法（包括私有和共有的，不包括父类的），需要传递两个参数，第一个参数是方法名称，第二个参数是一个可变参数，传递的是方法参数的类型。如果是私有方法，同样需要先打开访问开关(setAccessible(true))。<br><code>getDeclaredMethods()</code>// 获取本地中所有的方法（包括私有和公共的，不包括父类）<br><code>getName()</code>// 获取方法名称<br><code>getReturnType()</code>// 获取方法的返回值类型<br><code>getParameterTypes()</code>// 获取方法中所有的参数类型<br><code>getParameterCount()</code>// 获取方法中参数的总个数<br><code>getParameters()</code>// (JDK1.8新特性)获取方法中所有的参数信息，每一个参数信息都是一个Parameter类的对象。可以通过这个对象获取各个参数的类型以及名称(注意：如果要获取参数名，在编译的时候需要加上一个parameters参数，如：javac -parameters Xxx.java。或者是在开发环境中设置相应的编译选项)。<br><code>invoke()</code>// 回调当前方法,需要传递两个参数，第一个是当前类的实例，第二个是一个可变参数，需要传入调用方法是所需的参数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>throwsException</span>&#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">"org.demo.bean.People"</span>);</div><div class="line">    Object instance = clazz.newInstance();</div><div class="line">    <span class="comment">// 获取指定的Method</span></div><div class="line">    Method m1 = clazz.getMethod(<span class="string">"say"</span>, String.class, <span class="keyword">int</span>.class);</div><div class="line">    <span class="comment">// 获取方法名</span></div><div class="line">    System.out.println(m1.getName());</div><div class="line">    <span class="comment">// 获取方法的返回值类型</span></div><div class="line">    System.out.println(m1.getReturnType());</div><div class="line">    <span class="comment">// 获取方法的所有参数类型</span></div><div class="line">    Class&lt;?&gt;[] paramsType = m1.getParameterTypes();</div><div class="line">    <span class="keyword">for</span> (Class&lt;?&gt; c : paramsType) &#123;</div><div class="line">    System.out.println(c);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获取参数名称（JDK1.8开始支持）</span></div><div class="line">    Parameter[] params = m1.getParameters();</div><div class="line">    <span class="keyword">for</span> (Parameter p : params) &#123;</div><div class="line">    System.out.println(<span class="string">"参数类型:"</span>+p.getType());</div><div class="line">    System.out.println(<span class="string">"参数名称:"</span>+p.getName());</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通过当前的方法，获取定义这个方法的类</span></div><div class="line">    Class&lt;?&gt; c = m1.getDeclaringClass();</div><div class="line">    System.out.println(c.getName());</div><div class="line">    </div><div class="line">    <span class="comment">// 方法回调，目的就是通过反射去调用一个方法</span></div><div class="line">    m1.invoke(instance, <span class="string">"godql"</span>, <span class="number">21</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="动态操作构造方法"><a href="#动态操作构造方法" class="headerlink" title="动态操作构造方法"></a>动态操作构造方法</h4><ul><li>Constructor是在反射API中用于封装构造方法的一个类，因此通过这个类可以获取构造方法的一些信息，以及通过这个对象来实例化一个类的实例。</li></ul><p><code>getConstructor()</code>// 获取无参并且公共的构造方法<br><code>getDeclaredConstructor()</code>// 获取一个构造方法可以是私有的也可以是公共的，需要传入一个可变参数，就是构造方法的参数类型（注意：如果是私有的，必须先打开访问开关）<br><code>newInstance()</code>// 通过构造方法创建实例，也需要传入一个可变参数，传入的是具体的值<br><code>getConstructors()</code>// 获取所有公共的构造方法，返回的是一个Constructor数组<br><code>getDeclaredConstructors()</code>// 获取所有的构造方法(包括私有和共有的),同样返回的是一个数组<br><code>getParameters()</code>// 获取所有的参数对象，和Method一样<br><code>getParameterTypes()</code>// 获取所有的参数类型，同Method一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>throwsException</span>&#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; clazz = People.class;</div><div class="line">    <span class="comment">// 获取无参的构造方法</span></div><div class="line">    Constructor&lt;?&gt; c1 = clazz.getConstructor();</div><div class="line">    <span class="comment">// 获取构造方法的名称</span></div><div class="line">    System.out.println(c1.getName());</div><div class="line">    <span class="comment">// 获取一个私有并且带参数的构造方法</span></div><div class="line">    Constructor&lt;?&gt; c2 = clazz.getDeclaredConstructor(String.class);</div><div class="line">    </div><div class="line">    <span class="comment">// 可以通过构造方法实例化一个对象</span></div><div class="line">    <span class="comment">//（注意：如果默认有一个无参并且是公共的构造方法，</span></div><div class="line">    <span class="comment">// 那么可以直接使用class.newInstance()方法创建实例，</span></div><div class="line">    <span class="comment">// 如果构造方法是私有的，或者是带参数的，就必须先获取</span></div><div class="line">    <span class="comment">// Constructor对象，在通过这个对象来创建类实例）</span></div><div class="line">    </div><div class="line">    <span class="comment">// 1.适用于无参并且是公共的构造方法</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">    Object instance = clazz.newInstance();</div><div class="line">    System.out.println(instance);</div><div class="line">    */</div><div class="line">    </div><div class="line">    <span class="comment">// 2.适用于带参数或是私有的构造方法</span></div><div class="line">    <span class="comment">// 由于构造方法也可以私有化，所以必须先打开访问开关</span></div><div class="line">    c2.setAccessible(<span class="keyword">true</span>);</div><div class="line">    Object instance = c2.newInstance(<span class="string">"godql"</span>);</div><div class="line">    System.out.println(instance);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取所有public修饰的构造方法</span></div><div class="line">    Constructor&lt;?&gt;[] cons = clazz.getConstructors();</div><div class="line">    <span class="comment">// 获取所有构造方法（包括私有的）</span></div><div class="line">    Constructor&lt;?&gt;[] cons2 = clazz.getDeclaredConstructors();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Class中的一些API"><a href="#Class中的一些API" class="headerlink" title="Class中的一些API"></a>Class中的一些API</h4><ul><li>Class对象本身提供了很多的API方法用于获取和操作Class对象。</li></ul><p><code>getPackage()</code>// 获取当前类所在的包，使用Package对象进行封装，可以从中获取包的信息，例如：包名<br><code>getSimpleName()</code>// 获取当前类的简单类名（不包括包名）<br><code>getName()</code>// 获取当前类的完整类名(包括包名)<br><code>getSuperclass()</code>// 获取当前类的父类，返回的也是一个Class对象<br><code>getInterfaces()</code>// 获取当前类所实现的所有接口，返回的是一个Class数组<br><code>isAnnotationPresent()</code>// 判断当前类上是否定义了注解<br><code>getAnnotation()</code>// 获取类上定义的注解</p><h3 id="通过反射了解集合泛型的本质"><a href="#通过反射了解集合泛型的本质" class="headerlink" title="通过反射了解集合泛型的本质"></a>通过反射了解集合泛型的本质</h3><ul><li>Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译到了运行期就无效了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"></div><div class="line">    List list = <span class="keyword">new</span> ArrayList();</div><div class="line">    List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    </div><div class="line">    list.add(<span class="string">"godql"</span>);</div><div class="line">    <span class="comment">// list1.add(20); 错误的</span></div><div class="line">    </div><div class="line">    Class c1 = list.getClass();</div><div class="line">    Class c2 = list1.getClass();</div><div class="line">    </div><div class="line">    System.out.println(c1 == c2); <span class="comment">// 结果：true，说明类类型完全相同</span></div><div class="line">    <span class="comment">// 反射的操作都是编译之后的操作(运行时)</span></div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">    以上说明编译之后集合的泛型是泛型擦除的</div><div class="line">    Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译就无效了。</div><div class="line">    验证: 通过方法的反射来操作，绕过编译</div><div class="line">    */</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 通过动态操作方法的反射得到add方法</span></div><div class="line">        Method m = c2.getMethod(<span class="string">"add"</span>, Object.class);</div><div class="line">        <span class="comment">// 方法回调 给list1添加一个int型的，这是在运行时的操作，所以编译器编译时</span></div><div class="line">        <span class="comment">// 没有泛型检查，所以不会报错</span></div><div class="line">        <span class="comment">// 绕过编译操作</span></div><div class="line">        m.invoke(list1, <span class="number">20</span>);</div><div class="line">        <span class="comment">// 验证是否有添加进list集合里</span></div><div class="line">        System.out.println(list1.size());</div><div class="line">        <span class="comment">// 这时候不能使用foreach遍历，否则集合会认为集合里边全是String类型的值</span></div><div class="line">        <span class="comment">// 且有类型转换错误，因为这个集合里面有int类型、String类</span></div><div class="line">        System.out.println(list1);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心概念</title>
      <link href="/2018/04/05/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/04/05/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>当JVM运行起来的时候就会给内存划分空间，那么这块空间称之为运行时数据区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 当一个Java源程序编译成class字节码文件之后，字节码文件里存放的都是二进制的汇编命令，</div><div class="line">  当程序运行的时候，JVM会将这个二进制的命令逐行解释，交给CPU去执行</div></pre></td></tr></table></figure><p>运行时数据区将划分为以下几块内容：</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li><p>每一个线程运行起来的时候就会对应一个栈（线程栈），栈当中存放的数据是被当前线程所独有的。而栈当中存放的是栈帧，当线程调用一个方法的时候，就会形成一个栈帧，并将这个栈帧进行压栈操作，当方法执行完之后就会将这个栈帧进行出栈操作。这个栈帧里面包括（局部变量、操作数栈、指向当前方法对应类的常量池引用、方法的返回地址等信息）。</p><a id="more"></a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 由于局部变量都是存放在栈中，而每一个线程都对应自己的线程栈，因此局部变量是线程安全</div><div class="line">  的，不会才产生资源共享的情况</div></pre></td></tr></table></figure><p><img src="/images/Java/2018040501.png" alt=""></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul><li>本地方法栈的机制和栈的机制类似，区别在于，栈是运行Java所实现的方法，而本地方法栈是运行的本地方法(Native Method)。所谓的本地方法指的是在本地jvm中需要调用非Java语言所实现的方法，例如c语言。在JVM的规范中，其实没有强制性要求实现方一定要划分出本地方法栈的和具体的实现，这一部分可以根据实现方具体要求来实现。因此在HotSport虚拟机的实现中就将方法栈和本地方法栈二合为一。</li></ul><p><img src="/images/Java/2018040502.png" alt=""></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul><li>程序计数器也可以称之为PC寄存器。它主要用于存放当前程序下一条将要执行的指令地址。CPU会根据这个地址找到对应的指令来执行。通俗的讲就是指令缓存。这个寄存器是有JVM内部实现的，并不是物理概念上的寄存器，但是JVM在实现功能的逻辑上是相同的。</li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li><p>堆内存中主要存放创建的对象以及数组。 堆内存是可以被多个线程所共享的一块区域,因此多个线程栈都可以去访问同一块堆的内存区域。堆里面的每一对象都存放了该实例的实例变量。</p></li><li><p>当在方法中定义了一个局部变量，如果这个变量是基本数据类型，那么这个变量的值就直接存放在栈中，如果这个变量是引用数据类型，那么这个对象变量就存放在堆内存中，而栈中存放的是一个指向堆内存中这个对象的首地址。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># Java中除了8个基本数据类型以外的所有类型都是引用数据类型</div></pre></td></tr></table></figure><ul><li>引用</li></ul><p><img src="/images/Java/2018040503.png" alt=""></p><ul><li>更改</li></ul><p><img src="/images/Java/2018040504.png" alt=""></p><ul><li>数组</li></ul><p><img src="/images/Java/2018040505.png" alt=""></p><ul><li>循环</li></ul><p><img src="/images/Java/2018040506.png" alt=""></p><blockquote><p>实例变量和静态变量的区别：</p><ul><li>实例变量： 实例变量是随着对象的创建而创建，而实例是存放在堆中，所以实例变量自然也就跟实例一并保存在堆内存。只要创建多少个实例，就会有多少份实例变量。当实例被回收的时候，实例变量也随之而销毁。</li><li>静态变量： 静态变量也叫类变量，它是在类加载的时候就已经初始化好，并存放在方法区，并且只有一份，所以它是被多个实例所共享的一个变量。</li></ul></blockquote><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li><p>方法区在JVM中也是一个非常重要的一块内存区域，它和堆一样，是可以被多个线程所共享的一块区域。这个区域中主要存放了每一个加载的class文件信息。</p></li><li><p>在一个class文件中主要包含<code>魔数</code>（代码中出现但没有解释的数字常量或字符串）（用来确定是否是一个class文件）、常量池（常量池在下面会有完整说明）、访问标志（当前的class是类还是接口，是否是抽象类，是否是public修饰，是否使用了<code>final</code>修饰等描述信息…）、字段表集合信息（使用什么访问修饰符、是实例变量还是静态变量，是否用<code>final</code>修饰等描述信息…）、方法表集合信息（访问修饰符，是否静态方法，是否用<code>final</code>修饰，是否用了<code>synchronized</code>修饰，是否是<code>native</code> 方法…）等内容。当一个类加载器加载一个class文件的时候，会根据这个class文件的内容创建一个Class对象，而这个Class对象就包括了上述的这些内容。后续要创建这个类的所有实例，都是通过这个Class对象创建出来的。</p><p><img src="/images/Java/2018040507.png" alt=""></p></li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul><li><p>常量池也是方法区中的一部分，它存放的内容是class文件中最重要的资源，JVM为每一个class对象都维护一个常量池。它主要存储两种类型的常量。</p></li><li><p>字面常量：通常就是在Java中定义的字面量值，如：int i =1,这个1就是字面量；String s = “abc”，这个abc就是字面量。或者使用final修饰的常量值等等。</p></li><li>符号引用：主要包括类和接口的完整类名、属性字段的名称和描述符、方法名称和描述符等信息</li></ul><p><img src="/images/Java/2018040508.png" alt=""></p><ul><li>在Java当中，8个基本数据类型都有对应的包装类型，而大部分包装类型都实现了常量池的技术，除了Double 和 Float 类。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># 在JDK8之后，方法区已经取消，方法区被一个叫MetaSpace，它和堆合并到一起管理</div></pre></td></tr></table></figure><ul><li><p>内存运行时数据区</p><p><img src="/images/Java/2018040509.png" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL免安装版配置</title>
      <link href="/2018/04/03/MySQL%E5%85%8D%E5%AE%89%E8%A3%85%E7%89%88%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/04/03/MySQL%E5%85%8D%E5%AE%89%E8%A3%85%E7%89%88%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><p>5.7 32位<a href="https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.19-win32.zip" target="_blank" rel="external">https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.19-win32.zip</a></p><p>5.7 64位<a href="https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.19-winx64.zip" target="_blank" rel="external">https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.19-winx64.zip</a></p><p>本人解压到的是D:\Program Files\mysql（这里解压后文件夹重命名为了mysql）</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>我的电脑-&gt;属性-&gt;高级-&gt;环境变量</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>新建系统环境变量MYSQL_HOME,值为D:\Program Files\mysql，在环境变量path中添加变量值：%MYSQL_HOME%\bin;，可以写bat脚本完成。</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>选择PATH,在其后面添加: 你的mysql 安装文件下面的bin文件夹<br>(如: D:\Program Files\mysql\bin )</p><a id="more"></a><h3 id="编辑安装配置文件"><a href="#编辑安装配置文件" class="headerlink" title="编辑安装配置文件"></a>编辑安装配置文件</h3><p>my.ini是mysql的安装配置文件，在安装包解压后的根目录下（如: D:\Program Files\mysql），如果解压后根目录没有则自己新建一个进行编辑，如下配置项供参考，可直接复制修改后使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"># For advice on how to change settings please see</div><div class="line"># http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html</div><div class="line"># *** DO NOT EDIT THIS FILE. It&apos;s a template which will be copied to the</div><div class="line"># *** default location during install, and will be replaced if you</div><div class="line"># *** upgrade to a newer version of MySQL.</div><div class="line">[client] </div><div class="line">#password = your_password</div><div class="line">port = 3306</div><div class="line">#socket  = D:\Program Files\mysql\data\mysql\mysql.sock</div><div class="line">default-character-set=utf8</div><div class="line">host=localhost</div><div class="line">user=root</div><div class="line">password=&apos;root&apos;</div><div class="line"></div><div class="line">[mysqld]</div><div class="line">port = 3306</div><div class="line">basedir=D:\Program Files</div><div class="line"># 设置mysql的安装目录</div><div class="line">datadir=D:\Program Files\data</div><div class="line"># 设置mysql数据库的数据的存放目录，必须是data，或者是//xxx/data</div><div class="line">default-storage-engine=INNODB</div><div class="line"># 创建新表时将使用的默认存储引擎</div><div class="line">#socket = D:\Program Files\mysql\data\mysql\mysql.sock</div><div class="line">sql-mode=STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</div><div class="line"># SQL模式为strict模式</div><div class="line">#default-character-set=utf8</div><div class="line"># 设置mysql服务器的字符集  </div><div class="line">character-set-server=utf8</div><div class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</div><div class="line">max_connections=100</div><div class="line"># mysql服务器支持的最大并发连接数（用户数）。但总会预留其中的一个连接给管理员使用超级权限登录，即使连接数目达到最大限制。如果设置得过小而用户比较多，会经常出现“Too many connections”错误。</div><div class="line">query_cache_size=0</div><div class="line"># 查询缓存大小，用于缓存SELECT查询结果。如果有许多返回相同查询结果的SELECT查询，并且很少改变表，可以设置query_cache_size大于0，可以极大改善查询效率。而如果表数据频繁变化，就不要使用这个，会适得其反</div><div class="line">#table_cache=256 </div><div class="line"># 这个参数在5.1.3之后的版本中叫做table_open_cache，用于设置table高速缓存的数量。由于每个客户端连接都会至少访问一个表，因此此参数的值与       max_connections有关。当某一连接访问一个表时，MySQL会检查当前已缓存表的数量。如果该表已经在缓存中打开，则会直接访问缓存中的表已加快查询速度；如果该表未被缓存，则会将当前的表添加进缓存并进行查询。在执行缓存操作之前，table_cache用于限制缓存表的最大数目：如果当前已经缓存的表未达到table_cache，则会将新表添加进来；若已经达到此值，MySQL将根据缓存表的最后查询时间、查询率等规则释放之前的缓存。</div><div class="line">tmp_table_size=34M</div><div class="line"># 内存中的每个临时表允许的最大大小。如果临时表大小超过该值，临时表将自动转为基于磁盘的表（Disk Based Table）。</div><div class="line">thread_cache_size=8</div><div class="line"># 缓存的最大线程数。当客户端连接断开时，如果客户端总连接数小于该值，则处理客户端任务的线程放回缓存。在高并发情况下，如果该值设置得太小，就会有很多线程频繁创建，线程创建的开销会变大，查询效率也会下降。一般来说如果在应用端有良好的多线程处理，这个参数对性能不会有太大的提高。</div><div class="line">#------------------------------MyISAM相关参数    begin------------------------------------------------</div><div class="line">max_allowed_packet=500M</div><div class="line">myisam_max_sort_file_size=100G</div><div class="line"># mysql重建索引时允许使用的临时文件最大大小</div><div class="line">myisam_sort_buffer_size=68M</div><div class="line">key_buffer_size=54M</div><div class="line"># Key Buffer大小，用于缓存MyISAM表的索引块。决定数据库索引处理的速度（尤其是索引读）</div><div class="line">read_buffer_size=64K</div><div class="line"># 用于对MyISAM表全表扫描时使用的缓冲区大小。针对每个线程进行分配（前提是进行了全表扫描）。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。</div><div class="line">read_rnd_buffer_size=256K</div><div class="line">sort_buffer_size=256K</div><div class="line"># connection级参数（为每个线程配置），500个线程将消耗500*256K的sort_buffer_size。</div><div class="line">#------------------------- MyISAM相关参数  end ---------------------------</div><div class="line">#------------------------- InnoDB相关参数  begin -------------------------</div><div class="line">innodb_additional_mem_pool_size=3M</div><div class="line"># InnoDB用于存储元数据信息的内存池大小，一般不需修改</div><div class="line">innodb_flush_log_at_trx_commit =1</div><div class="line"># 事务相关参数，如果值为1，则InnoDB在每次commit都会将事务日志写入磁盘（磁盘IO消耗较大），这样保证了完全的ACID特性。而如果设置为0，则表示事务日志写入内存log和内存log写入磁盘的频率都为1次/秒。如果设为2则表示事务日志在每次commit都写入内存log，但内存log写入磁盘的频率为1次/秒。</div><div class="line">innodb_log_buffer_size=2M</div><div class="line"># InnoDB日志数据缓冲大小，如果缓冲满了，就会将缓冲中的日志数据写入磁盘（flush）。由于一般至少都1秒钟会写一次磁盘，所以没必要设置过大，即使是长事务。</div><div class="line">innodb_buffer_pool_size=105M</div><div class="line"># InnoDB使用缓冲池来缓存索引和行数据。该值设置的越大，则磁盘IO越少。一般将该值设为物理内存的80%。</div><div class="line">innodb_log_file_size=53M</div><div class="line"># 每一个InnoDB事务日志的大小。一般设为innodb_buffer_pool_size的25%到100%</div><div class="line">innodb_thread_concurrency=9</div><div class="line"># InnoDB内核最大并发线程数</div><div class="line">#------------------------- InnoDB相关参数  end -------------------------</div><div class="line">skip-grant-tables</div><div class="line">#表示忽略密码</div></pre></td></tr></table></figure><h3 id="安装启动服务"><a href="#安装启动服务" class="headerlink" title="安装启动服务"></a>安装启动服务</h3><h4 id="安装注册"><a href="#安装注册" class="headerlink" title="安装注册"></a>安装注册</h4><p>“管理员身份”，点击”cmd”右键，选择“管理员方式运行”，执行控制台cmd 执行命令:  mysqld install MySQLService –defaults-file=”D:\Program Files\mysql\my.ini”（注意目录）</p><p>这里将mysql根据my.ini配置文件，安装注册为名称是MySQLService 的 服务，在本地服务列表中可以找到。</p><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 启动mysql</div><div class="line">net start MySQLService</div></pre></td></tr></table></figure><h3 id="登陆服务"><a href="#登陆服务" class="headerlink" title="登陆服务"></a>登陆服务</h3><h4 id="忽略密码"><a href="#忽略密码" class="headerlink" title="忽略密码"></a>忽略密码</h4><p>同样黑窗口，用命令 mysql –u root –p 进入mysql管理界面，待输入密码时直接回车即可</p><p>因为上述mysql.ini配置中最后第二行<code>skip-grant-tables</code>即忽略密码设置，可不输入密码直接回车登录数据库。更改密码后，注释掉或删掉后重启服务即可。</p><h4 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt;mysql-uroot -p</div><div class="line">mysql&gt;show databases;</div><div class="line">mysql&gt;use mysql;</div><div class="line">mysql&gt;UPDATE user SET password=PASSWORD(&quot;root&quot;) WHERE user=&apos;root&apos;;</div><div class="line">mysql&gt;FLUSH PRIVILEGES;（刷新权限）</div><div class="line">mysql&gt;QUIT（退出后重启服务）</div></pre></td></tr></table></figure><h4 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 停止服务</div><div class="line">net stop MySQLService</div><div class="line"># 启动服务</div><div class="line">net start MySQLService</div></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>在服务列表中停止服务，“管理员身份”，点击”cmd”右键，选择“管理员方式运行”，执行控制台cmd。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 删除服务</div><div class="line">sc delete MySQLService（服务名称）</div><div class="line"># 查询服务</div><div class="line">sc query MySQLService（服务名称）</div><div class="line"># 导入</div><div class="line">mysql --defaults-extra-file=&quot;D:\Program Files\mysql\my.ini&quot; 数据库名&lt;C:\文件名.sql</div><div class="line"># 导出</div><div class="line">mysqldump --defaults-extra-file=&quot;D:\Program Files\mysql\my.ini&quot; 数据库名&gt;C:\文件名.sql</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git ssh 配置及使用</title>
      <link href="/2018/04/02/Git-ssh-%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/04/02/Git-ssh-%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在电脑上已经安装好git的前提之上的，要进行以下配置，请先确保你的电脑已经安装好git。以下配置步骤是在git bash里面进行配置的，可以通过 右键 git bash here 打开</p><h3 id="https和ssh使用区别"><a href="#https和ssh使用区别" class="headerlink" title="https和ssh使用区别"></a>https和ssh使用区别</h3><p>在管理Git项目上，很多时候都是直接使用https url克隆到本地，当然也有有些人使用SSH url克隆到本地。</p><p>这两种方式的主要区别在于：使用https url克隆对初学者来说会比较方便，复制https url然后到git Bash里面直接用clone命令克隆到本地就好了，但是每次fetch和push代码都需要输入账号和密码，这也是https方式的麻烦之处。</p><p>而使用SSH url克隆却需要在克隆之前先配置和添加好SSH key，因此，如果你想要使用SSH url克隆的话，你必须是这个项目的拥有者。否则你是无法添加SSH key的，另外ssh默认是每次fetch和push代码都不需要输入账号和密码，如果你想要每次都输入账号密码才能进行fetch和push也可以另外进行设置。</p><a id="more"></a><h3 id="配置ssh主要步骤"><a href="#配置ssh主要步骤" class="headerlink" title="配置ssh主要步骤"></a>配置ssh主要步骤</h3><ul><li>设置Git的user name和email：(如果是第一次的话)</li><li>检查是否已经有SSH Key。</li><li>生成密钥</li><li>添加密钥到ssh-agent</li><li>登陆Github, 添加 ssh</li><li>测试</li></ul><h4 id="设置Git的user-name和email：-如果是第一次的话"><a href="#设置Git的user-name和email：-如果是第一次的话" class="headerlink" title="设置Git的user name和email：(如果是第一次的话)"></a>设置Git的user name和email：(如果是第一次的话)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 这里的“justxzm&quot; 可以替换成自己的用户名</div><div class="line">git config --global user.name &quot;justxzm&quot;</div><div class="line"># 这里的邮箱 justxzm@163.com  替换成自己的邮箱</div><div class="line">git config --global user.email  &quot;justxzm@163.com&quot;</div></pre></td></tr></table></figure><h4 id="检查是否已经有SSH-Key"><a href="#检查是否已经有SSH-Key" class="headerlink" title="检查是否已经有SSH Key"></a>检查是否已经有SSH Key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.ssh</div></pre></td></tr></table></figure><p>接着输入ls</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls</div></pre></td></tr></table></figure><p>列出该文件下的文件，看是否存在 id_isa 和 id_isa.pub 文件（也可以是别的文件名，只要 yourName 和 yourName.pub 成对存在），如果存在的话，证明已经存在 ssh key了，可以直接跳过生成密钥这一步骤，</p><p>下图是存在的情况下</p><p><img src="/images/Java/2018061205.jpg" alt=""></p><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 这里的邮箱 justxzm@163.com  替换成自己的邮箱</div><div class="line">ssh-keygen -t rsa -C &quot;justxzm@163.com&quot;</div></pre></td></tr></table></figure><p>连续3个回车。如果不需要密码的话。<br>最后得到了两个文件：id_rsa和id_rsa.pub。</p><p>默认的存储路径是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\.ssh</div></pre></td></tr></table></figure><h4 id="添加密钥到ssh-agent"><a href="#添加密钥到ssh-agent" class="headerlink" title="添加密钥到ssh-agent"></a>添加密钥到ssh-agent</h4><p>确保 ssh-agent 是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># start the ssh-agent in the background</div><div class="line">eval &quot;$(ssh-agent -s)&quot;</div></pre></td></tr></table></figure><p><img src="/images/Java/2018061206.jpg" alt=""></p><p>添加生成的 SSH key 到 ssh-agent：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-add ~/.ssh/id_rsa</div></pre></td></tr></table></figure><h4 id="登陆Github-添加-ssh"><a href="#登陆Github-添加-ssh" class="headerlink" title="登陆Github, 添加 ssh"></a>登陆Github, 添加 ssh</h4><p>把id_rsa.pub文件里的内容复制到这里</p><p><img src="/images/Java/2018061207.jpg" alt=""></p><p><img src="/images/Java/2018061208.jpg" alt=""></p><p><img src="/images/Java/2018061209.jpg" alt=""></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure><p>测试的时候“ssh -T git@github.com”后要输入yes，你将会看到：</p><blockquote><p>Hi just! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>如果看到Hi后面是你的用户名，就说明成功了。</p><p><img src="/images/Java/2018061210.jpg" alt=""></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>如果我之前的仓库是用https提交的，那么我现在想用ssh 的方式提交，怎么办呢 ，别急，下面就来教你怎样操作了。</p><p>这里同样以我本机目录下的G://test 仓库为例子，</p><p>找到仓库下 .git 文件夹下的config文件，打开，可以看到以下内容</p><pre><code>[core]    repositoryformatversion = 0    filemode = false    bare = false    logallrefupdates = true    symlinks = false    ignorecase = true[remote &quot;origin&quot;]    url = https://github.com/gdutxiaoxu/test.git    fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;]    remote = origin    merge = refs/heads/master</code></pre><p>将文件中的 url = <a href="https://github.com/gdutxiaoxu/test.git" target="_blank" rel="external">https://github.com/gdutxiaoxu/test.git</a> 更改为 url = git@github.com:gdutxiaoxu/test.git 即可。</p><p>修改后的文件如下：</p><pre><code>[core]    repositoryformatversion = 0    filemode = false    bare = false    logallrefupdates = true    symlinks = false    ignorecase = true[remote &quot;origin&quot;]    url = git@github.com:gdutxiaoxu/test.git    fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;]    remote = origin    merge = refs/heads/master</code></pre><p>进入本地仓库 ，增加 xujun.txt 文件，提交，你会看到不需要再提交密码了</p><p><img src="/images/Java/2018061211.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Volatile</title>
      <link href="/2017/04/04/Java-Volatile/"/>
      <url>/2017/04/04/Java-Volatile/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-Volatile关键字"><a href="#Java-Volatile关键字" class="headerlink" title="Java Volatile关键字"></a>Java Volatile关键字</h3><p>在java线程并发处理中，有一个关键字volatile的使用目前存在很大的混淆，以为使用这个关键字，在进行多线程并发处理的时候就可以万事大吉。</p><p>Java语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了 同步块 和 volatile 关键字机制。</p><p>锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 —— 如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。</p><a id="more"></a><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h4><p>同步块大家都比较熟悉，通过 synchronized 关键字来实现，所有加上synchronized 和 块语句，在多线程访问的时候，同一时刻只能有一个线程能够用。</p><p>synchronized 修饰的方法或者代码块。</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><strong>volatile</strong></h4><p>用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，用来进行原子性操作。volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。</p><p>Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start &lt;=end”）。</p><p>下面看一个例子，我们实现一个计数器，每次线程启动的时候，会调用计数器inc方法，对计数器进行加一。</p><p>执行环境——jdk版本：jdk1.6.0_31 ，内存 ：3G   cpu：x86 2.4G<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//这里延迟1毫秒，使得结果明显</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1</span>);</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//同时启动1000个线程，去进行i++计算，看看实际结果</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                    Counter.inc();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">//这里每次运行的值都有可能不同,可能为1000</span></div><div class="line">        System.out.println(<span class="string">"运行结果:Counter.count="</span> +Counter.count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果:</p><pre><code>Counter.count=995</code></pre><p>实际运算结果每次可能都不一样，本机的结果为：运行结果:Counter.count=995，可以看出，在多线程的环境下，Counter.count并没有期望结果是1000。</p><p>很多人以为，这个是多线程并发问题，只需要在变量count之前加上volatile就可以避免这个问题，那我们在修改代码看看，看看结果是不是符合我们的期望。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//这里延迟1毫秒，使得结果明显</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1</span>);</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//同时启动1000个线程，去进行i++计算，看看实际结果</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                    Counter.inc();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//这里每次运行的值都有可能不同,可能为1000</span></div><div class="line">        System.out.println(<span class="string">"运行结果:Counter.count="</span> +Counter.count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果:</p><pre><code>Counter.count=992</code></pre><p>运行结果还是没有我们期望的1000，下面我们分析一下原因</p><p>在 java 垃圾回收整理一文中，描述了jvm运行时刻内存的分配。其中有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。下面一幅图描述这写交互：</p><p><img src="/images/Java/2019031401.jpg" alt=""></p><p>read and load 从主存复制变量到当前工作内存</p><p>use and assign  执行代码，改变共享变量值 </p><p>store and write 用工作内存数据刷新主存相关内容</p><p>其中use and assign 可以多次出现</p><p>但是这一些操作并不是原子性，也就是 在read load之后，如果主内存count变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，所以计算出来的结果会和预期不一样</p><p>对于volatile修饰的变量，jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新的</p><p>在线程1堆count进行修改之后，会write到主内存中，主内存中的count变量就会变为6</p><p>线程2由于已经进行read,load操作，在进行运算之后，也会更新主内存count的变量值为6</p><p>导致两个线程及时用volatile关键字修改之后，还是会存在并发的情况。</p><h3 id="正确使用-volatile-变量的条件"><a href="#正确使用-volatile-变量的条件" class="headerlink" title="正确使用 volatile 变量的条件"></a><strong>正确使用 volatile 变量的条件</strong></h3><p>您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li><p>对变量的写操作不依赖于当前值。</p></li><li><p>该变量没有包含在具有其他变量的不变式中。</p></li></ul><p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p><p>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。（然而，如果将值调整为只从单个线程写入，那么可以忽略第一个条件。）</p><p>大多数编程情形都会与这两个条件的其中之一冲突，使得 volatile 变量不能像 synchronized 那样普遍适用于实现线程安全。</p><h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a><strong>性能考虑</strong></h3><p>使用 volatile 变量的主要原因是其简易性：在某些情形下，使用 volatile 变量要比使用相应的锁简单得多。使用 volatile 变量次要原因是其性能：某些情况下，volatile 变量同步机制的性能要优于锁。</p><p>很难做出准确、全面的评价，例如 “X 总是比 Y 快”，尤其是对 JVM 内在的操作而言。（例如，某些情况下 VM 也许能够完全删除锁机制，这使得我们难以抽象地比较 volatile 和 synchronized 的开销。）就是说，在目前大多数的处理器架构上，volatile 读操作开销非常低 —— 几乎和非 volatile 读操作一样。而 volatile 写操作的开销要比非 volatile 写操作多很多，因为要保证可见性需要实现内存界定（Memory Fence），即便如此，volatile 的总开销仍然要比锁获取低。</p><p>volatile 操作不会像锁一样造成阻塞，因此，在能够安全使用 volatile 的情况下，volatile 可以提供一些优于锁的可伸缩特性。如果读操作的次数要远远超过写操作，与锁相比，volatile 变量通常能够减少同步的性能开销。</p><h3 id="正确使用-volatile-的模式"><a href="#正确使用-volatile-的模式" class="headerlink" title="正确使用 volatile 的模式"></a><strong>正确使用 volatile 的模式</strong></h3><p>很多并发性专家事实上往往引导用户远离 volatile 变量，因为使用它们要比使用锁更加容易出错。然而，如果谨慎地遵循一些良好定义的模式，就能够在很多场合内安全地使用 volatile 变量。要始终牢记使用 volatile 的限制 —— 只有在状态真正独立于程序内其他内容时才能使用 volatile —— 这条规则能够避免将这些模式扩展到不安全的用例。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Transient</title>
      <link href="/2017/04/04/Java-Transient/"/>
      <url>/2017/04/04/Java-Transient/</url>
      
        <content type="html"><![CDATA[<h3 id="transient的作用及使用方法"><a href="#transient的作用及使用方法" class="headerlink" title="transient的作用及使用方法"></a>transient的作用及使用方法</h3><p>我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。</p><p>然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p><p>总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><a id="more"></a><p><strong>示例code如下:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@description</span> 使用transient关键字不序列化某个变量</div><div class="line"> *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientTest</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        </div><div class="line">        User user = <span class="keyword">new</span> User();</div><div class="line">        user.setUsername(<span class="string">"Alexia"</span>);</div><div class="line">        user.setPasswd(<span class="string">"123456"</span>);</div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"read before Serializable: "</span>);</div><div class="line">        System.out.println(<span class="string">"username: "</span> + user.getUsername());</div><div class="line">        System.err.println(<span class="string">"password: "</span> + user.getPasswd());</div><div class="line">        </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(</div><div class="line">                    <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/user.txt"</span>));</div><div class="line">            os.writeObject(user); <span class="comment">// 将User对象写进文件</span></div><div class="line">            os.flush();</div><div class="line">            os.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</div><div class="line">                    <span class="string">"C:/user.txt"</span>));</div><div class="line">            user = (User) is.readObject(); <span class="comment">// 从流中读取User的数据</span></div><div class="line">            is.close();</div><div class="line">            </div><div class="line">            System.out.println(<span class="string">"\nread after Serializable: "</span>);</div><div class="line">            System.out.println(<span class="string">"username: "</span> + user.getUsername());</div><div class="line">            System.err.println(<span class="string">"password: "</span> + user.getPasswd());</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8294180014912103005L</span>;  </div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String username;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passwd;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> username;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.username = username;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPasswd</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> passwd;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPasswd</span><span class="params">(String passwd)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.passwd = passwd;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出为：</p><pre><code>read before Serializable: username: Alexiapassword: 123456read after Serializable: username: Alexiapassword: null</code></pre><p>密码字段为null，说明反序列化时根本没有从文件中获取到信息。</p><h3 id="transient使用小结"><a href="#transient使用小结" class="headerlink" title="transient使用小结"></a>transient使用小结</h3><p>1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</p><p>2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p><p>3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</p><p>第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的，不相信？好吧，下面我来证明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@description</span> 使用transient关键字不序列化某个变量</div><div class="line"> *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientTest</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        </div><div class="line">        User user = <span class="keyword">new</span> User();</div><div class="line">        user.setUsername(<span class="string">"Alexia"</span>);</div><div class="line">        user.setPasswd(<span class="string">"123456"</span>);</div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"read before Serializable: "</span>);</div><div class="line">        System.out.println(<span class="string">"username: "</span> + user.getUsername());</div><div class="line">        System.err.println(<span class="string">"password: "</span> + user.getPasswd());</div><div class="line">        </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(</div><div class="line">                    <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/user.txt"</span>));</div><div class="line">            os.writeObject(user); <span class="comment">// 将User对象写进文件</span></div><div class="line">            os.flush();</div><div class="line">            os.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 在反序列化之前改变username的值</span></div><div class="line">            User.username = <span class="string">"jmwang"</span>;</div><div class="line">            </div><div class="line">            ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</div><div class="line">                    <span class="string">"C:/user.txt"</span>));</div><div class="line">            user = (User) is.readObject(); <span class="comment">// 从流中读取User的数据</span></div><div class="line">            is.close();</div><div class="line">            </div><div class="line">            System.out.println(<span class="string">"\nread after Serializable: "</span>);</div><div class="line">            System.out.println(<span class="string">"username: "</span> + user.getUsername());</div><div class="line">            System.err.println(<span class="string">"password: "</span> + user.getPasswd());</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8294180014912103005L</span>;  </div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String username;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passwd;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> username;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.username = username;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPasswd</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> passwd;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPasswd</span><span class="params">(String passwd)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.passwd = passwd;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果为：</p><pre><code>read before Serializable: username: Alexiapassword: 123456read after Serializable: username: jmwangpassword: null</code></pre><p>这说明反序列化后类中static型变量username的值为当前JVM中对应static变量的值，为修改后jmwang，而不是序列化时的值Alexia。</p><h3 id="transient使用细节"><a href="#transient使用细节" class="headerlink" title="transient使用细节"></a>transient使用细节</h3><p>被transient关键字修饰的变量真的不能被序列化吗？</p><p>思考下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.Externalizable;</div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInput;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutput;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@descripiton</span> Externalizable接口的使用</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalizableTest</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String content = <span class="string">"是的，我将会被序列化，不管我是否被transient关键字修饰"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        out.writeObject(content);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException,</span></div><div class="line">            ClassNotFoundException &#123;</div><div class="line">        content = (String) in.readObject();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        </div><div class="line">        ExternalizableTest et = <span class="keyword">new</span> ExternalizableTest();</div><div class="line">        ObjectOutput out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(</div><div class="line">                <span class="keyword">new</span> File(<span class="string">"test"</span>)));</div><div class="line">        out.writeObject(et);</div><div class="line"></div><div class="line">        ObjectInput in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(</div><div class="line">                <span class="string">"test"</span>)));</div><div class="line">        et = (ExternalizableTest) in.readObject();</div><div class="line">        System.out.println(et.content);</div><div class="line"></div><div class="line">        out.close();</div><div class="line">        in.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>content变量会被序列化吗？好吧，我把答案都输出来了，是的，运行结果就是：<br>​<br>    是的，我将会被序列化，不管我是否被transient关键字修饰</p><p>这是为什么呢，不是说类的变量被transient关键字修饰以后将不能序列化了吗？</p><p>我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变量content初始化的内容，而不是null。</p><h3 id="关于java-io-Serializable序列化"><a href="#关于java-io-Serializable序列化" class="headerlink" title="关于java.io.Serializable序列化"></a>关于java.io.Serializable序列化</h3><p>Java API中java.io.Serializable接口源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>类通过实现java.io.Serializable接口可以启用其序列化功能。未实现次接口的类无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。</p><p>Java的”对象序列化”能让你将一个实现了Serializable接口的对象转换成byte流，这样日后要用这个对象时候，你就能把这些byte数据恢复出来，并据此重新构建那个对象了。</p><p>要想序列化对象，你必须先创建一个OutputStream，然后把它嵌进ObjectOutputStream。这时，你就能用writeObject()方法把对象写入OutputStream了。</p><p>writeObject()方法负责写入特定类的对象的状态，以便相应的 readObject()方法可以还原它。通过调用 out.defaultWriteObject 可以调用保存 Object 的字段的默认机制。该方法本身不需要涉及属于其超类或子类的状态。状态是通过使用 writeObject 方法或使用 DataOutput 支持的用于基本数据类型的方法将各个字段写入 ObjectOutputStream 来保存的。</p><p>读的时候，你得把InputStream嵌到ObjectInputStream里面，然后再调用readObject()方法。不过这样读出来的，只是一个Object的reference，因此在用之前，还得先下传。readObject() 方法负责从流中读取并还原类字段。它可以调用 in.defaultReadObject 来调用默认机制，以还原对象的非静态和非瞬态字段。　 defaultReadObject()方法使用流中的信息来分配流中通过当前对象中相应命名字段保存的对象的字段。这用于处理类发展后需要添加新字段的情形。该方法本身不需要涉及属于其超类或子类的状态。状态是通过使用 writeObject 方法或使用 DataOutput 支持的用于基本数据类型的方法将各个字段写入 ObjectOutputStream 来保存的。</p><p><strong>在序列化时，有几点要注意的：</strong></p><ul><li>当一个对象被序列化时，只保存对象的非静态成员变量（包括声明为private的变量），不能保存任何的成员方法和静态的成员变量。</li><li>如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被序列化。</li><li>如果一个可序列化的对象包含对某个不可序列化的对象的引用，那么整个序列化操作将会失败，并且会抛出一个NotSerializableException。我们可以将这个引用标记为transient，那么对象仍然可以序列化。</li></ul><h4 id="序列化是干什么的？"><a href="#序列化是干什么的？" class="headerlink" title="序列化是干什么的？"></a><strong>序列化是干什么的？</strong></h4><p>简单说就是为了保存在内存中的各种对象的状态，并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存Object States，但是Java给你提供一种应该比你自己好的保存对象状态的机制,那就是序列化。</p><h4 id="什么情况下需要序列化"><a href="#什么情况下需要序列化" class="headerlink" title="什么情况下需要序列化"></a><strong>什么情况下需要序列化</strong></h4><p>a）当你想把的内存中的对象保存到一个文件中或者数据库中时候；</p><p>b）当你想用套接字在网络上传送对象的时候；</p><p>c）当你想通过RMI传输对象的时候；</p><h4 id="当对一个对象实现序列化时，究竟发生了什么？"><a href="#当对一个对象实现序列化时，究竟发生了什么？" class="headerlink" title="当对一个对象实现序列化时，究竟发生了什么？"></a><strong>当对一个对象实现序列化时，究竟发生了什么？</strong></h4><p>在没有序列化前，每个保存在堆（Heap）中的对象都有相应的状态（state），即实例变量（instance ariable）比如：</p><pre><code>Foo myFoo = new Foo();myFoo .setWidth(37);myFoo.setHeight(70);</code></pre><p>当通过下面的代码序列化之后，MyFoo对象中的width和Height实例变量的值（37，70）都被保存到foo.ser文件中，这样以后又可以把它从文件中读出来，重新在堆中创建原来的对象。当然保存时候不仅仅是保存对象的实例变量的值，JVM还要保存一些小量信息，比如类的类型等以便恢复原来的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FileOutputStream fs = <span class="keyword">new</span> FileOutputStream(<span class="string">"foo.ser"</span>);</div><div class="line">ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(fs);</div><div class="line">os.writeObject(myFoo);</div></pre></td></tr></table></figure><h4 id="实现序列化（保存到一个文件）的步骤"><a href="#实现序列化（保存到一个文件）的步骤" class="headerlink" title="实现序列化（保存到一个文件）的步骤"></a><strong>实现序列化（保存到一个文件）的步骤</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">FileOutputStream fs = <span class="keyword">new</span> FileOutputStream(<span class="string">"foo.ser"</span>);</div><div class="line">ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(fs);</div><div class="line">os.writeObject(myObject1);</div><div class="line">os.writeObject(myObject2);</div><div class="line">os.writeObject(myObject3);</div><div class="line">os.close();</div></pre></td></tr></table></figure><h4 id="相关注意事项"><a href="#相关注意事项" class="headerlink" title="相关注意事项"></a><strong>相关注意事项</strong></h4><p>a）当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</p><p>b）当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</p><p>c）并非所有的对象都可以序列化，至于为什么不可以，有很多原因了,比如：</p><ul><li><p>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输 等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。</p></li><li><p>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象克隆与序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高mysql千万级大数据SQL查询优化30条经验</title>
      <link href="/2017/04/02/%E6%8F%90%E9%AB%98mysql%E5%8D%83%E4%B8%87%E7%BA%A7%E5%A4%A7%E6%95%B0%E6%8D%AESQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%9630%E6%9D%A1%E7%BB%8F%E9%AA%8C/"/>
      <url>/2017/04/02/%E6%8F%90%E9%AB%98mysql%E5%8D%83%E4%B8%87%E7%BA%A7%E5%A4%A7%E6%95%B0%E6%8D%AESQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%9630%E6%9D%A1%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>(转)</p><ol><li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p></li><li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0</p></li><li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p></li><li><p>应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num=10 or num=20可以这样查询：select id from t where num=10 union all select id from t where num=20</p></li><li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3</p></li><li><p>下面的查询也将导致全表扫描：select id from t where name like ‘李%’若要提高效率，可以考虑全文检索。</p><a id="more"></a></li><li><p>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：select id from t where num=@num可以改为强制查询使用索引：select id from t with(index(索引名)) where num=@num</p></li><li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where num/2=100应改为:select id from t where num=100*2</p></li><li><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where substring(name,1,3)=’abc’ ，name以abc开头的id</p><p>应改为:</p><p>select id from t where name like ‘abc%’</p></li><li><p>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p></li><li><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p></li><li><p>不要写一些没有意义的查询，如需要生成一个空表结构：select col1,col2 into #t from t where 1=0</p><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p><p>create table #t(…)</p></li><li><p>很多时候用 exists 代替 in 是一个好的选择：select num from a where num in(select num from b)</p><p>用下面的语句替换：</p><p>select num from a where exists(select 1 from b where num=a.num)</p></li><li><p>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p></li><li><p>索引并不是越多越好，索引固然可 以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p></li><li><p>应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p></li><li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p></li><li><p>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p></li><li><p>任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段。</p></li><li><p>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p></li><li><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。</p></li><li><p>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p></li><li><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p></li><li><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p></li><li><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p></li><li><p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p></li><li><p>与临时表一样，游标并不是不可使 用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p></li><li><p>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC 消息。</p></li><li><p>尽量避免大事务操作，提高系统并发能力。</p></li><li><p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java二叉树实现</title>
      <link href="/2017/03/31/Java%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/03/31/Java%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> value;</div><div class="line"><span class="keyword">public</span> Node left;</div><div class="line"><span class="keyword">public</span> Node right;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</div><div class="line"><span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</div><div class="line">left = <span class="keyword">new</span> Node();</div><div class="line">left.value = value;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">left.store(value);</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="keyword">this</span>.value) &#123;</div><div class="line"><span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</div><div class="line">right = <span class="keyword">new</span> Node();</div><div class="line">right.value = value;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">right.store(value);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"happen "</span> + <span class="keyword">this</span>.value);</div><div class="line"><span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="keyword">this</span>.value) &#123;</div><div class="line"><span class="keyword">if</span> (right == <span class="keyword">null</span>)</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="keyword">return</span> right.find(value);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">if</span> (left == <span class="keyword">null</span>)</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="keyword">return</span> left.find(value);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 前序遍历</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preList</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.print(<span class="keyword">this</span>.value + <span class="string">","</span>);</div><div class="line"><span class="keyword">if</span> (left != <span class="keyword">null</span>)</div><div class="line">left.preList();</div><div class="line"><span class="keyword">if</span> (right != <span class="keyword">null</span>)</div><div class="line">right.preList();</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 中序遍历</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">middleList</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (left != <span class="keyword">null</span>)</div><div class="line">left.preList();</div><div class="line">System.out.print(<span class="keyword">this</span>.value + <span class="string">","</span>);</div><div class="line"><span class="keyword">if</span> (right != <span class="keyword">null</span>)</div><div class="line">right.preList();</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 后序遍历</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterList</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (left != <span class="keyword">null</span>)</div><div class="line">left.preList();</div><div class="line"><span class="keyword">if</span> (right != <span class="keyword">null</span>)</div><div class="line">right.preList();</div><div class="line">System.out.print(<span class="keyword">this</span>.value + <span class="string">","</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</div><div class="line">data[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>) + <span class="number">1</span>;</div><div class="line">System.out.print(data[i] + <span class="string">","</span>);</div><div class="line">&#125;</div><div class="line">System.out.println();</div><div class="line">Node root = <span class="keyword">new</span> Node();</div><div class="line">root.value = data[<span class="number">0</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) &#123;</div><div class="line">root.store(data[i]);</div><div class="line">&#125;</div><div class="line">root.find(data[<span class="number">19</span>]);</div><div class="line">root.preList();</div><div class="line">System.out.println();</div><div class="line">root.middleList();</div><div class="line">System.out.println();</div><div class="line">root.afterList();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存泄露</title>
      <link href="/2017/03/31/Java%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
      <url>/2017/03/31/Java%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="Java是如何管理内存"><a href="#Java是如何管理内存" class="headerlink" title="Java是如何管理内存"></a><strong>Java是如何管理内存</strong></h3><p>为了判断Java中是否有内存泄露，我们首先必须了解Java是如何管理内存的。Java的内存管理就是对象的分配和释放问题。在Java中，程序员需要通过关键字new为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。另外，对象的释放是由GC决定和执行的。在Java中，内存的分配是由程序完成的，而内存的释放是有GC完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。这也是Java程序运行速度较慢的原因之一。因为，GC为了能够正确释放对象，GC必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC都需要进行监控。</p><p>监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。</p><a id="more"></a><p>为了更好理解GC的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从main进程开始执行，那么该图就是以main进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被GC回收。</p><p>JVM的内存分配情况。以下右图，就是左边程序运行到第6行的示意图。</p><p><img src="/images/Java/2019031402.png" alt=""></p><p>Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。</p><h3 id="什么是Java中的内存泄露"><a href="#什么是Java中的内存泄露" class="headerlink" title="什么是Java中的内存泄露"></a><strong>什么是Java中的内存泄露</strong></h3><p>下面，我们就可以描述什么是内存泄漏。在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p><p>在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。</p><p>通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。</p><p><img src="/images/Java/2019031403.png" alt=""></p><p>因此，通过以上分析，我们知道在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。</p><p>对于程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。</p><h3 id="内存泄露什么情况发生"><a href="#内存泄露什么情况发生" class="headerlink" title="内存泄露什么情况发生"></a>内存泄露什么情况发生</h3><p>虽然Java自带垃圾回收机制（GC），程序员不需要手动进行内存管理，但是仍然会出现内存泄漏的情况。尽管如此，Java的自动内存管理，比起C/C++，内存泄漏的情况大大减少了。下面总结下什么情况下会发生Java内存泄漏。</p><p><strong>静态集合类</strong></p><p>在使用Set、Vector、HashMap等集合类的时候需要特别注意，有可能会发生内存泄漏。当这些集合被定义成静态的时候，由于它们的生命周期跟应用程序一样长，这时候，就有可能会发生内存泄漏，看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;</div><div class="line">    </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)&#123;</div><div class="line">            Object object = <span class="keyword">new</span> Object();</div><div class="line">            v.add(object);</div><div class="line">            object = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在上面的代码中，循环申请了Object对象，并添加到Vector中，然后将对象设置为null，可是这些对象因为被Vector引用着，因此并不能被GC回收，因此造成了内存泄漏。因此，要释放这些对象，还需要被它们从Vector删除，最简单的方法就是将Vector设置为null。</p><p><strong>集合里的对象属性值被改变</strong></p><p>看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Set&lt;Student&gt; set = <span class="keyword">new</span> HashSet&lt;Student&gt;();</div><div class="line">    Student s1 = <span class="keyword">new</span> Student(<span class="string">"Jack"</span>);</div><div class="line">    Student s2 = <span class="keyword">new</span> Student(<span class="string">"Mary"</span>);</div><div class="line">    Student s3 = <span class="keyword">new</span> Student(<span class="string">"Eason"</span>);</div><div class="line"></div><div class="line">    set.add(s1);</div><div class="line">    set.add(s2);</div><div class="line">    set.add(s3);</div><div class="line"></div><div class="line">    System.out.println(set.size());<span class="comment">//3</span></div><div class="line">    s2.setName(<span class="string">"Jackson"</span>); <span class="comment">//修改属性，此时s2元素对应的hashcode值发生改变</span></div><div class="line">    set.remove(s2);        <span class="comment">// remove不掉，造成内存泄漏</span></div><div class="line">    set.add(s2);           <span class="comment">// 添加成功</span></div><div class="line"></div><div class="line">    System.out.println(set.size());<span class="comment">//4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这个例子中，由于对象s2的属性值被改变了，因此不能从set中删除，所以set中会一直保持着s2的引用，不能被回收，造成了内存泄漏。</p><p><strong>监听器</strong></p><p>在Java中，我们经常会使用到监听器，如对某个控件添加单击监听器addOnClickListener()，但往往释放对象的时候会忘记删除监听器，这就有可能造成内存泄漏。好的方法就是，在释放对象的时候，应该记住释放所有监听器，这就能避免了因为监听器而导致的内存泄漏。</p><p><strong>各种连接</strong></p><p>Java中的连接包括数据库连接、网络连接和io连接，如果没有显式调用其close()方法，是不会自动关闭的，这些连接就不能被GC回收而导致内存泄漏。一般情况下，在try代码块里创建连接，在finally里释放连接，就能够避免此类内存泄漏。</p><p><strong>外部模块的引用</strong></p><p>调用外部模块的时候，也应该注意防止内存泄漏。如模块A调用了外部模块B的一个方法，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object o)</span></span></div></pre></td></tr></table></figure><p>这个方法有可能就使得A模块持有传入对象的引用，这时候需要查看B模块是否提供了去除引用的方法，如unregister()。这种情况容易忽略，而且发生了内存泄漏的话，比较难察觉，应该在编写代码过程中就应该注意此类问题。</p><p><strong>单例模式</strong></p><p>使用单例模式的时候也有可能导致内存泄漏。因为单例对象初始化后将在JVM的整个生命周期内存在，如果它持有一个外部对象（生命周期比较短）的引用，那么这个外部对象就不能被回收，而导致内存泄漏。如果这个外部对象还持有其它对象的引用，那么内存泄漏会更严重，因此需要特别注意此类情况。这种情况就需要考虑下单例模式的设计会不会有问题，应该怎样保证不会产生内存泄漏问题。</p>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Lambda</title>
      <link href="/2017/03/31/Java-Lambda/"/>
      <url>/2017/03/31/Java-Lambda/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是λ表达式"><a href="#1-什么是λ表达式" class="headerlink" title="1. 什么是λ表达式"></a><strong>1. 什么是λ表达式</strong></h3><p>λ表达式本质上是一个匿名方法。让我们来看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public int add(int x, int y) &#123;</div><div class="line">return x + y;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>转成λ表达式后是这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y;</div></pre></td></tr></table></figure><p>参数类型也可以省略，Java编译器会根据上下文推断出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(x, y) -&gt; x + y; <span class="comment">//返回两数之和</span></div></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(x, y) -&gt; &#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">//显式指明返回值</span></div></pre></td></tr></table></figure><p>可见λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。</p><p>下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() -&gt; &#123; System.out.println(<span class="string">"Hello Lambda!"</span>); &#125;</div></pre></td></tr></table></figure><p>如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c -&gt; &#123; <span class="keyword">return</span> c.size(); &#125;</div></pre></td></tr></table></figure><a id="more"></a><h3 id="2-λ表达式的类型（它是Object吗？）"><a href="#2-λ表达式的类型（它是Object吗？）" class="headerlink" title="2. λ表达式的类型（它是Object吗？）"></a><strong>2. λ表达式的类型（它是Object吗？）</strong></h3><p>λ表达式可以被当做是一个Object（注意措辞）。λ表达式的类型，叫做“目标类型（target type）”。λ表达式的目标类型是“函数接口（functional interface）”，这是Java8新引入的概念。它的定义是：一个接口，如果只有一个显式声明的抽象方法，那么它就是一个函数接口。一般用@FunctionalInterface标注出来（也可以不标）。举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;<span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActionListener</span> </span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span>;&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>; <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;&#125;</div></pre></td></tr></table></figure><p>注意最后这个Comparator接口。它里面声明了两个方法，貌似不符合函数接口的定义，但它的确是函数接口。这是因为equals方法是Object的，所有的接口都会声明Object的public方法——虽然大多是隐式的。所以，Comparator显式的声明了equals不影响它依然是个函数接口。</p><p>你可以用一个λ表达式为一个函数接口赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Runnable r1 = () -&gt; &#123;System.out.println(<span class="string">"Hello Lambda!"</span>);&#125;;</div></pre></td></tr></table></figure><p>然后再赋值给一个Object：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object obj = r1;</div></pre></td></tr></table></figure><p>但却不能这样干：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object obj = () -&gt; &#123;System.out.println(<span class="string">"Hello Lambda!"</span>);&#125;; </div><div class="line"><span class="comment">// ERROR! Object is not a functional interface!</span></div></pre></td></tr></table></figure><p>必须显式的转型成一个函数接口才可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object o = (Runnable) () -&gt; &#123; System.out.println(<span class="string">"hi"</span>); &#125;; <span class="comment">// correct</span></div></pre></td></tr></table></figure><p>一个λ表达式只有在转型成一个函数接口后才能被当做Object使用。所以下面这句也不能编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println( () -&gt; &#123;&#125; ); <span class="comment">//错误! 目标类型不明</span></div></pre></td></tr></table></figure><p>必须先转型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println( (Runnable)() -&gt; &#123;&#125; ); <span class="comment">// 正确</span></div></pre></td></tr></table></figure><p>假设你自己写了一个函数接口，长的跟Runnable一模一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRunnable</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Runnable r1 =    () -&gt; &#123;System.out.println(<span class="string">"Hello Lambda!"</span>);&#125;;</div><div class="line">MyRunnable2 r2 = () -&gt; &#123;System.out.println(<span class="string">"Hello Lambda!"</span>);&#125;;</div></pre></td></tr></table></figure><p>JDK预定义了很多函数接口以避免用户重复定义。最典型的是Function：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;  </div><div class="line"><span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个接口代表一个函数，接受一个T类型的参数，并返回一个R类型的返回值。   </p><p>另一个预定义函数接口叫做Consumer，跟Function的唯一不同是它没有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还有一个Predicate，用来判断某项条件是否满足。经常用来进行筛滤操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>综上所述，一个λ表达式其实就是定义了一个匿名方法，只不过这个方法必须符合至少一个函数接口。</p><h3 id="3-λ表达式的使用"><a href="#3-λ表达式的使用" class="headerlink" title="3. λ表达式的使用"></a><strong>3. λ表达式的使用</strong></h3><h4 id="λ表达式用在何处"><a href="#λ表达式用在何处" class="headerlink" title="λ表达式用在何处"></a><strong><em>λ表达式用在何处</em></strong></h4><p>λ表达式主要用于替换以前广泛使用的内部匿名类，各种回调，比如事件响应器、传入Thread类的Runnable等。看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Thread oldSchool = <span class="keyword">new</span> Thread( <span class="keyword">new</span> Runnable () &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"This is from an anonymous class."</span>);</div><div class="line">&#125;</div><div class="line">&#125; );</div><div class="line">Thread gaoDuanDaQiShangDangCi = <span class="keyword">new</span> Thread( () -&gt; &#123;</div><div class="line">    System.out.println(<span class="string">"This is from an anonymous method (lambda exp)."</span>);</div><div class="line">&#125; );</div></pre></td></tr></table></figure><p>注意第二个线程里的λ表达式，你并不需要显式地把它转成一个Runnable，因为Java能根据上下文自动推断出来：一个Thread的构造函数接受一个Runnable参数，而传入的λ表达式正好符合其run()函数，所以Java编译器推断它为Runnable。</p><p>从形式上看，λ表达式只是为你节省了几行代码。但将λ表达式引入Java的动机并不仅仅为此。Java8有一个短期目标和一个长期目标。短期目标是：配合“集合类批处理操作”的内部迭代和并行处理（下面将要讲到）；长期目标是将Java向函数式编程语言这个方向引导（并不是要完全变成一门函数式编程语言，只是让它有更多的函数式编程语言的特性），也正是由于这个原因，Oracle并没有简单地使用内部类去实现λ表达式，而是使用了一种更动态、更灵活、易于将来扩展和改变的策略（invokedynamic）。</p><h4 id="λ表达式与集合类批处理操作（或者叫块操作）"><a href="#λ表达式与集合类批处理操作（或者叫块操作）" class="headerlink" title="λ表达式与集合类批处理操作（或者叫块操作）"></a><strong><em>λ表达式与集合类批处理操作（或者叫块操作）</em></strong></h4><p>上文提到了集合类的批处理操作。这是Java8的另一个重要特性，它与λ表达式的配合使用乃是Java8的最主要特性。集合类的批处理操作API的目的是实现集合类的“内部迭代”，并期望充分利用现代多核CPU进行并行计算。<br>Java8之前集合类的迭代（Iteration）都是外部的，即客户代码。而内部迭代意味着改由Java类库来进行迭代，而不是客户代码。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(Object o: list) &#123; <span class="comment">// 外部迭代</span></div><div class="line">    System.out.println(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以写成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//forEach函数实现内部迭代</span></div><div class="line">list.forEach(o -&gt; &#123;System.out.println(o);&#125;);</div></pre></td></tr></table></figure><p>集合类（包括List）现在都有一个forEach方法，对元素进行迭代（遍历），所以我们不需要再写for循环了。forEach方法接受一个函数接口Consumer做参数，所以可以使用λ表达式。</p><p>这种内部迭代方法广泛存在于各种语言，如C++的STL算法库、Python、ruby、Scala等。</p><p>Java8为集合类引入了另一个重要概念：流（stream）。一个流通常以一个集合类实例为其数据源，然后在其上定义各种操作。流的API设计使用了管道（pipelines）模式。对流的一次操作会返回另一个流。如同IO的API或者StringBuffer的append方法那样，从而多个不同的操作可以在一个语句里串起来。看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Shape&gt; shapes = ...</div><div class="line">shapes.stream()</div><div class="line">  .filter(s -&gt; s.getColor() == BLUE)</div><div class="line">  .forEach(s -&gt; s.setColor(RED));</div></pre></td></tr></table></figure><p>首先调用stream方法，以集合类对象shapes里面的元素为数据源，生成一个流。然后在这个流上调用filter方法，挑出蓝色的，返回另一个流。最后调用forEach方法将这些蓝色的物体喷成红色。（forEach方法不再返回流，而是一个终端方法，类似于StringBuffer在调用若干append之后的那个toString）</p><p>filter方法的参数是Predicate类型，forEach方法的参数是Consumer类型，它们都是函数接口，所以可以使用λ表达式。</p><p>还有一个方法叫parallelStream()，顾名思义它和stream()一样，只不过指明要并行处理，以期充分利用现代CPU的多核特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shapes.parallelStream(); <span class="comment">// 或shapes.stream().parallel()</span></div></pre></td></tr></table></figure><p>来看更多的例子。下面是典型的大数据处理方法，Filter-Map-Reduce：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给出一个String类型的数组，找出其中所有不重复的素数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">distinctPrimary</span><span class="params">(String... numbers)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; l = Arrays.asList(numbers);</div><div class="line">    List&lt;Integer&gt; r = l.stream()</div><div class="line">            .map(e -&gt; <span class="keyword">new</span> Integer(e))</div><div class="line">            .filter(e -&gt; Primes.isPrime(e))</div><div class="line">            .distinct()</div><div class="line">            .collect(Collectors.toList());</div><div class="line">    System.out.println(<span class="string">"distinctPrimary result is: "</span> + r);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第一步：传入一系列String（假设都是合法的数字），转成一个List，然后调用stream()方法生成流。</p><p>第二步：调用流的map方法把每个元素由String转成Integer，得到一个新的流。map方法接受一个Function类型的参数，上面介绍了，Function是个函数接口，所以这里用λ表达式。</p><p>第三步：调用流的filter方法，过滤那些不是素数的数字，并得到一个新流。filter方法接受一个Predicate类型的参数，上面介绍了，Predicate是个函数接口，所以这里用λ表达式。</p><p>第四步：调用流的distinct方法，去掉重复，并得到一个新流。这本质上是另一个filter操作。</p><p>第五步：用collect方法将最终结果收集到一个List里面去。collect方法接受一个Collector类型的参数，这个参数指明如何收集最终结果。在这个例子中，结果简单地收集到一个List中。我们也可以用Collectors.toMap(e-&gt;e, e-&gt;e)把结果收集到一个Map中，它的意思是：把结果收到一个Map，用这些素数自身既作为键又作为值。toMap方法接受两个Function类型的参数，分别用以生成键和值，Function是个函数接口，所以这里都用λ表达式。</p><p>你可能会觉得在这个例子里，List l被迭代了好多次，map，filter，distinct都分别是一次循环，效率会不好。实际并非如此。这些返回另一个Stream的方法都是“懒（lazy）”的，而最后返回最终结果的collect方法则是“急（eager）”的。在遇到eager方法之前，lazy的方法不会执行。</p><p>当遇到eager方法时，前面的lazy方法才会被依次执行。而且是管道贯通式执行。这意味着每一个元素依次通过这些管道。例如有个元素“3”，首先它被map成整数型3；然后通过filter，发现是素数，被保留下来；又通过distinct，如果已经有一个3了，那么就直接丢弃，如果还没有则保留。这样，3个操作其实只经过了一次循环。</p><blockquote><p>除collect外其它的eager操作还有forEach，toArray，reduce等。</p></blockquote><p>下面来看一下也许是最常用的收集器方法，groupingBy：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给出一个String类型的数组，找出其中各个素数，并统计其出现次数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">primaryOccurrence</span><span class="params">(String... numbers)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; l = Arrays.asList(numbers);</div><div class="line">    Map&lt;Integer, Integer&gt; r = l.stream()</div><div class="line">        .map(e -&gt; <span class="keyword">new</span> Integer(e))</div><div class="line">        .filter(e -&gt; Primes.isPrime(e))</div><div class="line">        .collect( Collectors.groupingBy(p-&gt;p, Collectors.summingInt(p-&gt;<span class="number">1</span>)) );</div><div class="line">    System.out.println(<span class="string">"primaryOccurrence result is: "</span> + r);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意这一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collectors.groupingBy(p-&gt;p, Collectors.summingInt(p-&gt;<span class="number">1</span>))</div></pre></td></tr></table></figure><p>它的意思是：把结果收集到一个Map中，用统计到的各个素数自身作为键，其出现次数作为值。</p><p>下面是一个reduce的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给出一个String类型的数组，求其中所有不重复素数的和</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">distinctPrimarySum</span><span class="params">(String... numbers)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; l = Arrays.asList(numbers);</div><div class="line">    <span class="keyword">int</span> sum = l.stream()</div><div class="line">        .map(e -&gt; <span class="keyword">new</span> Integer(e))</div><div class="line">        .filter(e -&gt; Primes.isPrime(e))</div><div class="line">        .distinct()</div><div class="line">        .reduce(<span class="number">0</span>, (x,y) -&gt; x+y); <span class="comment">// equivalent to .sum()</span></div><div class="line">    System.out.println(<span class="string">"distinctPrimarySum result is: "</span> + sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>reduce方法用来产生单一的一个最终结果。</p><p>流有很多预定义的reduce操作，如sum()，max()，min()等。</p><p>再举个现实世界里的例子比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 统计年龄在25-35岁的男女人数、比例</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boysAndGirls</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</div><div class="line">    Map&lt;Integer, Integer&gt; result = persons.parallelStream().filter(p -&gt;</div><div class="line"> p.getAge()&gt;=<span class="number">25</span> &amp;&amp; p.getAge()&lt;=<span class="number">35</span>).</div><div class="line">        collect(</div><div class="line">            Collectors.groupingBy(p-&gt;p.getSex(), Collectors.summingInt(p-&gt;<span class="number">1</span>))</div><div class="line">    );</div><div class="line">    System.out.print(<span class="string">"boysAndGirls result is "</span> + result);</div><div class="line">    System.out.println(<span class="string">", ratio (male : female) is "</span> + (<span class="keyword">float</span>)result.get</div><div class="line">(Person.MALE)/result.get(Person.FEMALE));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="λ表达式的更多用法"><a href="#λ表达式的更多用法" class="headerlink" title="λ表达式的更多用法"></a><strong><strong>λ表达式的更多用法</strong></strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 嵌套的λ表达式</span></div><div class="line">Callable&lt;Runnable&gt; c1 = () -&gt; () -&gt; &#123; System.out.println(<span class="string">"Nested lambda"</span>); &#125;;</div><div class="line">c1.call().run();</div><div class="line"></div><div class="line"><span class="comment">// 用在条件表达式中</span></div><div class="line">Callable&lt;Integer&gt; c2 = <span class="keyword">true</span> ? (() -&gt; <span class="number">42</span>) : (() -&gt; <span class="number">24</span>);</div><div class="line">System.out.println(c2.call());</div><div class="line"></div><div class="line"><span class="comment">// 定义一个递归函数，注意须用this限定</span></div><div class="line"><span class="keyword">protected</span> UnaryOperator&lt;Integer&gt; factorial = i -&gt; i == <span class="number">0</span> ? <span class="number">1</span> : i * <span class="keyword">this</span>.factorial.apply( i - <span class="number">1</span> );</div><div class="line">...</div><div class="line">System.out.println(factorial.apply(<span class="number">3</span>));</div></pre></td></tr></table></figure><p>在Java中，随声明随调用的方式是不行的，比如下面这样，声明了一个λ表达式(x, y) -&gt; x + y，同时企图通过传入实参(2, 3)来调用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> five = ( (x, y) -&gt; x + y ) (<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// ERROR! try to call a lambda in-place</span></div></pre></td></tr></table></figure><p>这在C++中是可以的，但Java中不行。Java的λ表达式只能用作赋值、传参、返回值等。</p><h3 id="4-其它相关概念"><a href="#4-其它相关概念" class="headerlink" title="4. 其它相关概念"></a><strong>4. 其它相关概念</strong></h3><h4 id="捕获（Capture）"><a href="#捕获（Capture）" class="headerlink" title="捕获（Capture）"></a><strong><em>捕获（Capture）</em></strong></h4><p>捕获的概念在于解决在λ表达式中我们可以使用哪些外部变量（即除了它自己的参数和内部定义的本地变量）的问题。</p><p>答案是：与内部类非常相似，但有不同点。不同点在于内部类总是持有一个其外部类对象的引用。而λ表达式呢，除非在它内部用到了其外部类（包围类）对象的方法或者成员，否则它就不持有这个对象的引用。</p><p>在Java8以前，如果要在内部类访问外部对象的一个本地变量，那么这个变量必须声明为final才行。在Java8中，这种限制被去掉了，代之以一个新的概念，“effectively final”。它的意思是你可以声明为final，也可以不声明final但是按照final来用，也就是一次赋值永不改变。换句话说，保证它加上final前缀后不会出编译错误。</p><p>在Java8中，内部类和λ表达式都可以访问effectively final的本地变量。λ表达式的例子如下：</p><pre><code>...    </code></pre><p>​    int tmp1 = 1; //包围类的成员变量<br>​    static int tmp2 = 2; //包围类的静态成员变量<br>​    public void testCapture() {<br>​        int tmp3 = 3; //没有声明为final，但是effectively final的本地变量<br>​        final int tmp4 = 4; //声明为final的本地变量<br>​        int tmp5 = 5; //普通本地变量<br>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    Function&lt;Integer, Integer&gt; f1 = i -&gt; i + tmp1;</div><div class="line">    Function&lt;Integer, Integer&gt; f2 = i -&gt; i + tmp2;</div><div class="line">    Function&lt;Integer, Integer&gt; f3 = i -&gt; i + tmp3;</div><div class="line">    Function&lt;Integer, Integer&gt; f4 = i -&gt; i + tmp4;</div><div class="line">    Function&lt;Integer, Integer&gt; f5 = i -&gt; &#123;</div><div class="line">        tmp5  += i; <span class="comment">// 编译错！对tmp5赋值导致它不是effectively final的</span></div><div class="line">        <span class="keyword">return</span> tmp5;</div><div class="line">    &#125;;</div><div class="line">    ...</div><div class="line">    tmp5 = <span class="number">9</span>; <span class="comment">// 编译错！对tmp5赋值导致它不是effectively final的</span></div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p><p>Java要求本地变量final或者effectively final的原因是多线程并发问题。内部类、λ表达式都有可能在不同的线程中执行，允许多个线程同时修改一个本地变量不符合Java的设计理念。</p><h4 id="方法引用（Method-reference）"><a href="#方法引用（Method-reference）" class="headerlink" title="方法引用（Method reference）"></a><strong><em>方法引用（Method reference）</em></strong></h4><p>任何一个λ表达式都可以代表某个函数接口的唯一方法的匿名描述符。我们也可以使用某个类的某个具体方法来代表这个描述符，叫做方法引用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer::parseInt <span class="comment">//静态方法引用</span></div><div class="line">System.out::print <span class="comment">//实例方法引用</span></div><div class="line">Person::<span class="keyword">new</span>       <span class="comment">//构造器引用</span></div></pre></td></tr></table></figure><p>下面是一组例子，教你使用方法引用代替λ表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//c1 与 c2 是一样的（静态方法引用）</span></div><div class="line">Comparator&lt;Integer&gt; c2 = (x, y) -&gt; Integer.compare(x, y);</div><div class="line">Comparator&lt;Integer&gt; c1 = Integer::compare;</div><div class="line"></div><div class="line"><span class="comment">//下面两句是一样的（实例方法引用1）</span></div><div class="line">persons.forEach(e -&gt; System.out.println(e));</div><div class="line">persons.forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">//下面两句是一样的（实例方法引用2）</span></div><div class="line">persons.forEach(person -&gt; person.eat());</div><div class="line">persons.forEach(Person::eat);</div><div class="line"></div><div class="line"><span class="comment">//下面两句是一样的（构造器引用）</span></div><div class="line">strList.stream().map(s -&gt; <span class="keyword">new</span> Integer(s));</div><div class="line">strList.stream().map(Integer::<span class="keyword">new</span>);</div></pre></td></tr></table></figure><p>使用方法引用，你的程序会变得更短些。现在distinctPrimarySum方法可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">distinctPrimarySum</span><span class="params">(String... numbers)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; l = Arrays.asList(numbers);</div><div class="line">    <span class="keyword">int</span> sum = l.stream().map(Integer::<span class="keyword">new</span>).filter(Primes::isPrime).distinct().sum();</div><div class="line">    System.out.println(<span class="string">"distinctPrimarySum result is: "</span> + sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还有一些其它的方法引用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">super</span>::toString <span class="comment">//引用某个对象的父类方法</span></div><div class="line">String[]::<span class="keyword">new</span> <span class="comment">//引用一个数组的构造器</span></div></pre></td></tr></table></figure><h4 id="默认方法（Default-method）"><a href="#默认方法（Default-method）" class="headerlink" title="默认方法（Default method）"></a><strong><em>默认方法（Default method）</em></strong></h4><p>Java8中，接口声明里可以有方法实现了，叫做默认方法。在此之前，接口里的方法全部是抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterf</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">m1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">m2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello default method!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这实际上混淆了接口和抽象类，但一个类仍然可以实现多个接口，而只能继承一个抽象类。</p><p>这么做的原因是：由于Collection库需要为批处理操作添加新的方法，如forEach()，stream()等，但是不能修改现有的Collection接口——如果那样做的话所有的实现类都要进行修改，包括很多客户自制的实现类。所以只好使用这种妥协的办法。</p><p>如此一来，我们就面临一种类似多继承的问题。如果类Sub继承了两个接口，Base1和Base2，而这两个接口恰好具有完全相同的两个默认方法，那么就会产生冲突。这时Sub类就必须通过重载来显式指明自己要使用哪一个接口的实现（或者提供自己的实现）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">implements</span> <span class="title">Base1</span>, <span class="title">Base2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</div><div class="line">        Base1.<span class="keyword">super</span>.hello(); <span class="comment">//使用Base1的实现</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>除了默认方法，Java8的接口也可以有静态方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterf</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">m1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">m2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello default method!"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">m3</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello static method in Interface!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="生成器函数（Generator-function）"><a href="#生成器函数（Generator-function）" class="headerlink" title="生成器函数（Generator function）"></a><strong><em>生成器函数（Generator function）</em></strong></h4><p>有时候一个流的数据源不一定是一个已存在的集合对象，也可能是个“生成器函数”。一个生成器函数会产生一系列元素，供给一个流。Stream.generate(Supplier<t> s)就是一个生成器函数。其中参数Supplier是一个函数接口，里面有唯一的抽象方法 <t> get()。</t></t></p><p>下面这个例子生成并打印5个随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream.generate(Math::random).limit(<span class="number">5</span>).forEach(System.out::println);</div></pre></td></tr></table></figure><p>注意这个limit(5)，如果没有这个调用，那么这条语句会永远地执行下去。也就是说这个生成器是无穷的。这种调用叫做终结操作，或者短路（short-circuiting）操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Copy On Write</title>
      <link href="/2017/03/29/Copy-On-Write/"/>
      <url>/2017/03/29/Copy-On-Write/</url>
      
        <content type="html"><![CDATA[<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p><h3 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a><strong>什么是CopyOnWrite容器</strong></h3><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><a id="more"></a><p><strong>场景一：对于ArrayList，使用直接方式，一边遍历，一边删除，会报错</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 删除/修改元素</span></div><div class="line"><span class="keyword">for</span>(String item : list)&#123;</div><div class="line">list.remove(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解决办法一：使用迭代器，一边遍历，一边删除，不会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 删除/修改元素 </span></div><div class="line">Iterator&lt;String&gt; it = list.iterator(); </div><div class="line"><span class="keyword">while</span>(it.hasNext())&#123; </div><div class="line">String ele = it.next(); </div><div class="line">it.remove(); </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解决办法二：使用CopyOnWriteArrayList，直接方式，一边遍历，一会删除，不会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(String item : list)&#123; </div><div class="line">list.remove(item); </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>【场景二】对于ArrayList，使用迭代器，一边遍历，一边add，会报错。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; it = list.iterator(); </div><div class="line"><span class="keyword">while</span>(it.hasNext())&#123; </div><div class="line">String str = it.next(); </div><div class="line">String tem = str + <span class="string">"..."</span>; </div><div class="line">list.add(tem); </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解决办法一：改用CopyOnWriteArrayList，直接方式，一边遍历，一边add，不会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(String item : list)&#123; </div><div class="line">String tem = item + <span class="string">"..."</span>; </div><div class="line">list.add(tem); </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解决办法二：改用CopyOnWriteArrayList，一边遍历，一边add，不会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; it = list.iterator(); </div><div class="line"><span class="keyword">while</span>(it.hasNext())&#123; </div><div class="line">String str = it.next(); </div><div class="line">String tem = str + <span class="string">"..."</span>; </div><div class="line">list.add(tem); </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>【场景三】对于CopyOnWriteArrayList，迭代器，不能remove。</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; it = list.iterator(); </div><div class="line"><span class="keyword">while</span>(it.hasNext())&#123; </div><div class="line">String str = it.next(); </div><div class="line">String tem = str + <span class="string">"..."</span>; </div><div class="line">it.remove(); </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解决办法一：使用直接方式，一边遍历，一边add/remove()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(String item : list)&#123; </div><div class="line">String tem = item + <span class="string">"..."</span>; </div><div class="line">list.remove(item); </div><div class="line">list.add(tem); </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h3><p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Object[] elements = getArray();</div><div class="line">        <span class="keyword">int</span> len = elements.length;</div><div class="line">        <span class="comment">// 复制出新数组</span></div><div class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</div><div class="line">        <span class="comment">// 把新元素添加到新数组里</span></div><div class="line">        newElements[len] = e;</div><div class="line">        <span class="comment">// 把原数组引用指向新数组</span></div><div class="line">        setArray(newElements);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</div><div class="line">    array = a;</div><div class="line">&#125;</div><div class="line"><span class="keyword">final</span> Object[] getArray() &#123;</div><div class="line"><span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> get(getArray(), index);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span> </span>&#123;    </div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;K, V&gt; internalMap;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        internalMap = <span class="keyword">new</span> HashMap&lt;K, V&gt;();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Map&lt;K, V&gt; newMap = <span class="keyword">new</span> HashMap&lt;K, V&gt;(internalMap);</div><div class="line">            V val = newMap.put(key, value);</div><div class="line">            internalMap = newMap;</div><div class="line">            <span class="keyword">return</span> val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> internalMap.get(key);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; newData)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Map&lt;K, V&gt; newMap = <span class="keyword">new</span> HashMap&lt;K, V&gt;(internalMap);</div><div class="line">            newMap.putAll(newData);</div><div class="line">            internalMap = newMap;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 黑名单服务</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListServiceImpl</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = <span class="keyword">new</span> CopyOnWriteMap&lt;String, Boolean&gt;(<span class="number">1000</span>);</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBlackList</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> blackListMap.get(id) == <span class="keyword">null</span> ? <span class="keyword">false</span> : <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBlackList</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        blackListMap.put(id, Boolean.TRUE);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 批量添加黑名单</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> ids</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBlackList</span><span class="params">(Map&lt;String,Boolean&gt; ids)</span> </span>&#123;</div><div class="line">        blackListMap.putAll(ids);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p><ol><li><p>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</p></li><li><p>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</p></li></ol><h3 id="CopyOnWrite的缺点"><a href="#CopyOnWrite的缺点" class="headerlink" title="CopyOnWrite的缺点"></a><strong>CopyOnWrite的缺点</strong></h3><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p><p><strong>内存占用问题</strong>。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p><p><strong>针对内存占用问题</strong>，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p><p>数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常处理机制</title>
      <link href="/2017/03/28/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/03/28/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>try…catch…finally恐怕是大家再熟悉不过的语句了，而且感觉用起来也是很简单，逻辑上似乎也是很容易理解。不过，我亲自体验的“教训”告诉我，这个东西可不是想象中的那么简单、听话。不信？那你看看下面的代码，“猜猜”它执行后的结果会是什么？不要往后看答案、也不许执行代码看真正答案哦。如果你的答案是正确，那么这篇文章你就不用浪费时间看啦。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestException</span><span class="params">()</span> </span>&#123;  </div><div class="line"></div><div class="line">    &#125;    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">testEx</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            ret = testEx1();  </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </div><div class="line">            System.out.println(<span class="string">"testEx, catch exception"</span>);  </div><div class="line">            ret = <span class="keyword">false</span>;  </div><div class="line">            <span class="keyword">throw</span> e;  </div><div class="line">        &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">            System.out.println(<span class="string">"testEx, finally; return value="</span> + ret);  </div><div class="line">            <span class="keyword">return</span> ret;  </div><div class="line">        &#125;  </div><div class="line">    &#125;   </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">testEx1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            ret = testEx2();  </div><div class="line">            <span class="keyword">if</span> (!ret) &#123;  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">            &#125;  </div><div class="line">            System.out.println(<span class="string">"testEx1, at the end of try"</span>);  </div><div class="line">            <span class="keyword">return</span> ret;  </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </div><div class="line">            System.out.println(<span class="string">"testEx1, catch exception"</span>);  </div><div class="line">            ret = <span class="keyword">false</span>;  </div><div class="line">            <span class="keyword">throw</span> e;  </div><div class="line">        &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">            System.out.println(<span class="string">"testEx1, finally; return value="</span> + ret);  </div><div class="line">            <span class="keyword">return</span> ret;  </div><div class="line">        &#125;  </div><div class="line">    &#125;    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">testEx2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">int</span> b = <span class="number">12</span>;  </div><div class="line">            <span class="keyword">int</span> c;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &gt;= -<span class="number">2</span>; i--) &#123;  </div><div class="line">                c = b / i;  </div><div class="line">                System.out.println(<span class="string">"i="</span> + i);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </div><div class="line">            System.out.println(<span class="string">"testEx2, catch exception"</span>);  </div><div class="line">            ret = <span class="keyword">false</span>;  </div><div class="line">            <span class="keyword">throw</span> e;  </div><div class="line">        &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">            System.out.println(<span class="string">"testEx2, finally; return value="</span> + ret);  </div><div class="line">            <span class="keyword">return</span> ret;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        TestException testException1 = <span class="keyword">new</span> TestException();  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            testException1.testEx();  </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你的答案是什么？是下面的答案吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">i=<span class="number">2</span></div><div class="line">i=<span class="number">1</span></div><div class="line">testEx2, <span class="keyword">catch</span> exception</div><div class="line">testEx2, <span class="keyword">finally</span>; <span class="keyword">return</span> value=<span class="keyword">false</span></div><div class="line">testEx1, <span class="keyword">catch</span> exception</div><div class="line">testEx1, <span class="keyword">finally</span>; <span class="keyword">return</span> value=<span class="keyword">false</span></div><div class="line">testEx, <span class="keyword">catch</span> exception</div><div class="line">testEx, <span class="keyword">finally</span>; <span class="keyword">return</span> value=<span class="keyword">false</span></div></pre></td></tr></table></figure><p>如果你的答案真的如上面所说，那么你错啦。^_^，那就建议你仔细看一看这篇文章或者拿上面的代码按各种不同的情况修改、执行、测试，你会发现有很多事情不是原来想象中的那么简单的。现在公布正确答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">i=<span class="number">2</span></div><div class="line">i=<span class="number">1</span></div><div class="line">testEx2, <span class="keyword">catch</span> exception</div><div class="line">testEx2, <span class="keyword">finally</span>; <span class="keyword">return</span> value=<span class="keyword">false</span></div><div class="line">testEx1, <span class="keyword">finally</span>; <span class="keyword">return</span> value=<span class="keyword">false</span></div><div class="line">testEx, <span class="keyword">finally</span>; <span class="keyword">return</span> value=<span class="keyword">false</span></div></pre></td></tr></table></figure><p>注意说明：</p><p>finally语句块不应该出现return。上面的return ret最好是其他语句来处理相关逻辑。</p><h3 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h3><p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p><p>Java异常类层次结构图：</p><p><img src="/images/Java/2018061201.jpg" alt=""></p><p>在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。</p><p><strong>Throwable</strong>： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><p> <strong>Error（错误）</strong>:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p><p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p><p><strong>Exception（异常）</strong>:是程序本身可以处理的异常。</p><p> Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</p><blockquote><p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p></blockquote><p>通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。</p><h3 id="可查异常-编译器要求必须处置的异常-："><a href="#可查异常-编译器要求必须处置的异常-：" class="headerlink" title="可查异常(编译器要求必须处置的异常)："></a><strong>可查异常(编译器要求必须处置的异常)</strong>：</h3><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><h3 id="不可查异常-编译器不要求强制处置的异常"><a href="#不可查异常-编译器不要求强制处置的异常" class="headerlink" title="不可查异常(编译器不要求强制处置的异常):"></a><strong>不可查异常(编译器不要求强制处置的异常)</strong>:</h3><p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p><p>Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。</p><h3 id="运行时异常："><a href="#运行时异常：" class="headerlink" title="运行时异常："></a><strong>运行时异常</strong>：</h3><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><h3 id="非运行时异常-编译异常-："><a href="#非运行时异常-编译异常-：" class="headerlink" title="非运行时异常(编译异常)："></a><strong>非运行时异常(编译异常)</strong>：</h3><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h3 id="处理异常机制"><a href="#处理异常机制" class="headerlink" title="处理异常机制"></a>处理异常机制</h3><p>在 Java 应用程序中，异常处理机制为：抛出异常，捕捉异常。</p><p><strong>抛出异常</strong>：</p><p>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java冒泡排序</title>
      <link href="/2017/03/28/Java%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2017/03/28/Java%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="排序算法概述"><a href="#排序算法概述" class="headerlink" title="排序算法概述"></a>排序算法概述</h3><p>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。</p><p><strong>稳定性</strong>：一个排序算法是稳定的，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。</p><p>如果算法是稳定的有什么好处呢？排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。</p><a id="more"></a><hr><p>排序算法根据是否需要访问外存分为内部排序和外部排序。</p><p><strong>内部排序</strong>是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列。</p><p><strong>外部排序</strong>指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。</p><p><img src="/images/Java/2019031404.png" alt=""></p><p>我们现在要讨论的排序都是内部排序。</p><hr><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h3><p>冒泡排序的效率很低，但是算法实现起来很简单，因此很适合作为研究排序的入门算法。</p><p><strong>基本思想</strong></p><p>对当前还未排好序的范围内的全部数，自上而下对相邻的俩个数依次进行比较和调整，让较大的数下沉，较小的数往上冒。即：每当俩相邻的数比较后发现他们的排序与排序的要求相反时，就将他们交换。每次遍历都可确定一个最大值放到待排数组的末尾，下次遍历，对该最大值以及它之后的元素不再排序（已经排好）。</p><p><img src="https://raw.githubusercontent.com/scalad/Note/master/image/java_buddle_sort.jpg" alt=""></p><p>java实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> [] array;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sort</span><span class="params">(<span class="keyword">int</span> [] array)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.array = array;</div><div class="line">&#125;</div><div class="line"><span class="comment">//按顺序打印数组中的元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</div><div class="line">System.out.print(array[i]+<span class="string">"\t"</span>);</div><div class="line">&#125;</div><div class="line">System.out.println();</div><div class="line">&#125;</div><div class="line"><span class="comment">//冒泡排序</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">int</span> temp;</div><div class="line"><span class="keyword">int</span> len = array.length;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;  <span class="comment">//外层循环：每循环一次就确定了一个相对最大元素</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len-i;j++)&#123;  <span class="comment">//内层循环：有i个元素已经排好，根据i确定本次的比较次数</span></div><div class="line"><span class="keyword">if</span>(array[j-<span class="number">1</span>]&gt;array[j])&#123;  <span class="comment">//如果前一位大于后一位，交换位置</span></div><div class="line">temp = array[j-<span class="number">1</span>];</div><div class="line">array[j-<span class="number">1</span>] = array[j];</div><div class="line">array[j] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">System.out.print(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"轮排序结果："</span>);  </div><div class="line">display();  </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> [] a = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">20</span>,<span class="number">18</span>&#125;;</div><div class="line">Sort sort = <span class="keyword">new</span> Sort(a);</div><div class="line">System.out.print(<span class="string">"未排序时的结果："</span>);</div><div class="line">sort.display();</div><div class="line">sort.bubbleSort();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>打印结果：</p><p><img src="/images/Java/2019031405.png" alt=""></p><p><strong>算法分析</strong></p><p>上面的例子中，待排数组中一共有7个数，第一轮排序时进行了6次比较，第二轮排序时进行了5比较，依次类推，最后一轮进行了一次比较。加入元素总数为N，则一共需要的比较次数为：</p><pre><code>(N-1)+ (N-2)+ (N-3)+ ...1=N*(N-1)/2</code></pre><p>这样，算法约做了N2/2次比较。因为只有在前面的元素比后面的元素大时才交换数据，所以交换的次数少于比较的次数。如果数据是随机的，大概有一半数据需要交换，则交换的次数为N2/4（不过在最坏情况下，即初始数据逆序时，每次比较都需要交换）。</p><p>交换和比较的操作次数都与N2成正比，由于在大O表示法中，常数忽略不计，冒泡排序的时间复杂度为O(N2)。O(N2)的时间复杂度是一个比较糟糕的结果，尤其在数据量很大的情况下。所以冒泡排序通常不会用于实际应用。</p><h3 id="冒泡排序的改进"><a href="#冒泡排序的改进" class="headerlink" title="冒泡排序的改进"></a><strong>冒泡排序的改进</strong></h3><p>上面已经分析过，冒泡排序的效率比较低，所以我们要通过各种方法改进。</p><p>最简单的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程.</p><p>在上例中，第四轮排序之后实际上整个数组已经是有序的了，最后两轮的比较没必要进行。</p><p>改进后的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//冒泡排序改进1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort_improvement_1</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">int</span> temp;</div><div class="line"><span class="keyword">int</span> len = array.length;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</div><div class="line"><span class="keyword">boolean</span> exchange = <span class="keyword">false</span>;  <span class="comment">//设置交换变量</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len-i;j++)&#123;</div><div class="line"><span class="keyword">if</span>(array[j-<span class="number">1</span>]&gt;array[j])&#123;  <span class="comment">//如果前一位大于后一位，交换位置</span></div><div class="line">temp = array[j-<span class="number">1</span>];</div><div class="line">array[j-<span class="number">1</span>] = array[j];</div><div class="line">array[j] = temp;</div><div class="line"><span class="keyword">if</span>(!exchange)&#123;</div><div class="line">exchange =<span class="keyword">true</span>;  <span class="comment">//发生了交换操作</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">System.out.print(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"轮排序结果："</span>);</div><div class="line">display();</div><div class="line"><span class="keyword">if</span>(!exchange)&#123;</div><div class="line"><span class="keyword">break</span>;  <span class="comment">//如果上一轮没有发生交换数据，证明已经是有序的了，结束排序</span></div><div class="line">&#125;  </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>用同样的初始数组测试，打印结果如下：</p><p><img src="/images/Java/2019031406.png" alt=""></p><p>上面的改进方法，是根据上一轮排序有没有发生数据交换作为标识，进一步思考，如果上一轮排序中，只有后一段的几个元素没有发生数据交换，是不是可以判定这一段不用在进行比较了呢？答案是肯定的。</p><p>例如上面的例子中，前四轮的排序结果为：</p><pre><code>未排序时的结果：1   5  4  11 2  20 18第1轮排序结果：1  4  5  2  11 18 20第2轮排序结果：1  4  2  5  11 18 20第3轮排序结果：1  2  4  5  11 18 20第4轮排序结果：1  2  4  5  11 18 20</code></pre><p>第1轮排序之后，11、18、20已经是有序的了，后面的几次排序后它们的位置都没有变化，但是根据冒泡算法，18依然会在第2轮参与比较，11依然会在第2轮、第3轮参与比较，其实都是无用功。</p><p>我们可以对算法进一步改进：设置一个pos指针，pos后面的数据在上一轮排序中没有发生交换，下一轮排序时，就对pos之后的数据不再比较。</p><p>代码改动如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//冒泡排序改进2  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort_improvement_2</span><span class="params">()</span></span>&#123;  </div><div class="line"><span class="keyword">int</span> temp;  </div><div class="line"><span class="keyword">int</span> counter = <span class="number">1</span>;  </div><div class="line"><span class="keyword">int</span> endPoint = array.length-<span class="number">1</span>;  <span class="comment">//endPoint代表最后一个需要比较的元素下标      </span></div><div class="line"><span class="keyword">while</span>(endPoint&gt;<span class="number">0</span>)&#123;   </div><div class="line">intpos = <span class="number">1</span>;  </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=endPoint;j++)&#123;    </div><div class="line"><span class="keyword">if</span>(array[j-<span class="number">1</span>]&gt;array[j])&#123;  <span class="comment">//如果前一位大于后一位，交换位置  </span></div><div class="line">temp= array[j-<span class="number">1</span>];  </div><div class="line">array[j-<span class="number">1</span>]= array[j];  </div><div class="line">array[j]= temp;               </div><div class="line">pos= j;  <span class="comment">//下标为j的元素与下标为j-1的元素发生了数据交换  </span></div><div class="line">&#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">//下一轮排序时只对下标小于pos的元素排序，下标大于等于pos的元素已经排好  </span></div><div class="line">endPoint= pos-<span class="number">1</span>;         </div><div class="line">System.out.print(<span class="string">"第"</span>+counter+<span class="string">"轮排序结果："</span>);  </div><div class="line">display();  </div><div class="line">&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对的算法来说，没有最好，只有更好。上面的两种改进方法其实治标不治本，是一种“扬汤止沸”的改进，下面我们来一次“釜底抽薪”的改进。</p><p>传统的冒泡算法每次排序只确定了最大值，我们可以在每次循环之中进行正反两次冒泡，分别找到最大值和最小值，如此可使排序的轮数减少一半。</p><p>改进代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//冒泡排序改进3  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort_improvement_3</span><span class="params">()</span></span>&#123;  </div><div class="line"><span class="keyword">int</span> temp;  </div><div class="line"><span class="keyword">int</span> low = <span class="number">0</span>;  </div><div class="line"><span class="keyword">int</span> high = array.length-<span class="number">1</span>;  </div><div class="line"><span class="keyword">int</span> counter = <span class="number">1</span>;  </div><div class="line"><span class="keyword">while</span>(low&lt;high)&#123;          </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;high;++i)&#123;   <span class="comment">//正向冒泡，确定最大值  </span></div><div class="line"><span class="keyword">if</span>(array[i]&gt;array[i+<span class="number">1</span>])&#123;  <span class="comment">//如果前一位大于后一位，交换位置  </span></div><div class="line">temp= array[i];  </div><div class="line">array[i]= array[i+<span class="number">1</span>];  </div><div class="line">array[i+<span class="number">1</span>]= temp;  </div><div class="line">&#125;  </div><div class="line">&#125;  </div><div class="line">--high;      </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=high;j&gt;low;--j)&#123;   <span class="comment">//反向冒泡，确定最小值  </span></div><div class="line"><span class="keyword">if</span>(array[j]&lt;array[j-<span class="number">1</span>])&#123;  <span class="comment">//如果前一位大于后一位，交换位置  </span></div><div class="line">temp= array[j];  </div><div class="line">array[j]= array[j-<span class="number">1</span>];  </div><div class="line">array[j-<span class="number">1</span>]= temp;  </div><div class="line">&#125;  </div><div class="line">&#125;  </div><div class="line">++low;        </div><div class="line">System.out.print(<span class="string">"第"</span>+counter+<span class="string">"轮排序结果："</span>);  </div><div class="line">display();  </div><div class="line">counter++;  </div><div class="line">&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap从jdk1.7到jdk1.8的变化</title>
      <link href="/2017/03/27/ConcurrentHashMap%E4%BB%8Ejdk1.7%E5%88%B0jdk1.8%E7%9A%84%E5%8F%98%E5%8C%96/"/>
      <url>/2017/03/27/ConcurrentHashMap%E4%BB%8Ejdk1.7%E5%88%B0jdk1.8%E7%9A%84%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>(转自<a href="https://github.com/muyinchen/woker/blob/master/JAVA8/ConcurrentHashMap%E4%BB%8Ejdk1.7%E5%88%B0jdk1.8%E7%9A%84%E5%8F%98%E5%8C%96.md" target="_blank" rel="external">知秋</a>)</p><h3 id="一、简单回顾ConcurrentHashMap在jdk1-7中的设计"><a href="#一、简单回顾ConcurrentHashMap在jdk1-7中的设计" class="headerlink" title="一、简单回顾ConcurrentHashMap在jdk1.7中的设计"></a><strong>一、简单回顾ConcurrentHashMap在jdk1.7中的设计</strong></h3><p>先简单看下ConcurrentHashMap类在jdk1.7中的设计，其基本结构如图所示：</p><p><img src="/images/Java/2018061202.png" alt="img"></p><p>每一个segment都是一个HashEntry<k,v>[] table， table中的每一个元素本质上都是一个HashEntry的单向队列。比如table[3]为首节点，table[3]-&gt;next为节点1，之后为节点2，依次类推。</k,v></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span> &#123;</div><div class="line">    <span class="comment">// 将整个hashmap分成几个小的map，每个segment都是一个锁；与hashtable相比，这么设计的目的是对于put, remove等操作，可以减少并发冲突，对</span></div><div class="line">    <span class="comment">// 不属于同一个片段的节点可以并发操作，大大提高了性能</span></div><div class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</div><div class="line">    <span class="comment">// 本质上Segment类就是一个小的hashmap，里面table数组存储了各个节点的数据，继承了ReentrantLock, 可以作为互拆锁使用</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</div><div class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> count;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 基本节点，存储Key， Value值</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        <span class="keyword">volatile</span> V value;</div><div class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="二、在jdk1-8中主要做了2方面的改进"><a href="#二、在jdk1-8中主要做了2方面的改进" class="headerlink" title="二、在jdk1.8中主要做了2方面的改进"></a><strong>二、在jdk1.8中主要做了2方面的改进</strong></h3><p><strong>改进一：取消segments字段，直接采用transient volatile HashEntry<k,v>[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</k,v></strong></p><p><strong>改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。</strong></p><p>为了说明以上2个改动，看一下put操作是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</div><div class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">        <span class="comment">// 如果table为空，初始化；否则，根据hash值计算得到数组索引i，如果tab[i]为空，直接新建节点Node即可。注：tab[i]实质为链表或者红黑树的首节点。</span></div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            tab = initTable();</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</div><div class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果tab[i]不为空并且hash值为MOVED，说明该链表正在进行transfer操作，返回扩容完成后的table。</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            V oldVal = <span class="keyword">null</span>;</div><div class="line">            <span class="comment">// 针对首个节点进行加锁操作，而不是segment，进一步减少线程冲突</span></div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        binCount = <span class="number">1</span>;</div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                            K ek;</div><div class="line">                            <span class="comment">// 如果在链表中找到值为key的节点e，直接设置e.val = value即可。</span></div><div class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                oldVal = e.val;</div><div class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                    e.val = value;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">// 如果没有找到值为key的节点，直接新建Node并加入链表即可。</span></div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, <span class="keyword">null</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 如果首节点为TreeBin类型，说明为红黑树结构，执行putTreeVal操作。</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = <span class="number">2</span>;</div><div class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                            oldVal = p.val;</div><div class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 如果节点数&gt;＝8，那么转换链表结构为红黑树结构。</span></div><div class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                    treeifyBin(tab, i);</div><div class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> oldVal;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 计数增加1，有可能触发transfer操作(扩容)。</span></div><div class="line">    addCount(<span class="number">1L</span>, binCount);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另外，在其他方面也有一些小的改进，比如新增字段 transient volatile CounterCell[] counterCells; 可方便的计算hashmap中所有元素的个数，性能大大优于jdk1.7中的size()方法。</p><h3 id="三、ConcurrentHashMap-jdk1-7、jdk1-8性能比较"><a href="#三、ConcurrentHashMap-jdk1-7、jdk1-8性能比较" class="headerlink" title="三、ConcurrentHashMap jdk1.7、jdk1.8性能比较"></a><strong>三、ConcurrentHashMap jdk1.7、jdk1.8性能比较</strong></h3><p>测试程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareConcurrentHashMap</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Integer&gt;(<span class="number">40000</span>);</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putPerformance</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; (num + index) ; i++)</div><div class="line">            map.put(String.valueOf(i), i);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getPerformance2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">400000</span>; i++)</div><div class="line">            map.get(String.valueOf(i));</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"get: it costs "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">final</span> CountDownLatch cdLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">4</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    CompareConcurrentHashMap.putPerformance(<span class="number">100000</span> * finalI, <span class="number">100000</span>);</div><div class="line">                    cdLatch.countDown();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">        cdLatch.await();</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"put: it costs "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line">        CompareConcurrentHashMap.getPerformance2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>程序运行多次后取平均值，结果如下：</p><p><img src="/images/Java/2018061203.png" alt="img"></p><h3 id="四、Collections-synchronizedList和CopyOnWriteArrayList性能分析"><a href="#四、Collections-synchronizedList和CopyOnWriteArrayList性能分析" class="headerlink" title="四、Collections.synchronizedList和CopyOnWriteArrayList性能分析"></a><strong>四、Collections.synchronizedList和CopyOnWriteArrayList性能分析</strong></h3><p>CopyOnWriteArrayList在线程对其进行变更操作的时候，会拷贝一个新的数组以存放新的字段，因此写操作性能很差；而Collections.synchronizedList读操作采用了synchronized，因此读性能较差。以下为测试程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; arrayList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; copyOnWriteArrayList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch cdl1 = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch cdl2 = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch cdl3 = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch cdl4 = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</div><div class="line">                arrayList.add(String.valueOf(i));</div><div class="line">            cdl1.countDown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</div><div class="line">                copyOnWriteArrayList.add(String.valueOf(i));</div><div class="line">            cdl2.countDown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread3</span> <span class="keyword">extends</span> <span class="title">Thread1</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> size = arrayList.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">                arrayList.get(i);</div><div class="line">            cdl3.countDown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread4</span> <span class="keyword">extends</span> <span class="title">Thread1</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> size = copyOnWriteArrayList.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">                copyOnWriteArrayList.get(i);</div><div class="line">            cdl4.countDown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</div><div class="line">        <span class="keyword">new</span> Thread1().start();</div><div class="line">        <span class="keyword">new</span> Thread1().start();</div><div class="line">        cdl1.await();</div><div class="line">        System.out.println(<span class="string">"arrayList add: "</span> + (System.currentTimeMillis() - start1));</div><div class="line"></div><div class="line">        <span class="keyword">long</span> start2 = System.currentTimeMillis();</div><div class="line">        <span class="keyword">new</span> Thread2().start();</div><div class="line">        <span class="keyword">new</span> Thread2().start();</div><div class="line">        cdl2.await();</div><div class="line">        System.out.println(<span class="string">"copyOnWriteArrayList add: "</span> + (System.currentTimeMillis() - start2));</div><div class="line"></div><div class="line">        <span class="keyword">long</span> start3 = System.currentTimeMillis();</div><div class="line">        <span class="keyword">new</span> Thread3().start();</div><div class="line">        <span class="keyword">new</span> Thread3().start();</div><div class="line">        cdl3.await();</div><div class="line">        System.out.println(<span class="string">"arrayList get: "</span> + (System.currentTimeMillis() - start3));</div><div class="line"></div><div class="line">        <span class="keyword">long</span> start4 = System.currentTimeMillis();</div><div class="line">        <span class="keyword">new</span> Thread4().start();</div><div class="line">        <span class="keyword">new</span> Thread4().start();</div><div class="line">        cdl4.await();</div><div class="line">        System.out.println(<span class="string">"copyOnWriteArrayList get: "</span> + (System.currentTimeMillis() - start4));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="结果如下："><a href="#结果如下：" class="headerlink" title="结果如下："></a>结果如下：</h3><p><img src="/images/Java/2018061204.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Java深入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList And Vector</title>
      <link href="/2017/03/26/ArrayList-And-Vector/"/>
      <url>/2017/03/26/ArrayList-And-Vector/</url>
      
        <content type="html"><![CDATA[<p>List,是元素的有序列表。当我们讨论List时，将其与Set作对比是一个很好的办法,Set集合中的元素是无序且唯一的。</p><p>List接口下一共实现了三个类：ArrayList，Vector，LinkedList。LinkedList就不多说了，它一般主要用在保持数据的插入顺序的时候。ArrayList和Vector都是用数组实现的，主要有这么三个区别：</p><ol><li><p>Vector是多线程安全的，而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；</p></li><li><p>两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同的，很多网友说Vector增加原来空间的一倍，ArrayList增加原来空间的50%，其实也差不多是这个意思，不过还有一点点问题可以从源码中看出，一会儿从源码中分析。</p></li><li><p>Vector可以设置增长因子，而ArrayList不可以，最开始看这个的时候，我没理解什么是增量因子，不过通过对比一下两个源码理解了这个，先看看两个类的构造方法： ArrayList有三个构造方法：分别是</p><a id="more"></a></li></ol><h3 id="构造器比较"><a href="#构造器比较" class="headerlink" title="构造器比较"></a>构造器比较</h3><p>ArrayList有三个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span><span class="comment">//构造一个具有指定初始容量的空列表。  </span></span></div><div class="line"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span><span class="comment">//构造一个初始容量为10的空列表。  </span></div><div class="line"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span><span class="comment">//构造一个包含指定 collection 的元素的列表</span></div></pre></td></tr></table></figure><p>Vector有四个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用指定的初始容量和等于零的容量增量构造一个空向量。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span>  </span></div><div class="line"><span class="comment">//构造一个空向量，使其内部数据数组的大小，其标准容量增量为零。</span></div><div class="line"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></div><div class="line"><span class="comment">//构造一个包含指定 collection 中的元素的向量    </span></div><div class="line"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span></div><div class="line"><span class="comment">//使用指定的初始容量和容量增量构造一个空的向量  </span></div><div class="line"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity,<span class="keyword">int</span> capacityIncrement)</span></div></pre></td></tr></table></figure><h3 id="增长因子比较"><a href="#增长因子比较" class="headerlink" title="增长因子比较"></a>增长因子比较</h3><p>Vector比Arraylist多一个构造方法，没错就是<br>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity,<span class="keyword">int</span> capacityIncrement)</span></span></div></pre></td></tr></table></figure></p><p>这个构造方法capacityIncrement就是容量增长，即前面所说的增长因子，ArrayList中是没有的。 再贴出两个类的添加源码分析下（jdk1.7版本）：</p><blockquote><p>ArrayList类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></div><div class="line">    elementData[size++] = e;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line">    modCount++;  </div><div class="line">    <span class="comment">// overflow-conscious code  </span></div><div class="line">    <span class="comment">//如果添加一个元素之后，新容器的大小大于容器的容量，那么就无法存值了，需要扩充空间  </span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  </div><div class="line">        grow(minCapacity);  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line">    <span class="comment">// overflow-conscious code  </span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line">    <span class="comment">//扩充的空间增加原来的50%（即是原来的1.5倍）  </span></div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="comment">//如果容器扩容之后还是不够，那么干脆直接将minCapacity设为容器的大小   </span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) </div><div class="line">        newCapacity = minCapacity;  </div><div class="line">    <span class="comment">//如果扩充的容器太大了的话，那么就执行hugeCapacity  </span></div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) </div><div class="line">        newCapacity = hugeCapacity(minCapacity);  </div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:  </span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>jdk1.6版本是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line">    modCount++;  </div><div class="line"><span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line"><span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;  </div><div class="line">Object oldData[] = elementData;  </div><div class="line"><span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>) / <span class="number">2</span> + <span class="number">1</span>;  </div><div class="line"><span class="keyword">if</span> (newCapacity &lt; minCapacity)  </div><div class="line">newCapacity = minCapacity;  </div><div class="line"><span class="comment">// minCapacity is usually close to size, so this is a win:  </span></div><div class="line">elementData = Arrays.copyOf(elementData, newCapacity);  </div><div class="line">&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>Vector类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">modCount++;  </div><div class="line">ensureCapacityHelper(elementCount + <span class="number">1</span>);  </div><div class="line">elementData[elementCount++] = e;  </div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="comment">// overflow-conscious code  </span></div><div class="line"><span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  </div><div class="line">grow(minCapacity);  </div><div class="line">&#125;  </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="comment">// overflow-conscious code  </span></div><div class="line"><span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line"><span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?  capacityIncrement : oldCapacity);  </div><div class="line"><span class="comment">/** </span></div><div class="line">这个扩容需要做个判断：如果容量增量初始化的不是0，即使用的public Vector(int initialCapacity,int capacityIncrement) </div><div class="line">构造方法进行的初始化，那么扩容的容量是(oldCapacity+capacityIncrement)，就是原来的容量加上容量增量的值； </div><div class="line">如果没有设置容量增量，那么扩容后的容量就是(oldCapacity+oldCapacity)，就是原来容量的二倍。 </div><div class="line">**/  </div><div class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  </div><div class="line">newCapacity = minCapacity;  </div><div class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)  </div><div class="line">newCapacity = hugeCapacity(minCapacity);  </div><div class="line">elementData = Arrays.copyOf(elementData, newCapacity);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>jdk1.6版本是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line"><span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line"><span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;  </div><div class="line">Object[] oldData = elementData;  </div><div class="line"><span class="keyword">int</span> newCapacity = (capacityIncrement &gt; <span class="number">0</span>) ? (oldCapacity + capacityIncrement) : (oldCapacity * <span class="number">2</span>);<span class="comment">//方式与jdk1.7一样  </span></div><div class="line">            <span class="keyword">if</span> (newCapacity &lt; minCapacity) &#123;  </div><div class="line">                 newCapacity = minCapacity;  </div><div class="line">            &#125;  </div><div class="line">            elementData = Arrays.copyOf(elementData, newCapacity);  </div><div class="line">       &#125;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法(线程安全)，通常性能上较ArrayList差。</p><h3 id="关于LinkedList"><a href="#关于LinkedList" class="headerlink" title="关于LinkedList"></a>关于LinkedList</h3><p>LinkedList 是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁的情况下的对比,如果数据和运算量很小,那么对比将失去意义.</p><p>而 LinkedList 还实现了 Queue 接口,该接口比List提供了更多的方法,包括 offer(),peek(),poll()等.注意: 默认情况下ArrayList的初始容量非常小,所以如果可以预估数据量的话,分配一个较大的初始值属于最佳实践,这样可以减少调整大小的开销。</p><p><strong>什么时候使用ArrayList或Vector</strong></p><p>在什么时候使用ArrayList或Vector，它完全取决于你的需求，如果你需要执行一个线程安全的操作，那么Vector是最好的选择，它保证你同一个时刻只有一个线程访问你的集合。</p><p>性能：同步操作相比没有同步操作消耗更多的时间，所以如果你不需要线程安全的操作，ArrayList将会是更好的选择，它将会因为并发进程提高性能。</p><h3 id="怎么让ArrayList同步"><a href="#怎么让ArrayList同步" class="headerlink" title="怎么让ArrayList同步"></a>怎么让ArrayList同步</h3><p>使用Collecions.synzhonizedList<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</div><div class="line">... </div><div class="line"><span class="comment">//If you wanna use iterator on the synchronized list, use it</span></div><div class="line"><span class="comment">//like this. It should be in synchronized block.</span></div><div class="line"><span class="keyword">synchronized</span> (list) &#123;</div><div class="line">Iterator iterator = list.iterator();</div><div class="line"><span class="keyword">while</span> (iterator.hasNext())</div><div class="line">...</div><div class="line">iterator.next();</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ArrayList,Vector, LinkedList的存储性能和特性<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素， 它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全） ，通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历， 但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。LinkedList 也是线程不安全的，LinkedList 提供了一些方法，使得LinkedList 可以被当作堆栈和队列来使用。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashSet And TreeSet</title>
      <link href="/2017/03/26/HashSet-And-TreeSet/"/>
      <url>/2017/03/26/HashSet-And-TreeSet/</url>
      
        <content type="html"><![CDATA[<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。<br>Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象,并且最多包含一个 null元素。<br>HashSet与TreeSet都是基于Set接口的实现类。其中TreeSet是Set的子接口SortedSet的实现类。Set接口及其子接口、实现类的结构如下所示：</p><pre><code>         |——SortedSet接口——TreeSet实现类Set接口——|——HashSet实现类            |——LinkedHashSet实现类</code></pre><a id="more"></a><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul><li>不能保证元素的排列顺序，顺序有可能发生变化</li><li>不是同步的</li><li>集合元素可以是null,但只能放入一个null</li></ul><p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。</p><p>简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值相等</p><p>注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对 象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。</p><p><strong>例如：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    HashSet hs=<span class="keyword">new</span> HashSet();</div><div class="line">    <span class="comment">/**//*hs.add("one");</span></div><div class="line">    hs.add("two");</div><div class="line">    hs.add("three");</div><div class="line">    hs.add("four");*/</div><div class="line">    hs.add(<span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"zhangsan"</span>));</div><div class="line">    hs.add(<span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">"lishi"</span>));</div><div class="line">    hs.add(<span class="keyword">new</span> Student(<span class="number">3</span>,<span class="string">"wangwu"</span>));</div><div class="line">    hs.add(<span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"zhangsan"</span>));</div><div class="line">    Iterator it=hs.iterator();</div><div class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">        System.out.println(it.next());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123; <span class="comment">//HashSet要重写hashCode和equals方法</span></div><div class="line">    <span class="keyword">int</span> num;</div><div class="line">    String name;</div><div class="line">    Student(<span class="keyword">int</span> num,String name)&#123;</div><div class="line">        <span class="keyword">this</span>.num=num;</div><div class="line">        <span class="keyword">this</span>.name=name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"num :"</span>+num+<span class="string">" name:"</span>+name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> num*name.hashCode();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</div><div class="line">        Student s=(Student)o;</div><div class="line">        <span class="keyword">return</span> num==s.num &amp;&amp; name.equals(s.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h3><p>TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序 和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。<br>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0</p><blockquote><p>自然排序</p></blockquote><p>自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。</p><p>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。<br>obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是 负数，则表明obj1小于obj2。</p><p>如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0</p><blockquote><p>定制排序</p></blockquote><p>自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用Comparator接口，实现 int compare(T o1,T o2)方法,我们可以构造TreeSet对象时,传递实现了Comparator接口的比较器对象.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">TreeSet&lt;Students&gt; ts = <span class="keyword">new</span> TreeSet&lt;Students&gt;(<span class="keyword">new</span> CompareToStudent());</div><div class="line">ts.add(<span class="keyword">new</span> Students(<span class="number">2</span>, <span class="string">"zhangshan"</span>));</div><div class="line">ts.add(<span class="keyword">new</span> Students(<span class="number">3</span>, <span class="string">"lishi"</span>));</div><div class="line">ts.add(<span class="keyword">new</span> Students(<span class="number">1</span>, <span class="string">"wangwu"</span>));</div><div class="line">ts.add(<span class="keyword">new</span> Students(<span class="number">4</span>, <span class="string">"maliu"</span>));</div><div class="line">Iterator&lt;Students&gt; it = ts.iterator();</div><div class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">System.out.println(it.next());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Students</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Students</span>&gt; </span>&#123;</div><div class="line"><span class="keyword">int</span> num;</div><div class="line">String name;</div><div class="line">Students(<span class="keyword">int</span> num, String name) &#123;</div><div class="line"><span class="keyword">this</span>.num = num;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> num + <span class="string">":"</span> + name;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Students o)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> result;</div><div class="line">Students s = (Students) o;</div><div class="line">result = num &gt; s.num ? <span class="number">1</span> : (num == s.num ? <span class="number">0</span> : -<span class="number">1</span>);</div><div class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">result = name.compareTo(s.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareToStudent</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</div><div class="line">Students s1 = (Students) o1;</div><div class="line">Students s2 = (Students) o2;</div><div class="line"><span class="keyword">int</span> rulst = s1.num &gt; s2.num ? <span class="number">1</span> : (s1.num == s2.num ? <span class="number">0</span> : -<span class="number">1</span>);</div><div class="line"><span class="keyword">if</span> (rulst == <span class="number">0</span>) &#123;</div><div class="line">rulst = s1.name.compareTo(s2.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> rulst;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>与HashSet相比，TreeSet还提供了几个额外的方法：</p><ol><li><p>Comparator comparator（）：返回当前set使用的Comparator，或者返回null，表示以自然方式排序。</p></li><li><p>Object first（）：返回集合中的第一个元素。</p></li><li><p>Object last（）：返回集合中的最后一个元素。</p></li><li><p>Object lower（Object e）：返回集合中位于指定元素之前的一个元素。</p></li><li><p>Object higher（Object e）：返回集合中位于指定元素之后的一个元素。</p></li><li><p>SortedSet subSet（from Element，to Element）：返回此set的子集合，范围从from Element到to Element（闭包）。</p></li><li><p>SortedSet headSet（toElement）：返回此Set的子集，由小于toElement的元素组成。</p></li><li><p>SortedSet tailSet（fromElement）：返回此Set的子集，由大于等于fromElement的元素组成。</p></li></ol><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>HashSet还有一个子类LinkedHashSet，其集合也是根据元素hashCode值来决定元素的存储位置，但它同时用链表来维护元素的次序，这样使得元素看起来是以插入的顺序保存的，也就是说，当遍历LinkedHashSet集合元素时，它将会按元素的添加顺序来访问集合里的元素。所以LinkedHashSet的性能略低于HashSet，但在迭代访问全部元素时将有很好的性能，因为它以链表来维护内部顺序。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Iterator And Enumeration</title>
      <link href="/2017/03/26/Iterator-And-Enumeration/"/>
      <url>/2017/03/26/Iterator-And-Enumeration/</url>
      
        <content type="html"><![CDATA[<p>在Java集合中，我们通常都通过 “Iterator(迭代器)” 或 “Enumeration(枚举类)” 去遍历集合。我们先看看 Enumeration.java 和 Iterator.java的源码，再说它们的区别。</p><p>Enumeration是一个接口，它的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Enumeration</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">E <span class="title">nextElement</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Iterator也是一个接口，它的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><a id="more"></a><p>效率比较**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 测试分别通过 Iterator 和 Enumeration 去遍历Hashtable</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorEnumeration</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        Random r = <span class="keyword">new</span> Random();</div><div class="line">        Hashtable table = <span class="keyword">new</span> Hashtable();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++) &#123;</div><div class="line">            <span class="comment">// 随机获取一个[0,100)之间的数字</span></div><div class="line">            val = r.nextInt(<span class="number">100</span>);</div><div class="line">            table.put(String.valueOf(i), val);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 通过Iterator遍历Hashtable</span></div><div class="line">        iterateHashtable(table) ;</div><div class="line">        <span class="comment">// 通过Enumeration遍历Hashtable</span></div><div class="line">        enumHashtable(table);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 通过Iterator遍历Hashtable</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterateHashtable</span><span class="params">(Hashtable table)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">        Iterator iter = table.entrySet().iterator();</div><div class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</div><div class="line">            <span class="comment">//System.out.println("iter:"+iter.next());</span></div><div class="line">            iter.next();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</div><div class="line">        countTime(startTime, endTime);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 通过Enumeration遍历Hashtable</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enumHashtable</span><span class="params">(Hashtable table)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">        Enumeration enu = table.elements();</div><div class="line">        <span class="keyword">while</span>(enu.hasMoreElements()) &#123;</div><div class="line">            <span class="comment">//System.out.println("enu:"+enu.nextElement());</span></div><div class="line">            enu.nextElement();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</div><div class="line">        countTime(startTime, endTime);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countTime</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"time: "</span>+(end-start)+<span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果如下：</p><pre><code>time: 9mstime: 5ms</code></pre><p>从中，我们可以看出。Enumeration 比 Iterator 的遍历速度更快。为什么呢？<br>这是因为，Hashtable中Iterator是通过Enumeration去实现的，而且Iterator添加了对fail-fast机制的支持；所以，执行的操作自然要多一些。</p><p><strong>关于fail-fast机制</strong></p><p>fail-fast，即快速失败，它是Java集合的一种错误检测机制。当多个线程对集合（非fail-safe的集合类）进行结构上的改变的操作时，有可能会产生fail-fast机制，这个时候就会抛出ConcurrentModificationException（当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常）。</p><p>例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p><p>同时需要注意的是，即使不是多线程环境，如果单线程违反了规则，同样也有可能会抛出改异常。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap And HashTable</title>
      <link href="/2017/03/26/HashMap-And-HashTable/"/>
      <url>/2017/03/26/HashMap-And-HashTable/</url>
      
        <content type="html"><![CDATA[<p>HashMap和Hashtable两个类都实现了Map接口，二者保存K-V对（key-value对）；<br>HashSet则实现了Set接口，性质类似于集合。<br>Hashtable的应用非常广泛，HashMap是新框架中用来代替Hashtable的类，也就是说建议使用HashMap，不要使用Hashtable。<br>可能你觉得Hashtable很好用，为什么不用呢？这里简单分析他们的区别。</p><a id="more"></a><h3 id="一、继承的父类不同"><a href="#一、继承的父类不同" class="headerlink" title="一、继承的父类不同"></a>一、继承的父类不同</h3><p>Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类，HashMap是Java1.2引进的Map interface 的一个实现。但二者都实现了Map接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</div></pre></td></tr></table></figure><h3 id="二、线程安全性不同"><a href="#二、线程安全性不同" class="headerlink" title="二、线程安全性不同"></a>二、线程安全性不同</h3><p>Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理。</p><p>HashTable<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> count == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HashMap<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="三、是否提供contains方法"><a href="#三、是否提供contains方法" class="headerlink" title="三、是否提供contains方法"></a>三、是否提供contains方法</h3><p>HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。<br>Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同，实际上containsValue调用的是contains方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">&#125;</div><div class="line">Entry&lt;?,?&gt; tab[] = table;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length ; i-- &gt; <span class="number">0</span> ;) &#123;</div><div class="line"><span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line"><span class="keyword">if</span> (e.value.equals(value)) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> contains(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="四、key和value是否允许null值"><a href="#四、key和value是否允许null值" class="headerlink" title="四、key和value是否允许null值"></a>四、key和value是否允许null值</h3><p>其中key和value都是对象，并且不能包含重复key，但可以包含重复的value。<br>Hashtable中，key和value都不允许出现null值。<br>HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</p><p>HashTable<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line"><span class="comment">// Make sure the value is not null</span></div><div class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">&#125;</div><div class="line"><span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">Entry&lt;?,?&gt; tab[] = table;</div><div class="line"><span class="keyword">int</span> hash = key.hashCode();</div><div class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</div><div class="line"><span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</div><div class="line"><span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</div><div class="line">V old = entry.value;</div><div class="line">entry.value = value;</div><div class="line"><span class="keyword">return</span> old;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">addEntry(hash, key, value, index);</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HashMap<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            (k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="五、两个遍历方式的内部实现上不同"><a href="#五、两个遍历方式的内部实现上不同" class="headerlink" title="五、两个遍历方式的内部实现上不同"></a>五、两个遍历方式的内部实现上不同</h3><p>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</p><h3 id="六、hash值不同"><a href="#六、hash值不同" class="headerlink" title="六、hash值不同"></a>六、hash值不同</h3><p>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p><h3 id="七、内部实现使用的数组初始化和扩容方式不同"><a href="#七、内部实现使用的数组初始化和扩容方式不同" class="headerlink" title="七、内部实现使用的数组初始化和扩容方式不同"></a>七、内部实现使用的数组初始化和扩容方式不同</h3><p>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。<br>HashMap中hash数组的默认大小是16，而且一定是2的指数。</p><p>Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</p><h3 id="我们能否让HashMap同步？"><a href="#我们能否让HashMap同步？" class="headerlink" title="我们能否让HashMap同步？"></a>我们能否让HashMap同步？</h3><p>HashMap可以通过下面的语句进行同步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map m = Collections.synchronizeMap(hashMap);</div></pre></td></tr></table></figure><h3 id="关于ConcurrentHashMap"><a href="#关于ConcurrentHashMap" class="headerlink" title="关于ConcurrentHashMap"></a>关于ConcurrentHashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</div></pre></td></tr></table></figure><p>Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux写时拷贝技术(copy-on-write)</title>
      <link href="/2017/03/23/Linux%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF-copy-on-write/"/>
      <url>/2017/03/23/Linux%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF-copy-on-write/</url>
      
        <content type="html"><![CDATA[<p>源于网上资料</p><p><strong>COW技术初窥：</strong></p><p><strong>Copy-on-write</strong> (sometimes referred to as “COW”) is an optimization strategy used in computer programming. The fundamental idea is that if multiple callers ask for resources which are initially indistinguishable, they can all be given pointers to the same resource. This function can be maintained until a caller tries to modify its “copy” of the resource, at which point a true private copy is created to prevent the changes becoming visible to everyone else. All of this happens transparently to the callers. The primary advantage is that if a caller never makes any modifications, no private copy need ever be created.</p><p>意思上就是：在复制一个对象的时候并不是真正的把原先的对象复制到内存的另外一个位置上，而是在新对象的内存映射表中设置一个指针，指向源对象的位置，并把那块内存的Copy-On-Write位设置为1.</p><p>这样，在对新的对象执行读操作的时候，内存数据不发生任何变动，直接执行读操作；而在对新的对象执行写操作时，将真正的对象复制到新的内存地址中，并修改新对象的内存映射表指向这个新的位置，并在新的内存位置上执行写操作。</p><p>这个技术需要跟虚拟内存和分页同时使用，好处就是在执行复制操作时因为不是真正的内存复制，而只是建立了一个指针，因而大大提高效率。但这不是一直成立的，如果在复制新对象之后，大部分对象都还需要继续进行写操作会产生大量的分页错误，得不偿失。所以COW高效的情况只是在复制新对象之后，在一小部分的内存分页上进行写操作。</p><a id="more"></a><p>在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p><p>那么子进程的物理空间没有代码，怎么去取指令执行exec系统调用呢？</p><p> 在fork之后exec之前两个进程用的是<br><em>相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间</em>，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p><p>在网上看到还有个细节问题就是，fork之后内核会通过将子进程放在队列的前面，以让子进程先执行，以免父进程执行导致写时复制，而后子进程执行exec系统调用，因无意义的复制而造成效率的下降。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统模拟Http请求</title>
      <link href="/2017/03/23/Linux%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9FHttp%E8%AF%B7%E6%B1%82/"/>
      <url>/2017/03/23/Linux%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9FHttp%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>Http请求指的是客户端向服务器的请求消息，Http请求主要分为get或post两种，在Linux系统下可以用curl和wget命令来模拟Http的请求。下面就来介绍一下Linux系统如何模拟Http的get或post请求。</p><h3 id="get请求："><a href="#get请求：" class="headerlink" title="get请求："></a>get请求：</h3><p>1、使用curl命令：</p><pre><code>curl “http://www.baidu.com” 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地curl -i “http://www.baidu.com” 显示全部信息curl -l “http://www.baidu.com” 只显示头部信息curl -v “http://www.baidu.com” 显示get请求全过程解析</code></pre><p>2、使用wget命令：</p><pre><code>wget “http://www.baidu.com” 也可以</code></pre><a id="more"></a><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><p>1、使用curl命令（通过-d参数，把访问参数放在里面）：</p><pre><code>curl -d “param1=value1&amp;m2=value2” “http://www.baidu.com”</code></pre><p>2、使用wget命令：（–post-data参数来实现）</p><pre><code>wget --post-data ‘user=foo&amp;password=bar’ http://www.baidu.com</code></pre><p>以上就是Linux模拟Http的get或post请求的方法了，这样一来Linux系统也能向远程服务器发送消息了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim:替换和查找</title>
      <link href="/2017/03/23/Vim%E6%9B%BF%E6%8D%A2%E5%92%8C%E6%9F%A5%E6%89%BE/"/>
      <url>/2017/03/23/Vim%E6%9B%BF%E6%8D%A2%E5%92%8C%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>Linux VI提供了文件中字符串的查找和全局替换的方法。在命令模式下输入/或？可进入查找模式/输入“/searchstring”，然后回车，VI光标从光标位置开始出现第一次出现的地方。输入n跳到该串的下一个出现处，输入N跳到该串上一次出现的位置。</p><p>在替换时，可指定替换的范围(1,n)，当n为$时指定为最后一行。s是替换命令，g代表全部替换。</p><p><strong>例如：</strong></p><blockquote><p>:1,$ s/pattern1/pattern2/g</p></blockquote><p>将行1至结尾的文字中匹配模式pattern1的字符串替换为pattern2字符串。如无g，则仅替换每一行所匹配的第一个字符串；如有g，则将每一个字符串均作替换。</p><a id="more"></a><p>现有一段文件的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;3.8.1&lt;/version&gt;</div><div class="line">&lt;scope&gt;test&lt;/scope&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">&lt;groupId&gt;com.hand&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;hap-db&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>将所有的dependency字符串替换为test字符串的命令如下：</p><blockquote><p>:1,$ s/dependency/test/g</p></blockquote><p>替换后的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;test&gt;</div><div class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;3.8.1&lt;/version&gt;</div><div class="line">&lt;scope&gt;test&lt;/scope&gt;</div><div class="line">&lt;/test&gt;</div><div class="line">&lt;test&gt;</div><div class="line">&lt;groupId&gt;com.hand&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;hap-db&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">&lt;/test&gt;</div></pre></td></tr></table></figure><p>如果你输入的是</p><blockquote><p>:1,10 s/dependency/test/g</p></blockquote><p>那么你将会替换前面10行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;test&gt;</div><div class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;3.8.1&lt;/version&gt;</div><div class="line">&lt;scope&gt;test&lt;/scope&gt;</div><div class="line">&lt;/test&gt;</div><div class="line">&lt;test&gt;</div><div class="line">&lt;groupId&gt;com.hand&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;hap-db&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2017/03/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/03/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述:"></a>描述:</h3><p>Singleton(单例)是设计模式的一种,为了保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点:"></a>主要特点:</h3><ol><li>单例类确保自己只有一个实例(构造函数私有:不被外部实例化,也不被继承)。</li><li>单例类必须自己创建自己的实例。</li><li>单例类必须为其他对象提供唯一的实例。</li></ol><h3 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用:"></a>单例模式的应用:</h3><p>资源管理器,回收站,打印机资源,线程池,缓存,配置信息类,管理类,控制类,门面类,代理类通常被设计为单例类<br>如果程序有多个类加载器又同时使用单例模式就有可能多个单例并存就要找相应解决方法了</p><a id="more"></a><h3 id="如下细述各种实现方式的优缺点"><a href="#如下细述各种实现方式的优缺点" class="headerlink" title="如下细述各种实现方式的优缺点:"></a>如下细述各种实现方式的优缺点:</h3><blockquote><p>如果应用程序总是创建并使用单例实例或在创建和运行时开销不大。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//饿汉式单例类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;    </div><div class="line">        <span class="comment">// jvm保证在任何线程访问uniqueInstance静态变量之前一定先创建了此实例    </span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> EagerSingleton uniqueInstance = <span class="keyword">new</span> EagerSingleton();    </div><div class="line">        <span class="comment">// 私有的默认构造子，保证外界无法直接实例化    </span></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span> </span>&#123;    </div><div class="line">        &#125;    </div><div class="line">        <span class="comment">// 提供全局访问点获取唯一的实例    </span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;    </div><div class="line">                <span class="keyword">return</span> uniqueInstance;    </div><div class="line">        &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><blockquote><p>如果开销比较大，希望用到时才创建就要考虑延迟实例化,或者Singleton的初始化需要某些外部资源(比如网络或存储设备),就要用后面的方法了.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">懒汉式单例类</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;    </div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton uniqueInstance;    </div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;    </div><div class="line">        &#125;    </div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;    </div><div class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>)    </div><div class="line">                        uniqueInstance = <span class="keyword">new</span> LazySingleton();    </div><div class="line">                <span class="keyword">return</span> uniqueInstance;    </div><div class="line">        &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同步一个方法可能造成程序执行效率下降100倍，完全没有必要每次调用getInstance都加锁，事实上我们只想保证一次初始化成功，其余的快速返回而已,如果在getInstance频繁使用的地方就要考虑重新优化了.</p><hr><blockquote><p>volatile 的功能:</p></blockquote><ol><li>避免编译器将变量缓存在寄存器里  </li><li>避免编译器调整代码执行的顺序</li></ol><p>优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLockingSingleton</span> </span>&#123;    </div><div class="line">        <span class="comment">// java中使用双重检查锁定机制,由于Java编译器和JIT的优化的原因系统无法保证我们期望的执行次序。    </span></div><div class="line">        <span class="comment">// 在java5.0修改了内存模型,使用volatile声明的变量可以强制屏蔽编译器和JIT的优化工作    </span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckedLockingSingleton uniqueInstance;    </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckedLockingSingleton</span><span class="params">()</span> </span>&#123;    </div><div class="line"></div><div class="line">        &#125;     </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckedLockingSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;    </div><div class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;    </div><div class="line">                        <span class="keyword">synchronized</span> (DoubleCheckedLockingSingleton.class) &#123;    </div><div class="line">                                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;    </div><div class="line">                                        uniqueInstance = <span class="keyword">new</span> DoubleCheckedLockingSingleton();    </div><div class="line">                                &#125;    </div><div class="line">                        &#125;    </div><div class="line">                &#125;    </div><div class="line">                <span class="keyword">return</span> uniqueInstance;    </div><div class="line">        &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><blockquote><p>Lazy initialization holder class 满足所有 Double-Checked Locking 满足的条件，并且没有显示的同步操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitHolderSingleton</span> </span>&#123;    </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">LazyInitHolderSingleton</span><span class="params">()</span> </span>&#123;    </div><div class="line">        &#125;       </div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;    </div><div class="line">                <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInitHolderSingleton INSTANCE = <span class="keyword">new</span> LazyInitHolderSingleton();    </div><div class="line">        &#125;        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyInitHolderSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;    </div><div class="line">                <span class="keyword">return</span> SingletonHolder.INSTANCE;    </div><div class="line">        &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><blockquote><p>可通过反射机制攻击“单例模式”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eivis</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Eivis</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Eivis INSTANCE=<span class="keyword">new</span> Eivis();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Eivis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> SingletonHolder.INSTANCE;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingElse</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, </span></div><div class="line">InstantiationException, IllegalAccessException, IllegalArgumentException, </div><div class="line">nvocationTargetException &#123;</div><div class="line">Class classType=Eivis.class;</div><div class="line">Constructor c=classType.getDeclaredConstructor(<span class="keyword">null</span>);</div><div class="line">c.setAccessible(<span class="keyword">true</span>);</div><div class="line">Eivis e1=(Eivis)c.newInstance();</div><div class="line">Eivis e2=Eivis.getInstance();</div><div class="line">System.out.println(e1==e2);<span class="comment">//false</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>单例模式被破坏时抛异常</p></blockquote><p>网上的如下预防措施有问题，思考：flag变量是否也可以通过反射机制改变然后能反射调用私有构造器实例化？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eivis</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Eivis</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">synchronized</span>(Eivis.class)&#123;</div><div class="line"><span class="keyword">if</span>(flag==<span class="keyword">false</span>)&#123;</div><div class="line">flag=!flag;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例模式被侵犯！"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Eivis INSTANCE=<span class="keyword">new</span> Eivis();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Eivis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> SingletonHolder.INSTANCE;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingElse</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;</div><div class="line">Class classType=Eivis.class;</div><div class="line">Constructor c=classType.getDeclaredConstructor(<span class="keyword">null</span>);</div><div class="line">c.setAccessible(<span class="keyword">true</span>);</div><div class="line">Eivis e1=(Eivis)c.newInstance();</div><div class="line">Eivis e2=Eivis.getInstance();</div><div class="line">System.out.println(e1==e2);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><blockquote><p>单元素枚举类实现单例，实现单例的最佳方法更简洁，无偿地提供了序列化机制，绝对防止多次实例化，即使在复杂的序列化或者反射攻击的时候</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> Singleton&#123;</div><div class="line">        INSTANCE;      </div><div class="line">        <span class="keyword">private</span> EnumSingleton singleton;</div><div class="line">        <span class="comment">//JVM会保证此方法绝对只调用一次</span></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">            singleton = <span class="keyword">new</span> EnumSingleton();</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> singleton;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>缺点:</strong>很难隔离测试，通常将“具有单实例行为”的对象当成对一个类的依赖，然后通过依赖注入框架构建单一的对象</p><hr><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>实现单例类的可序列化，仅仅实现Serializable是不够的，为了维护并保证单例，必须声明所有实例域都是瞬时(transient)的，并提供一个readResolve方法，否则每次反序列化一个序列化实例时，都会创建一个新的实例。</p><p>修复的办法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> User <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton&#123;</div><div class="line">        INSTANCE;</div><div class="line">        <span class="keyword">private</span> User user;</div><div class="line">        <span class="comment">//JVM会保证此方法绝对只调用一次</span></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">            user=<span class="keyword">new</span> User();</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> User <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> user;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">        File file=<span class="keyword">new</span> File(<span class="string">"e:/temp"</span>);</div><div class="line">        <span class="keyword">if</span>(!file.exists())&#123;</div><div class="line">            file.createNewFile();</div><div class="line">        &#125;</div><div class="line">        User user1=User.getInstance();</div><div class="line">        ObjectOutputStream oos=<span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</div><div class="line">        oos.writeObject(user1);</div><div class="line">        ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</div><div class="line">        User user2= (User) ois.readObject();</div><div class="line">        System.out.println(user1==user2);<span class="comment">//true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类  装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。</p><p>修复的办法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">getClass</span><span class="params">(String classname)</span><span class="keyword">throws</span> ClassNotFoundException </span>&#123;     </div><div class="line"></div><div class="line">       ClassLoader classLoader = Thread.currentThread().getContextClassLoader();     </div><div class="line">       </div><div class="line"><span class="keyword">if</span>(classLoader == <span class="keyword">null</span>)&#123;</div><div class="line">classLoader = Singleton.class.getClassLoader();     </div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="keyword">return</span> (classLoader.loadClass(classname));     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语法糖</title>
      <link href="/2017/03/20/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
      <url>/2017/03/20/%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2></blockquote><p>与C#中的泛型相比，Java的泛型可以算是“伪泛型”了。在C#中，不论是在程序源码中、在编译后的中间语言，还是在运行期泛型都是真实存在的。Java则不同，Java的泛型只在源代码存在，只供编辑器检查使用，编译后的字节码文件已擦除了泛型类型，同时在必要的地方插入了强制转型的代码。</p><p>泛型代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;  </div><div class="line">List&lt;String&gt; ## stringList = new ArrayList&lt;String&gt;();  </div><div class="line">stringList.add("oliver");  </div><div class="line">System.out.println(stringList.get(0));  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>将上面的代码的字节码反编译后：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </div><div class="line">List stringList = <span class="keyword">new</span> ArrayList();  </div><div class="line">stringList.add(<span class="string">"oliver"</span>);  </div><div class="line">System.out.println((String)stringList.get(<span class="number">0</span>));  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><a id="more"></a><blockquote><h2 id="自动拆箱-装箱"><a href="#自动拆箱-装箱" class="headerlink" title="自动拆箱/装箱"></a>自动拆箱/装箱</h2></blockquote><p>自动拆箱/装箱是在编译期，依据代码的语法，决定是否进行拆箱和装箱动作。装箱过程：把基本类型用它们对应的包装类型进行包装，使基本类型具有对象特征。拆箱过程：与装箱过程相反，把包装类型转换成基本类型。需要注意的是：包装类型的“==”运算在没有遇到算数运算符的情况下不会自动拆箱，而其包装类型的equals()方法不会处理数据类型转换，所以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Integer a = 1;  </div><div class="line">Integer b = 1;  </div><div class="line">Long c = 1L;  </div><div class="line">System.out.println(a == b);  </div><div class="line">System.out.println(c.equals(a));</div></pre></td></tr></table></figure></p><p>这样的代码应该尽量避免自动拆箱与装箱。</p><blockquote><h2 id="循环历遍（foreach）"><a href="#循环历遍（foreach）" class="headerlink" title="循环历遍（foreach）"></a>循环历遍（foreach）</h2></blockquote><p>语法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; ## list = new ArrayList&lt;Integer&gt;();  </div><div class="line">for(Integer num : list)&#123;  </div><div class="line">System.out.println(num);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Foreach要求被历遍的对象要实现Iterable接口，由此可想而知，foreach迭代也是调用底层的迭代器实现的。反编译上面源码的字节码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List list = <span class="keyword">new</span> ArrayList();  </div><div class="line">Integer num;  </div><div class="line">Integer num;  </div><div class="line"><span class="keyword">for</span> (Iterator iterator = list.iterator(); iterator.hasNext(); System.out.println(num))&#123;  </div><div class="line">num = (Integer) iterator.next();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><h2 id="条件编辑"><a href="#条件编辑" class="headerlink" title="条件编辑"></a>条件编辑</h2></blockquote><p>很多编程语言都提供了条件编译的途径，C，C++中使用#ifdef。Java语言并没有提供这种预编译功能，但是Java也能实现预编译。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">true</span>)&#123;  </div><div class="line">System.out.println(<span class="string">"oliver"</span>);  </div><div class="line">&#125;<span class="keyword">else</span>&#123;  </div><div class="line">System.out.println(<span class="string">"lee"</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这段代码的字节码反编译后只有一条语句：System.out.println(“oliver”);  在编译器中，将会把分支不成立的代码消除，这一动作发生在编译器解除语法糖阶段。所以说，可以利用条件语句来实现预编译。</p><blockquote><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2></blockquote><p>枚举类型其实并不复杂，在JVM字节码文件结构中，并没有“枚举”这个类型。其实源程序的枚举类型，会在编译期被编译成一个普通了类。利用继承和反射，这是完全可以做到的。看下面一个枚举类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumTest &#123;  </div><div class="line">OLIVER,LEE;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123;   </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumTest</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(s, i);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumTest[] values() &#123;  </div><div class="line">        EnumTest aenumtest[];  </div><div class="line">        <span class="keyword">int</span> i;  </div><div class="line">        EnumTest aenumtest1[];  </div><div class="line">        System.arraycopy(aenumtest = ENUM$VALUES, <span class="number">0</span>,  </div><div class="line">                aenumtest1 = <span class="keyword">new</span> EnumTest[i = aenumtest.length], <span class="number">0</span>, i);  </div><div class="line">        <span class="keyword">return</span> aenumtest1;  </div><div class="line">    &#125;   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumTest <span class="title">valueOf</span><span class="params">(String s)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> (EnumTest) Enum.valueOf(EnumTest, s);  </div><div class="line">    &#125;   </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumTest OLIVER;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumTest LEE;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumTest ENUM$VALUES[];   </div><div class="line">    <span class="keyword">static</span> &#123;  </div><div class="line">        OLIVER = <span class="keyword">new</span> EnumTest(<span class="string">"OLIVER"</span>, <span class="number">0</span>);  </div><div class="line">        LEE = <span class="keyword">new</span> EnumTest(<span class="string">"LEE"</span>, <span class="number">1</span>);  </div><div class="line">        ENUM$VALUES = (<span class="keyword">new</span> EnumTest[] &#123; OLIVER, LEE &#125;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>至于更多细节，可以参考父类Enum。</p><blockquote><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2></blockquote><p>变长参数允许我们传入到方法的参数是不固定个数。<br>对于这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String str,Object...args)</span></span>&#123;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line">我们可以这样调用：</div><div class="line">foo(<span class="string">"oliver"</span>);  </div><div class="line">foo(<span class="string">"oliver"</span>,<span class="keyword">new</span> Object());  </div><div class="line">foo(<span class="string">"oliver"</span>,<span class="keyword">new</span> Integer(<span class="number">1</span>),<span class="string">"sss"</span>);  </div><div class="line">foo(<span class="string">"oliver"</span>,<span class="keyword">new</span> ArrayList(),<span class="keyword">new</span> Object(),<span class="keyword">true</span>,<span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>参数args可以是任意多个。<br>其实，在编译阶段，args是会被编译成Object [] args。<br>​<br>这样，变长参数就可以实现了。<br>但是要注意的是，变长参数必须是方法参数的最后一项。</p><p>除了上面介绍的语法糖，还有内部类，断言以及JDK7的switch支持字符串，自动关闭资源（在try中定义和关闭）等。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java语法糖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronize And Lock</title>
      <link href="/2017/03/19/Synchronize-And-Lock/"/>
      <url>/2017/03/19/Synchronize-And-Lock/</url>
      
        <content type="html"><![CDATA[<p>在分布式开发中，锁是线程控制的重要途径。Java为此也提供了2种锁机制，synchronized和lock。做为Java爱好者，自然少不了对比一下这2种机制，也能从中学到些分布式开发需要注意的地方。</p><p>我们先从最简单的入手，逐步分析这2种的区别。</p><p><strong>一、synchronized和lock的用法区别</strong></p><p>synchronized：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> SaleStore extends Thread &#123;</div><div class="line"><span class="keyword">private</span> String name;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SaleStore</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SaleStore</span><span class="params">(String name)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.name=name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets=<span class="number">10000</span>;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line"><span class="keyword">while</span>(tickets&gt;<span class="number">0</span>)&#123;</div><div class="line">System.out.println(name+<span class="string">"售出："</span>+tickets);</div><div class="line">tickets--;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Train</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line"><span class="keyword">new</span> SaleStore(<span class="string">"窗口"</span>+<span class="number">1</span>).start();</div><div class="line"><span class="keyword">new</span> SaleStore(<span class="string">"窗口"</span>+<span class="number">2</span>).start();</div><div class="line"><span class="keyword">new</span> SaleStore(<span class="string">"窗口"</span>+<span class="number">3</span>).start();</div><div class="line"><span class="keyword">new</span> SaleStore(<span class="string">"窗口"</span>+<span class="number">4</span>).start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>lock：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.number;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">100</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">this</span>.number++;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line"><span class="keyword">final</span> ReentrantLock reentrantLockDemo = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">500</span> ; i++)&#123;</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">reentrantLockDemo.increase();</div><div class="line">&#125;</div><div class="line">&#125;).start();</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果还有子线程在运行，主线程就让出CPU资源，</span></div><div class="line"><span class="comment">//直到所有的子线程都运行完了，主线程再继续往下执行</span></div><div class="line"><span class="comment">/*while(Thread.activeCount() &gt; 1)&#123;</span></div><div class="line">Thread.yield();</div><div class="line">&#125;*/</div><div class="line">System.out.println(<span class="string">"number : "</span> + reentrantLockDemo.getNumber());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>用法区别比较简单，这里不赘述了，如果不懂的可以看看Java基本语法。</p><p><strong>二、synchronized和lock性能区别</strong></p><p>synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在Java1.5中，synchronize是性能低效的。因为这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。但是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地。</p><p>说到这里，还是想提一下这2中机制的具体区别。据我所知，synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。</p><p>而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。</p><p>现代的CPU提供了指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。这个算法称作非阻塞算法，意思是一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用集合类操作</title>
      <link href="/2017/03/19/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/03/19/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ArrayList</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ArrayList list=<span class="keyword">new</span> ArrayList();</div><div class="line">User zhangsan=<span class="keyword">new</span> User(<span class="string">"张三"</span>,<span class="number">1</span>);</div><div class="line">list.add(zhangsan);</div><div class="line">Dog dog=<span class="keyword">new</span> Dog();</div><div class="line">dog.setName(<span class="string">"哈哈"</span>);</div><div class="line">dog.setAge(<span class="number">1</span>);</div><div class="line">list.add(dog);</div><div class="line"><span class="keyword">for</span> (Object object : list) &#123;</div><div class="line"><span class="keyword">if</span>(object <span class="keyword">instanceof</span> User)&#123;</div><div class="line">User user=(User)object;</div><div class="line">System.out.println(user.getName());</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">Dog user=(Dog)object;</div><div class="line">System.out.println(user.getName());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ArrayList list=<span class="keyword">new</span> ArrayList();</div><div class="line">list.add(<span class="string">"a"</span>);</div><div class="line">list.add(<span class="string">"男"</span>);</div><div class="line">list.add(<span class="string">"a"</span>);</div><div class="line"><span class="comment">//add(index,object)方式插入时要注意插入的位置不能越界</span></div><div class="line">list.add(<span class="number">3</span>,<span class="string">"张三"</span>);</div><div class="line">System.out.println(list);<span class="comment">//[a, 男, a, 张三]</span></div><div class="line">list.set(<span class="number">1</span>,<span class="string">"女"</span>);</div><div class="line">System.out.println(list);<span class="comment">//[a, 女, a, 张三]</span></div><div class="line"><span class="comment">//根据位置来删除</span></div><div class="line">list.remove(<span class="string">"a"</span>);</div><div class="line">System.out.println(list);<span class="comment">//[女, a, 张三]</span></div><div class="line">list.remove(<span class="number">1</span>);</div><div class="line">System.out.println(list);<span class="comment">//[女, 张三]</span></div><div class="line">System.out.println(list.get(<span class="number">1</span>));<span class="comment">//张三</span></div><div class="line"><span class="comment">//集合的大小</span></div><div class="line">System.out.println(list.size());<span class="comment">//2</span></div></pre></td></tr></table></figure><blockquote><p>LinkedList</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">LinkedList list=<span class="keyword">new</span> LinkedList();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200</span>;i++)&#123;</div><div class="line">    list.add(i);</div><div class="line">&#125;</div><div class="line">list.addFirst(<span class="keyword">new</span> User(<span class="string">"张三"</span>,<span class="number">1</span>));</div><div class="line"><span class="keyword">int</span> count=<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(list.size()!=<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(count%<span class="number">3</span>==<span class="number">0</span>)&#123;</div><div class="line">        list.removeFirst();</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        list.addLast(list.removeFirst());</div><div class="line">    &#125;</div><div class="line">    count++;</div><div class="line">&#125;</div><div class="line">System.out.println(list.getFirst());</div></pre></td></tr></table></figure><blockquote><p>HashMap</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;String, String&gt; hm=<span class="keyword">new</span> HashMap&lt;String,String&gt;();</div><div class="line">hm.put(<span class="string">"name"</span>, <span class="string">"张三"</span>);</div><div class="line">hm.put(<span class="string">"age"</span>, <span class="string">"18"</span>);</div><div class="line">System.out.println(hm.get(<span class="string">"name"</span>));</div><div class="line">hm.remove(<span class="string">"name1"</span>);</div><div class="line">System.out.println(hm.get(<span class="string">"name"</span>));</div><div class="line">Set&lt;String&gt; keys=hm.keySet();</div><div class="line"><span class="keyword">for</span> (String string : keys) &#123;</div><div class="line">System.out.println(string+<span class="string">"--"</span>+hm.get(string));</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(String value:hm.values())&#123;</div><div class="line">System.out.println(value);</div><div class="line">&#125;</div><div class="line">Set&lt;Entry&lt;String, String&gt;&gt; entries=hm.entrySet();</div><div class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entries) &#123;</div><div class="line">System.out.println(entry.getValue());</div><div class="line">System.out.println(entry.getKey());</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>HashSet</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">HashSet hs=<span class="keyword">new</span> HashSet();</div><div class="line">hs.add(<span class="string">"a"</span>);</div><div class="line">hs.add(<span class="string">"b"</span>);</div><div class="line">hs.add(<span class="string">"c"</span>);</div><div class="line">HashSet hs1=<span class="keyword">new</span> HashSet();</div><div class="line">hs1.add(<span class="string">"e"</span>);</div><div class="line">hs1.add(<span class="string">"d"</span>);</div><div class="line">hs1.add(<span class="string">"c"</span>);</div><div class="line">hs.addAll(hs1);</div><div class="line"><span class="comment">//去重的方法</span></div><div class="line">System.out.println(hs.size());</div><div class="line">Iterator it=hs.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">System.out.println(it.next());</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"*************"</span>);</div><div class="line"><span class="comment">//for(集合中每个元素的类型 对应元素的形参 : 集合)</span></div><div class="line"><span class="keyword">for</span> (Object object : hs) &#123;</div><div class="line">System.out.println(object);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>其他</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List list=Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>);</div><div class="line">Collections.sort(list);</div><div class="line">System.out.println(list);</div></pre></td></tr></table></figure><p><code>System.arraycopy(integers,0,newIntegersArray,0,integers.length);</code></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用集合类</title>
      <link href="/2017/03/19/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>/2017/03/19/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Collection接口</p></blockquote><ul><li>List接口（允许有重复元素）：ArrayList、LinkedList、Vector、Stack</li><li>Set接口（不允许有重复元素，可用于去重操作）：HashSet、TreeSet</li></ul><blockquote><p>对于Collection需要掌握的七点内容</p></blockquote><ul><li><p>Collection的创建：即构造器，掌握在构造器方法中Collection的实现类做了一些什么</p></li><li><p>往Collection中添加对象：即add(E)方法–&gt;类的实现方式决定了此方法的性能</p></li><li><p>删除Collection中的对象：即remove(E)方法–&gt;类的实现方式决定了此方法的性能</p></li><li><p>获取Collection中的单个对象：即get(int index)方法–&gt;类的实现方式决定了此方法的性能</p></li><li><p>遍历Collection中的对象：即iterator，在实际中更常用的是增强型的for循环去做遍历</p></li><li><p>判断对象是否存在于Collection中：contain(E)–&gt;类的实现方式决定了此方法的性能</p></li><li><p>Collection中对象的排序：主要取决于所采取的排序算法</p><a id="more"></a></li></ul><blockquote><p>对于Map需要掌握的七点内容</p></blockquote><ul><li>Map的创建：即构造器，掌握在构造器方法中Map的实现类做了一些什么</li><li>往Map中添加键值对：即put(Object key, Object value)方法</li><li>删除Map中的对象：即remove(Object key)方法</li><li>获取Map中的单个对象：即get(Object key)方法</li><li>判断对象是否存在于Map中：containsKey(Object key)</li><li>遍历Map中的对象：即keySet()和iterator，在实际中更常用的是增强型的for循环去做遍历</li><li>Map中对象的排序：主要取决于所采取的排序算法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
